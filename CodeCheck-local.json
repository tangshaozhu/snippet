{
	"updateTime": "2023-01-16 16:45:49",
	"ruleSets": [
		{
			"rules": [
				{
					"name": "G.CMT.01-CPP 注释符与注释内容间留有1个空格",
					"language": "c++",
					"id": "51cb81b80fef11eda7be84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "注释符与注释内容之间留有1个空格。\n注释符包括： /* */和 //。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "按要求增加/减少空格",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CMT.02-CPP 代码注释置于对应代码的上方或右边",
					"language": "c++",
					"id": "51cba8ca0fef11ed830c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "针对代码的注释，应该置于对应代码的上方或右边。\n\n代码上方的注释：与代码行间无空行，保持与代码一样的缩进\n代码右边的注释：与代码之间，至少留有1空格\n通常右边的注释内容不宜过多，当注释超过行宽时，考虑将注释置于代码上方。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "按要求放置代码注释",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CMT.03-CPP 文件头注释包含版权说明",
					"language": "c++",
					"id": "51cba8cc0fef11ed9ffb84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "文件头注释应首先包含版权说明。\n如果文件头注释需要增加其他内容，可以在版权说明下面补充。例如：文件功能说明、作者、创建日期、注意事项等等。\n\n版权说明的内容及格式如下，其内容可根据实际情况做调整，参见下面的详细说明。\n中文版：\n版权所有 (c) 华为技术有限公司 2012-2018\n英文版：\nCopyright (c) Huawei Technologies Co., Ltd. 2012-2018. All rights reserved.\n\n详细说明\n\n2012-2018 根据实际需要可以修改\n2012 是文件首次创建年份，而 2018 是文件最后修改年份\n对文件有重大修改时，必须更新后面年份，如特性扩展，重大重构等\n可以只写一个创建年份，后续文件修改则不用更新版权声明\n如：版权所有 (c) 华为技术有限公司 2012\n或英文：Copyright (c) Huawei Technologies Co., Ltd. 2012. All rights reserved.\n版权说明可以使用华为子公司\n如：版权所有 (c) 海思半导体 2012-2018\n或英文：Copyright (c) Hisilicon Technologies Co., Ltd. 2012-2018. All rights reserved.\n对于华为自研用于外部开源的产品与代码，英文中的 ‘All rights reserved.’ 可省略",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "添加版权声明",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": false
				},
				{
					"name": "G.CMT.04-CPP 不写空有格式的函数头注释",
					"language": "c++",
					"id": "51cba8ce0fef11ed91c784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "尽量通过函数名自注释其功能，按需写函数头注释。不要写空有格式的函数头注释；不要写无用、信息冗余的函数头注释。\n\n函数头注释分为函数声明处的注释和函数定义处的注释，这两类注释的目标不同，内容也应不同:\n\n函数声明处的注释的目的是传递函数原型无法表达却又希望读者知道的信息，描述函数的功能以及如何使用它\n函数定义处的注释的目的是传递希望读者知道的函数实现细节，例如使用的算法、为什么这样实现等",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "/*\n * 返回实际写入的字节数，-1表示写入失败\n * 注意，len小于INT_MAX\n */\nint WriteData(const unsigned char *buf, size_t len);",
					"badExample": "/*\n * 函数名：WriteData\n * 功能：写入字符串\n * 参数：\n * 返回值：\n */\nint WriteData(const unsigned char* buf, size_t len);",
					"recommend": "补充内容或者删除空有格式的注释",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.43-CPP 不用的代码段直接删除，不要注释掉",
					"language": "c++",
					"id": "51cba8d00fef11ed8a8d84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "被注释掉的代码，无法被正常维护；当企图恢复使用这段代码时，极有可能引入易被忽略的缺陷。\n正确的做法是，不需要的代码直接删除掉。若再需要时，考虑移植或重写这段代码。\n\n这里说的“注释掉”的方式，除了 /* */ 或 //、还包括 #if 0、 #ifdef NEVER_DEFINED 等等。\n\n说明：注释中的代码示例不属于被注释掉的代码。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "删除无用代码",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CMT.05-CPP 正式交付给客户的代码不应包含TODO/TBD/FIXME注释",
					"language": "c++",
					"id": "51cba8d20fef11edb0c184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "TODO/TBD注释2用来描述已知待改进、待补充的修改点。\nFIXME 注释2用来描述已知缺陷。\n\n正式交付给客户的代码中不能包含这类注释，并且它们都应该有统一风格，方便文本搜索统一处理。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "改进代码或者删除注释",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CNS.01-CPP 禁止使用小写字母“l”作为数值型常量后缀",
					"language": "c++",
					"id": "51cba8d40fef11ed885584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "C++标准允许使用后缀来显式指定数值型字面量的类型，例如：整数字面量可以使用后缀字母 l 或 L 表示long类型，使用字母 ll 或 LL 表示 long long类型。\n当使用小写字母 l 指定数值型字面量类型时，在视觉上容易和数字 1 混淆。为了避免这种混淆带来的误解，应使用大写字母 L 或 LL 作为数值型字面量的后缀。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "constexpr long long BARRETT_REDUCTION = 0xFF6511LL;\nconstexpr long double MAX_DEGREE = 180.0L;",
					"badExample": "constexpr long long BARRETT_REDUCTION = 0xFF6511ll;\nconstexpr long double MAX_DEGREE = 180.0l;",
					"recommend": "小写\"l\"替换成大写\"L\"",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CNS.02-CPP 不要使用难以理解的字面常量",
					"language": "c++",
					"id": "51cba8d60fef11ed9ec684a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "难以理解的字面量是指通过代码的上下文难以明确业务含义的字面量，包括整型字面量、浮点数字面量、布尔字面量和字符串字面量等。\n\n有时候字面量在上下文中是能够理解其含义的，有时候则不能：\n例如：value = 1000; 不能明确1000代表什么类型；但 millisecond = second * 1000; 可以很容易理解为1秒是1000毫秒。\n又如：数字 0 有时候也是难以理解的，比如 status = 0;，无法明确 0 是什么状态。\n\n解决途径：\n\n对于单点使用的难以理解的字面量，按需增加注释说明\n对于多处使用的难以理解的字面量，应该定义为 constexpr 或 const 常量，并通过符号命名自注释",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "constexpr int SERV_TYPE_SET = 1;\nconstexpr int SERV_TYPE_QUERY = 4;\nconstexpr int ADULT_AGE = 18;\nint currentType = psInParam-&gt;GetValue(\"servType\");\n\nif (currentType == SERV_TYPE_SET) {\n    ...\n} else if (currentType == SERV_TYPE_QUERY) {\n    ...\n} else {\n    ...\n}\n\nif (age &gt;= ADULT_AGE) {\n    ...\n} else {\n    ...\n}\nconst std::string VERSION{\"V100R011C10\"};\n...\nstd::string srcDataVer;\n...\nbool cond = (srcDataVer.find(VERSION) == 0);",
					"badExample": "int currentType = psInParam-&gt;GetValue(\"servType\");\n\n// 下面使用的整数字面量，不容易理解其具体含义  \nif (currentType == 1) {\n    ...\n} else if (currentType == 4) {\n    ...\n} else {\n    ...\n}\n\nif (age &gt;= 18) {\n    ...\n} else {\n    ...\n}\nchar srcDataVer[VERSION_MAX_LEN] = {0};\n...\nbool cond = (strncmp(srcDataVer, \"V100R011C10\", strlen(\"V100R01C10\")) == 0);",
					"recommend": "对于单点使用的难以理解的常量，按需增加注释说明。对于\n多处使用的难以理解的常量，应该定义宏或 const 变量，并通过符号命名自注释 。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": false
				},
				{
					"name": "G.ERR.08-CPP 如果catch子句中不做任何操作，应添加注释说明原因",
					"language": "c++",
					"id": "51cba8d80fef11ed837084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "有的时候，程序员会因为程序抛出了异常，而想当然地使用try捕获异常，在catch里什么也不做，以使程序不再因异常而终止。但是，捕获到异常而不处理，相当于掩盖了问题。空白的catch块通常是这种掩盖问题的做法的表现。\n\n然而，有时候，某些异常的正确处理方法就是什么也不做，例如：\n\n对肮脏的数据进行统计时，忽略坏的数据，剩余的好数据仍然具有统计学意义\n对于IO操作，如果因为读到输入的结尾而抛出异常，就应该停止读取，继续下一步工作\n为了区别有意的“什么也不做”和因为疏忽而“掩盖异常”，应在空的catch块中添加注释，说明为何什么也不做。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "std::vector&lt;double&gt; results;\nfor (auto& data : dataSet) {\n    try {\n        double result = Process(data);\n        results.push_back(result);\n    } catch (const BadDataException& e) {\n        // 忽略错误的数据。虽然数据集没有被清理，但已有足够的好数据来计算最终结果\n    }\n}",
					"badExample": "std::vector&lt;double&gt; results;\nfor (auto& data : dataSet) {\n    try {\n        double result = Process(data);\n        results.push_back(result);\n    } catch (const BadDataException& e) {\n    }\n}",
					"recommend": "添加异常处理或者注释说明",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FUN.01-CPP 函数功能要单一——函数嵌套层次",
					"language": "c++",
					"id": "51cba8da0fef11ed8ace84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "功能单一的函数，更有利于理解和维护。对于功能不单一函数，可以进行进一步拆分或分层处理。\n\n可从如下维度间接衡量函数功能是否单一：\n\n函数行数，建议不超过50行（非空非注释）\n函数的参数个数，建议不超过5个\n函数最大代码块嵌套深度，建议不超过4层",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "对代码进行重构，减少函数复杂度",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FUN.01-CPP 函数功能要单一——函数大小",
					"language": "c++",
					"id": "51cba8dc0fef11edbed384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "功能单一的函数，更有利于理解和维护。对于功能不单一函数，可以进行进一步拆分或分层处理。\n\n可从如下维度间接衡量函数功能是否单一：\n\n函数行数，建议不超过50行（非空非注释）\n函数的参数个数，建议不超过5个\n函数最大代码块嵌套深度，建议不超过4层",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "对代码进行重构，减少函数复杂度",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.INT.09 确保枚举常量映射到唯一值",
					"language": "c++",
					"id": "51cbcfcf0fef11eda1a884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "C语言的枚举类型是具有一组有限值的集合，这些值的标识符被称为枚举常量。枚举常量是一个整数常量表达式，其值可表示为int。尽管C语言允许相同枚举类型中的多个枚举常量具有相同的值，但是人们普遍期望同一个枚举类型中的枚举常量具有不同的值。因此，将同一个枚举类型中的多个枚举常量定义为相同的值可能会导致一些不易被发现的错误。",
					"systemTag": "clangtidy",
					"goodExample": "为了防止出现错误代码示例中的问题，枚举类型声明可以采用以下形式之一：\n\n不提供显式的整数赋值，如下示例所示\ntypedef enum {\n    ERR_SYS_ARG_ERR,\n    ERR_SYS_SET_ERR,\n    ERR_SYS_OCCUPIED_ERR,\n    ERR_SYS_REQFREE_ERR,\n    ERR_SYS_NO_REC_ERR,\n    ERR_SYS_ACTIVED_ERR,\n    ERR_SYS_NO_FILE_ERR,\n    ERR_SYS_OPEN_ERR,\n    ERR_SYS_ASSIGN_ERR,\n    ERR_SYS_ALLOC_ERR,\n    ERR_SYS_GET_LIST_ERR,\n    ERR_SYS_IGNORE_ERR,\n    ERR_SYS_REG_ERR,\n    ERR_SYS_CALC_ERR,\n    ERR_SYS_SNED_ERR,\n    ERR_SYS_RECV_ERR,\n    ERR_SYS_MODIFY_ERR,\n    ERR_SYS_CHECK_ERR,\n\n    ERR_EMG_INVALID_ERR,\n    ERR_EMG_TYPE_ERR,\n    ...\n} SomeModuleErrCodes;\n只对第一个成员赋值，如下示例所示\ntypedef enum {\n    ERR_SYS_ARG_ERR      = 0x3a020000,\n    ERR_SYS_SET_ERR,\n    ERR_SYS_OCCUPIED_ERR,\n    ERR_SYS_REQFREE_ERR,\n    ERR_SYS_NO_REC_ERR,\n    ERR_SYS_ACTIVED_ERR,\n    ERR_SYS_NO_FILE_ERR,\n    ERR_SYS_OPEN_ERR,\n    ERR_SYS_ASSIGN_ERR,\n    ERR_SYS_ALLOC_ERR,\n    ERR_SYS_GET_LIST_ERR,\n    ERR_SYS_IGNORE_ERR,\n    ERR_SYS_REG_ERR,\n    ERR_SYS_CALC_ERR,\n    ERR_SYS_SNED_ERR,\n    ERR_SYS_RECV_ERR,\n    ERR_SYS_MODIFY_ERR,\n    ERR_SYS_CHECK_ERR,\n\n    ERR_EMG_INVALID_ERR,\n    ERR_EMG_TYPE_ERR,\n    ...\n} SomeModuleErrCodes;\n在上面的两个选项中，除非第一个枚举数必须具有非零值，否则第一种做法是最简单的方法，因此也是首选方法。",
					"badExample": "如下代码示例中，在枚举类型SomeModuleErrCodes中定义错误码的时候，为两个枚举常量分配了显式值，造成 ERR_SYS_MODIFY_ERR 和 ERR_EMG_INVALID_ERR 被隐式声明为相同的值（0x3a020010），对于程序员来说，可能并不明显。\n这种定义可能导致的错误是尝试将枚举常量用于 switch 语句的标签。由于 switch 语句中的所有标签都必须是唯一的，因此如下代码违反了此语义约束。\n\ntypedef enum {\n    ERR_SYS_ARG_ERR = 0x3a020000,\n    ERR_SYS_SET_ERR,\n    ERR_SYS_OCCUPIED_ERR,\n    ERR_SYS_REQFREE_ERR,\n    ERR_SYS_NO_REC_ERR,\n    ERR_SYS_ACTIVED_ERR,\n    ERR_SYS_NO_FILE_ERR,\n    ERR_SYS_OPEN_ERR,\n    ERR_SYS_ASSIGN_ERR,\n    ERR_SYS_ALLOC_ERR,\n    ERR_SYS_GET_LIST_ERR,\n    ERR_SYS_IGNORE_ERR,\n    ERR_SYS_REG_ERR,\n    ERR_SYS_CALC_ERR,\n    ERR_SYS_SNED_ERR,\n    ERR_SYS_RECV_ERR,\n    ERR_SYS_MODIFY_ERR,    // 不符合：值与ERR_EMG_INVALID_ERR相同\n    ERR_SYS_CHECK_ERR,     // 不符合：值与ERR_EMG_TYPE_ERR相同\n\n    ERR_EMG_INVALID_ERR = 0x3a020010,\n    ERR_EMG_TYPE_ERR,\n    ...\n} SomeModuleErrCodes;",
					"recommend": "（1）纠正编码错误，或者（2）显式指定枚举值",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.NAM.01-CPP C++文件以.cpp为扩展名，头文件以.h为扩展名",
					"language": "c++",
					"id": "51cbcfd10fef11ed9e2584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "推荐使用.h作为头文件的扩展名，这样头文件可以直接兼容C和C++。\n推荐使用.cpp作为C++源文件的扩展名，这样可以明确源文件中是C++代码，而不是C代码。\n\n目前业界还使用一些其他的扩展名：\n\n头文件： .hh, .hpp, .hxx\ncpp文件：.cc, .cxx, .C\n如果当前项目组已经使用了这些扩展名，那么可以继续使用，并保持风格统一。\n\nC++20中推出了新特性Modules，可以根据编译器的支持情况选择Module源文件的扩展名。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "修改头文件扩展名",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.NAM.02-CPP C++文件名和类名保持一致",
					"language": "c++",
					"id": "51cbcfd30fef11edb0fc84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "C++的头文件和源文件名应该和类名保持一致，可以使用大驼峰或者小写下划线风格。项目组可以选择一种风格约定执行，并保持风格统一。\n\n例如，有一个类叫DatabaseConnection，那么对应的文件名如下：\n\nDatabaseConnection.h\nDatabaseConnection.cpp\n或者使用如下文件名：\n\ndatabase_connection.h\ndatabase_connection.cpp\n结构体，命名空间，枚举等定义的文件名类似。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "修改文件名或类名",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.02-CPP 使用函数代替函数式宏",
					"language": "c++",
					"id": "51cbcfd50fef11ed93f284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "定义函数式宏前，应考虑能否用函数替代。对于可替代场景，建议用函数替代宏。\n\n函数式宏的缺点如下：\n\n函数式宏缺乏类型检查，不如函数调用检查严格\n宏展开时宏参数不求值，可能会产生非预期结果\n宏没有独立的作用域\n宏的技巧性太强，例如#的用法和无处不在的括号，影响可读性\n在特定场景中必须用编译器对宏的扩展语法，如GCC的statement expression，影响可移植性\n宏在预编译阶段展开后，在其后编译、链接和调试时都不可见；而且包含多行的宏会展开为一行。函数式宏难以调试、难以打断点，不利于定位问题\n对于包含大量语句的宏，在每个调用点都要展开。如果调用点很多，会造成代码空间的膨胀",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "int Max(int a, int b)\n{\n    return (a &lt; b) ? b : a;\n}",
					"badExample": "#define MAX(a, b) (((a) &lt; (b)) ? (b) : (a))",
					"recommend": "将函数式宏修改为函数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.03 包含多条语句的函数式宏的实现语句必须放在 do-while(0) 中",
					"language": "c++",
					"id": "51cbcfd70fef11ed890484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "宏本身没有代码块的概念。当宏在调用点展开后，宏内定义的表达式和变量融合到调用代码中，可能会出现变量名冲突和宏内语句被分割等问题。\n通过 do-while(0) 显式为宏加上边界，让宏有独立的作用域，并且跟分号能更好的结合而形成单条语句，从而规避此类问题。\n\n【例外】\n\n包含 break, continue 语句的宏可以例外，使用此类宏务必特别小心（G.PRE.05 函数式宏定义中慎用 return、goto、continue、break 等改变程序流程的语句）。\n宏中包含不完整语句时，可以例外。比如用宏封装 for 循环的条件部分。\n非多条语句，或单个 if/for/while/switch 语句，可以例外。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "如下示例代码，会出现编译报错(else没有与之匹配的if语句)：\n\nif (condition)\n    FOO(MAX_MONTH);\nelse\n    FOO(MAX_YEAR);\n更好的写法是用 do-while(0) 把宏FOO执行体括起来，如下所示：\n\n// 符合\n#define FOO(x) do { \\\n    (void)printf(\"arg is %d\\n\", (x)); \\\n    DoSomething((x)); \\\n} while (0)",
					"badExample": "如下所示的宏是错误的用法（为了说明问题，示例代码稍不符规范）：\n\n// 不符合\n#define FOO(x) \\\n    (void)printf(\"arg is %d\\n\", (x)); \\\n    DoSomething((x));\n当像如下示例代码这样调用宏FOO，for 循环只执行了宏的第一条语句，宏的后一条语句只在循环结束后执行一次。\n\nfor (i = 1; i &lt; MAX_TIMES; i++)\n    FOO(i);\n用大括号将FOO定义的语句括起来可以解决上面的问题：",
					"recommend": "用do-while(0)封装代码块",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.05 函数式宏定义中慎用 return、goto、continue、break 等改变程序流程的语句",
					"language": "c++",
					"id": "51cbcfd90fef11eda0e784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "宏中使用 return、goto、continue、break等改变流程的语句，虽然能简化代码，但同时也隐藏了真实流程，不易于理解，存在过度封装，容易导致资源泄漏等问题。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "【例外】\n用于返回值判断等异常处理场景的宏可以包含改变程序流程的语句。\n\n注意：包含 return、goto、continue、break等改变流程语句的宏命名，务必要体现对应关键字。\n比如：\n\n#define RETURN_IF(condition, retValue) \\\n    if (condition) { \\\n        RecordFailInfo(__FILE__, __LINE__); \\\n        return retValue; \\\n    }",
					"badExample": "如下是宏封装 return 容易导致过度封装和使用的场景：\n\n如下代码，status的判断是主干流程的一部分，用宏封装起来后，变得不直观了，阅读时习惯性把RETURN_IF宏忽略掉了，从而导致对主干流程的理解有偏差。\n\n#define LOG_AND_RETURN_IF_FAIL(ret, fmt, ...) do { \\\n    if ((ret) != OK) { \\\n        (void)ErrLog(fmt, ##__VA_ARGS__); \\\n        return (ret); \\\n    } \\\n} while (0)\n\n#define RETURN_IF(cond, ret) do { \\\n    if (cond) { \\\n        return (ret); \\\n    } \\\n} while (0)\n\nret = InitModuleA(a, b, &status);\nLOG_AND_RETURN_IF_FAIL(ret, \"Init module A failed!\"); // 符合\n\nRETURN_IF(status != READY, ERR_NOT_READY); // 不符合： 重要逻辑不明显\n\nret = InitModuleB(c);\nLOG_AND_RETURN_IF_FAIL(ret, \"Init module B failed!\"); // 符合\n如下是宏封装 return 也容易引发内存泄漏的场景：\n\n#define CHECK_PTR(ptr, ret) do { \\\n    if ((ptr) == NULL) { \\\n        return (ret); \\\n    } \\\n} while (0)\n\n...\n\nmem1 = MemAlloc(STR_SIZE_MAX);\nCHECK_PTR(mem1, ERR_CODE_XXX);\n\nmem2 = MemAlloc(STR_SIZE_MAX);\nCHECK_PTR(mem2, ERR_CODE_XXX); // 内存泄漏问题\n如果 mem2 申请内存失败了，CHECK_PTR 会直接返回，而没有释放 mem1。\n\n除此之外，CHECK_PTR 宏命名也不好，宏名只反映了检查动作，没有指明结果。只有看了宏实现才知道指针为空时返回失败。\n\n综上所述：\n\n不推荐宏定义中封装 return、goto、continue、break 等改变程序流程的语句；",
					"recommend": "重构代码逻辑，避免安全隐患",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.05-CPP 所有\\#else、\\#elif、\\#endif和与之对应的\\#if、\\#ifdef、\\#ifndef预处理指令应出现在同一文件中",
					"language": "c++",
					"id": "51cbcfdb0fef11ed8c9684a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "当使用多个文件来构成这些预处理块时，难以直观发现代码块的关联，增加了阅读和维护的复杂度，从而更容易产生错误。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "// sample.h 开始  \n#if defined(__VXWORKS__)    // 在相同文件中闭合该预处理块  \n#include \"vx_config.h\"\n#endif\n// sample.h 结束",
					"badExample": "// sample.h 开始  \n#if defined(__VXWORKS__)  // 未在相同文件中闭合该预处理块\n#include \"vx_config.h\"\n\n// 这里结束前，本应当有 #endif 与前面的 #if defined 形成闭合  \n// sample.h 结束",
					"recommend": "预处理指令在同一个文件中闭合",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.06 函数式宏要简短",
					"language": "c++",
					"id": "51cbcfdd0fef11edac5284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "函数式宏本身的一大问题是比函数更难以调试和定位，特别是宏过长，调试和定位的难度更大。\n\n而且宏扩展会导致目标代码膨胀。建议函数式宏不要超过10行（非空非注释）。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "减少函数式宏的复杂度或者改成函数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.07 宏的名称不应与关键字相同",
					"language": "c++",
					"id": "51cbcfdf0fef11edaa6084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "使用宏来改变语言关键字（包括用于实现语言扩展的关键字）的含义会导致代码难以理解。如果定义这种宏的同时又包含了标准头文件，则程序会产生未定义行为。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "// 不符合：改变了int的行为，导致后面包含标准头文件时，程序出现未定义的行为\n#define int OTHER_TYPE\n#include &lt;stdlib.h&gt;\n\n// 不符合：重定义关键字\n#define while(x) for (; (x);)",
					"recommend": "修改宏的名称",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.09 宏定义不以分号结尾",
					"language": "c++",
					"id": "51cbcfe10fef11ed85eb84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "当宏定义的结尾有分号时，从代码中难以直观发现语句的结束，降低了程序语句的可读性，并增加了程序员在使用宏时额外增加分号的可能(不小心额外增加的分号可能导致程序流程错误)。因此，宏末尾的分号应由使用者提供，宏定义不应以分号结尾。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "在宏定义的末尾不使用分号，而将是否使用分号的决定权交给宏的使用者：\n\n#define LOOP(count)  for (int i = 0; i &lt; (count); i++)\n\nint count = ...;\nLOOP(5) {\n    puts(\"In a loop\\n\");\n}",
					"badExample": "示例用宏定义for语句中的循环头。此宏使用了一个表示循环次数的整数参数，程序员错误地在宏定义的结尾加了分号。\n\n#define LOOP(count)  for (int i = 0; i &lt; (count); i++);\n\nint count = ...;\nLOOP(5) {\n    puts(\"In a loop\\n\");\n}\n程序员希望从代码中获得以下输出：\n\nIn a loop\nIn a loop\nIn a loop\nIn a loop\nIn a loop",
					"recommend": "删除多余的分号",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.01-CPP 非纯ASCII码源文件使用UTF-8编码",
					"language": "c++",
					"id": "51cbcfe30fef11edb10284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "对于含有非ASCII字符的源文件，使用UTF-8编码。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "class Base {\npublic:\n    Base();\n    virtual ~Base() = default;\n    virtual void Log();        // 不同的派生类调用不同的日志文件\n};\n\nBase::Base()                   // 基类构造函数\n{\n    Log();                     // 不符合：调用虚函数Log\n}\n\nclass Derived : public Base {\npublic:\n    void Log() override;\n};",
					"recommend": "使用UTF-8编码",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.02-CPP 使用空格进行缩进，每次缩进4个空格",
					"language": "c++",
					"id": "51cbf6d90fef11ed9e3384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "建议使用空格进行缩进，每次缩进为 4 个空格。避免使用制表符(‘\\t’)进行缩进。\n当前几乎所有的集成开发环境（IDE）和代码编辑器都支持配置将Tab键自动扩展为 4 空格输入。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "按要求进行缩进",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.03-CPP 使用统一的大括号换行风格",
					"language": "c++",
					"id": "51cbf6db0fef11edb65884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "选择并统一使用一种大括号换行风格，避免多种风格并存。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "使用相应的大括号换行风格",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.04-CPP 每个变量单独一行进行声明或赋值",
					"language": "c++",
					"id": "51cbf6dd0fef11edb03a84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "一个变量的声明或者赋值语句应该单独占一行，更加利于阅读和理解代码。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "int count = 10;\nbool isCompleted = false;\nint a = 0;\nint b = 0;\n\nint x;\nint y;\n...\nx = 1;\ny = 2;",
					"badExample": "int count = 10; bool isCompleted = false; // 不符合：多个变量初始化需要分开放在多行\n\nchar* str, ch, arr[10];                   // 不符合：多个变量定义且类型不同，容易产生误解\nint a = 0, b = 0;                         // 不符合：多个变量定义需要分开放在多行\n\nint x;\nint y;\n...\nx = 1; y = 2;                             // 不符合：一行中存在多个赋值语句",
					"recommend": "将语句拆分到多行",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.05-CPP 行宽不超过120个字符",
					"language": "c++",
					"id": "51cbf6df0fef11edbd2784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "代码行宽不宜过长，否则不利于阅读。\n控制行宽可以间接的引导程序员去缩短函数、变量的命名，减少嵌套的层数，提升代码的可读性。\n建议每行字符数不要超过 120 个；除非超过 120 能显著提升可读性，并且不会隐藏信息。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "在合适的位置换行",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.06-CPP 换行时将操作符留在行末，新行缩进一层或进行同类对齐——函数声明参数换行",
					"language": "c++",
					"id": "51cbf6e10fef11edab7984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "当语句过长，或者可读性不佳时，需要在合适的地方换行。\n换行时将操作符、连接符放在行末，表示“未结束，后续还有”。新行缩进一层，或者保持同类对齐。\n\n调用函数的参数列表换行时，左圆括号总是跟函数名，右圆括号总是跟最后一个参数，并进行合理的参数对齐。\n\n2选择在较低优先级操作符或连接符后换行，或者根据表达式层次换行。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "长表达式举例：\n\n// 假设下面第一行已经不满足行宽要求\nif (currentValue &gt; MIN &&  // 符合：换行后，布尔操作符放在行末\n    currentValue &lt; MAX) {  // 符合: 与(&&)操作符的两个操作数同类对齐\n    DoSomething();\n    ...\n}\n\nflashPara.flashEndAddr = flashPara.flashBaseAddr +  // 符合: 加号留在行末\n                         flashPara.flashSize;       // 符合: 加法两个操作数对齐\n函数参数列表举例：\n\n// 符合：函数参数放在一行\nReturnType result = FunctionName(paramName1, paramName2);\n\nReturnType result = FunctionName(paramName1,\n                                 paramName2,\n                                 paramName3); // 符合：保持与上方参数对齐\n\nReturnType result = FunctionName(paramName1, paramName2,\n    paramName3, paramName4, paramName5);     // 符合：参数换行，4 空格缩进\n\nReturnType result = VeryVeryVeryLongFunctionName( // 行宽不满足第1个参数，直接换行\n    paramName1, paramName2, paramName3);          // 换行后，4 空格缩进\n如果函数的参数存在内在关联性，按照可理解性优先于格式排版要求，对参数进行合理分组换行。\n\n// 符合：每行的参数代表一组相关性较强的数据结构，放在一行便于理解\nint result = DealWithStructLikeParams(left.x, left.y,    // 表示一组相关参数\n                                      right.x, right.y); // 表示另外一组相关参数\n初始化语句举例：\n\n// 符合: 满足行宽要求时不换行\nint arr[4] = { 1, 2, 3, 4 };\n// 符合: 行宽较长时，换行让可读性更好\nconst int rank[] = {\n    16, 16, 16, 16, 32, 32, 32, 32,\n    64, 64, 64, 64, 32, 32, 32, 32\n};\n对于复杂结构数据的初始化，尽量清晰、紧凑。\n参考如下格式：\n\nint a[][4] = {\n    { 1, 2, 3, 4 }, { 2, 2, 3, 4 }, // 符合\n    { 3, 2, 3, 4 }, { 4, 2, 3, 4 }\n};\n\nint b[][8] = {\n    { 1, 2, 3, 4, 5, 6, 7, 8 },     // 符合\n    { 2, 2, 3, 4, 5, 6, 7, 8 }\n};\nint c[][8] = {\n    {\n        1, 2, 3, 4, 5, 6, 7, 8      // 符合\n    }, {\n        2, 2, 3, 4, 5, 6, 7, 8\n    }\n};\n对于初始化语句中的大括号，遵循：\n\n左大括号放行末时，对应的右大括号需另起一行\n左大括号被内容跟随时，对应的右大括号也应跟随内容",
					"badExample": "ReturnType result = FunctionName(paramName1,\n paramName2); // 不符合，未按要求对齐\n\n\nflashPara.flashEndAddr = flashPara.flashBaseAddr \n      +  flashPara.flashSize;       // 不符合，操作符应该在上一行末",
					"recommend": "按要求进行对齐",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.06-CPP 换行时将操作符留在行末，新行缩进一层或进行同类对齐——函数调用参数换行",
					"language": "c++",
					"id": "51cbf6e30fef11edbce484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "当语句过长，或者可读性不佳时，需要在合适的地方换行。\n换行时将操作符、连接符放在行末，表示“未结束，后续还有”。新行缩进一层，或者保持同类对齐。\n\n调用函数的参数列表换行时，左圆括号总是跟函数名，右圆括号总是跟最后一个参数，并进行合理的参数对齐。\n\n2选择在较低优先级操作符或连接符后换行，或者根据表达式层次换行。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "长表达式举例：\n\n// 假设下面第一行已经不满足行宽要求\nif (currentValue &gt; MIN &&  // 符合：换行后，布尔操作符放在行末\n    currentValue &lt; MAX) {  // 符合: 与(&&)操作符的两个操作数同类对齐\n    DoSomething();\n    ...\n}\n\nflashPara.flashEndAddr = flashPara.flashBaseAddr +  // 符合: 加号留在行末\n                         flashPara.flashSize;       // 符合: 加法两个操作数对齐\n函数参数列表举例：\n\n// 符合：函数参数放在一行\nReturnType result = FunctionName(paramName1, paramName2);\n\nReturnType result = FunctionName(paramName1,\n                                 paramName2,\n                                 paramName3); // 符合：保持与上方参数对齐\n\nReturnType result = FunctionName(paramName1, paramName2,\n    paramName3, paramName4, paramName5);     // 符合：参数换行，4 空格缩进\n\nReturnType result = VeryVeryVeryLongFunctionName( // 行宽不满足第1个参数，直接换行\n    paramName1, paramName2, paramName3);          // 换行后，4 空格缩进\n如果函数的参数存在内在关联性，按照可理解性优先于格式排版要求，对参数进行合理分组换行。\n\n// 符合：每行的参数代表一组相关性较强的数据结构，放在一行便于理解\nint result = DealWithStructLikeParams(left.x, left.y,    // 表示一组相关参数\n                                      right.x, right.y); // 表示另外一组相关参数\n初始化语句举例：\n\n// 符合: 满足行宽要求时不换行\nint arr[4] = { 1, 2, 3, 4 };\n// 符合: 行宽较长时，换行让可读性更好\nconst int rank[] = {\n    16, 16, 16, 16, 32, 32, 32, 32,\n    64, 64, 64, 64, 32, 32, 32, 32\n};\n对于复杂结构数据的初始化，尽量清晰、紧凑。\n参考如下格式：\n\nint a[][4] = {\n    { 1, 2, 3, 4 }, { 2, 2, 3, 4 }, // 符合\n    { 3, 2, 3, 4 }, { 4, 2, 3, 4 }\n};\n\nint b[][8] = {\n    { 1, 2, 3, 4, 5, 6, 7, 8 },     // 符合\n    { 2, 2, 3, 4, 5, 6, 7, 8 }\n};\nint c[][8] = {\n    {\n        1, 2, 3, 4, 5, 6, 7, 8      // 符合\n    }, {\n        2, 2, 3, 4, 5, 6, 7, 8\n    }\n};\n对于初始化语句中的大括号，遵循：\n\n左大括号放行末时，对应的右大括号需另起一行\n左大括号被内容跟随时，对应的右大括号也应跟随内容",
					"badExample": "ReturnType result = FunctionName(paramName1,\n paramName2); // 不符合，未按要求对齐\n\n\nflashPara.flashEndAddr = flashPara.flashBaseAddr \n      +  flashPara.flashSize;       // 不符合，操作符应该在上一行末",
					"recommend": "按要求进行对齐",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.06-CPP 换行时将操作符留在行末，新行缩进一层或进行同类对齐——数据初始化换行",
					"language": "c++",
					"id": "51cbf6e50fef11edafca84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "当语句过长，或者可读性不佳时，需要在合适的地方换行。\n换行时将操作符、连接符放在行末，表示“未结束，后续还有”。新行缩进一层，或者保持同类对齐。\n\n调用函数的参数列表换行时，左圆括号总是跟函数名，右圆括号总是跟最后一个参数，并进行合理的参数对齐。\n\n2选择在较低优先级操作符或连接符后换行，或者根据表达式层次换行。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "长表达式举例：\n\n// 假设下面第一行已经不满足行宽要求\nif (currentValue &gt; MIN &&  // 符合：换行后，布尔操作符放在行末\n    currentValue &lt; MAX) {  // 符合: 与(&&)操作符的两个操作数同类对齐\n    DoSomething();\n    ...\n}\n\nflashPara.flashEndAddr = flashPara.flashBaseAddr +  // 符合: 加号留在行末\n                         flashPara.flashSize;       // 符合: 加法两个操作数对齐\n函数参数列表举例：\n\n// 符合：函数参数放在一行\nReturnType result = FunctionName(paramName1, paramName2);\n\nReturnType result = FunctionName(paramName1,\n                                 paramName2,\n                                 paramName3); // 符合：保持与上方参数对齐\n\nReturnType result = FunctionName(paramName1, paramName2,\n    paramName3, paramName4, paramName5);     // 符合：参数换行，4 空格缩进\n\nReturnType result = VeryVeryVeryLongFunctionName( // 行宽不满足第1个参数，直接换行\n    paramName1, paramName2, paramName3);          // 换行后，4 空格缩进\n如果函数的参数存在内在关联性，按照可理解性优先于格式排版要求，对参数进行合理分组换行。\n\n// 符合：每行的参数代表一组相关性较强的数据结构，放在一行便于理解\nint result = DealWithStructLikeParams(left.x, left.y,    // 表示一组相关参数\n                                      right.x, right.y); // 表示另外一组相关参数\n初始化语句举例：\n\n// 符合: 满足行宽要求时不换行\nint arr[4] = { 1, 2, 3, 4 };\n// 符合: 行宽较长时，换行让可读性更好\nconst int rank[] = {\n    16, 16, 16, 16, 32, 32, 32, 32,\n    64, 64, 64, 64, 32, 32, 32, 32\n};\n对于复杂结构数据的初始化，尽量清晰、紧凑。\n参考如下格式：\n\nint a[][4] = {\n    { 1, 2, 3, 4 }, { 2, 2, 3, 4 }, // 符合\n    { 3, 2, 3, 4 }, { 4, 2, 3, 4 }\n};\n\nint b[][8] = {\n    { 1, 2, 3, 4, 5, 6, 7, 8 },     // 符合\n    { 2, 2, 3, 4, 5, 6, 7, 8 }\n};\nint c[][8] = {\n    {\n        1, 2, 3, 4, 5, 6, 7, 8      // 符合\n    }, {\n        2, 2, 3, 4, 5, 6, 7, 8\n    }\n};\n对于初始化语句中的大括号，遵循：\n\n左大括号放行末时，对应的右大括号需另起一行\n左大括号被内容跟随时，对应的右大括号也应跟随内容",
					"badExample": "ReturnType result = FunctionName(paramName1,\n paramName2); // 不符合，未按要求对齐\n\n\nflashPara.flashEndAddr = flashPara.flashBaseAddr \n      +  flashPara.flashSize;       // 不符合，操作符应该在上一行末",
					"recommend": "按要求进行对齐",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.07-CPP 预处理的\"#\"统一放在行首，嵌套预处理语句时，\"#\"可以进行缩进",
					"language": "c++",
					"id": "51cbf6e70fef11edb67384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "预处理的#统一放在行首，即使预处理的代码是嵌入在函数体中的，#也应该放在行首。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "将#放在行首或者嵌套缩进",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.08-CPP 遵循传统的类成员声明顺序",
					"language": "c++",
					"id": "51cbf6e90fef11eda0bb84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "类访问控制块的声明顺序默认依次是 public:、protected:、 private:，缩进与 class 关键字对齐。如果访问控制块的内容存在依赖关系，则可以根据需要调整顺序；如果不需要某个访问控制块，则不要声明一个空的块。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "按顺序声明",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.09-CPP 构造函数初始化列表放在同一行或按4空格缩进并排多行",
					"language": "c++",
					"id": "51cbf6eb0fef11ed93a184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "构造函数初始化列表放在同一行，如果需要换行，则将冒号放置新行，首行缩进4空格，其余多行与首行的成员变量对齐缩进。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "按要求进行缩进",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.10-CPP 函数的返回类型及修饰符与函数名同行",
					"language": "c++",
					"id": "51cbf6ed0fef11ed8e5884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "声明和定义函数时，函数的返回类型以及其他修饰符，保持与函数名同一行；如果行宽度允许，函数参数也应该放在一行；否则，函数参数应该换行，并进行合理对齐。\n参数列表的左圆括号总是和函数名在同一行，不要单独一行；右圆括号总是跟随最后一个参数。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "声明定义函数时，函数的返回值类型以及其他修饰符，保持与函数名同一行。\n\n例：\n\nstatic inline int ShortFunc(int a, int b);         // 符合",
					"badExample": "声明定义函数时，函数的返回值类型以及其他修饰符，保持与函数名同一行。\n\n例：\n\nstatic inline int\nShortFunc(int a, int b);         // 不符合",
					"recommend": "函数返回值及修饰符与函数名调整到同一行",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.12-CPP 避免将if/else/else if写在同一行",
					"language": "c++",
					"id": "51cc1de90fef11ed8f8f84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "条件语句中，若有多个分支，应该写在不同行。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "if (someConditions) {\n    DoSomething();\n    ...\n} else {                                 // 符合：else 与 if 在不同行\n    ...\n}",
					"badExample": "if (someConditions) { ... } else { ... } // 不符合：else 与 if 在同一行",
					"recommend": "将语句拆分到多行",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.13-CPP case/default语句相对switch缩进一层",
					"language": "c++",
					"id": "51cc1deb0fef11ed8c7a84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "case/default语句相对switch缩进一层，case中的语句相对case缩进一层。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "switch (var) {\n    case CASE1:         // 符合：缩进  \n        DoSomething1(); // 符合：缩进  \n        break;\n    case CASE2: {       // 符合：带大括号格式  \n        DoSomething2();\n        break;\n    }\n    ...\n    default:\n        break;\n}",
					"badExample": "switch (var) {\ncase CASE1:             // 不符合：case 未缩进  \n    DoSomething1();\n    break;\n...\ndefault:                // 不符合：default 未缩进  \n    break;\n}",
					"recommend": "按要求进行缩进",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.14-CPP 指针类型\"*\"和引用类型\"&\"只跟随类型或变量名——指针类型",
					"language": "c++",
					"id": "51cc1ded0fef11eda3df84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "指针类型的类型修饰符*可以跟随类型也可以跟随变量名或函数名，编写代码时需要选择使用其中一种风格。 按照C++代码的惯例，建议使用跟随类型的风格。\n\n当*与类型、变量、函数名之间有其他关键字而无法跟随时，可以选择向左或向右跟随关键字，或者选择与关键字之间留有1个空格，并保持风格一致。\n当*由于其他原因无法跟随类型、变量、函数名时，选择一种跟随风格并保持一致。\n\n类似地，成员指针::* 和引用类型&、&&、*&的风格也应与指针类型*的风格相同。\n\n本条款中列举了一些应该避免出现的风格以及常见的推荐风格。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "const char* const VERSION = \"V100\"; // 符合：跟随类型（可选\"*\"两边都有空格的风格）\nint i = 0;\nint* p = &i;                        // 符合：跟随类型\nFoo* CreateFoo();                   // 符合：跟随类型\n\nint& r = i;                         // 符合：跟随类型\nint&& rr = i + 10;                  // 符合：跟随类型\nint*& rp = p;                       // 符合：指针的引用，*& 一起跟随类型，中间没有空格\nFoo& GetFoo();                      // 符合：跟随类型\nconst char *const VERSION = \"V100\"; // 向右跟随关键字（可选\"*\"两边都有空格的风格）\nint i = 0;\nint *p = &i;                        // 符合：跟随变量名\nFoo *CreateFoo();                   // 符合：跟随函数名\n\nint &r = i;                         // 符合：跟随变量名\nint &&rr = i + 10;                  // 符合：跟随变量名\nint *&rp = p;                       // 符合：指针的引用，*& 一起跟随变量名，中间没有空格\nFoo &GetFoo();                      // 符合：跟随函数名\n\nconst int SomeClass::*p1;           // 符合：跟随变量名\nvoid (SomeClass::*fp1)();           // 符合：跟随变量名\nvoid (*fp2);                        // 符合：跟随变量名\n\nint array[LEN] = {0};               \nint (*pa)[LEN] = &array;            // 符合：跟随变量名\nint (&ra)[LEN] = array;             // 符合：跟随变量名\n\nsize_t size = sizeof(int *);        // 符合：留有1空格（可选\"*\"靠近类型）",
					"badExample": "int i = 0;\nint*p1 = &i;                        // 不符合：两边都没空格\nint * p2 = &i;                      // 不符合：两边都有空格\n\nint&r1 = i;                         // 不符合：两边都没空格\nint & r1 = i;                       // 不符合：两边都有空格\n\nint&&rr1 = i + 10;                  // 不符合：两边都没空格\nint && rr2 = i + 10;                // 不符合：两边都有空格\n\nint*&rp1 = p1;                      // 不符合：两边都没空格\nint *& rp2= p1;                     // 不符合：两边都有空格\nint * &rp3 = p1;                    // 不符合：中间有空格\nint* &rp4 = p1;                     // 不符合：中间有空格\nint* & rp5 = p1;                    // 不符合：中间有空格\nint * & rp6 = p1;                   // 不符合：中间有空格",
					"recommend": "\"*\"和\"&\"按要求跟随类型或者名称",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.16-CPP 用空格突出关键字和重要信息——关键信息",
					"language": "c++",
					"id": "51cc1def0fef11edb49f84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "空格应该突出关键字和重要信息。总体建议如下：\n\n行末不要加空格\nif, switch, case, do, while, for 等关键字之后加空格\n小括号内部的两侧，不加空格；外部两侧与关键字或重要信息之间加空格\n大括号内部两侧是否留有空格，左右必须保持一致；外部两侧与关键字或重要信息之间加空格\n使用大括号进行初始化时，左侧大括号跟随类型或变量名时不加空格\n一元操作符（& * + ‐ ~ !）之后不加空格\n二元操作符（= + ‐ &lt; &gt; * / % | & ^ &lt;= &gt;= == !=）左右两侧加空格\n三元操作符（? :）符号两侧均加空格\n前置和后置的自增、自减操作符（++ --）和变量之间不加空格\n尾置返回类型语法中的-&gt;前后加空格\n结构体成员操作符（. -&gt;）前后不加空格\n结构体中表示位域的冒号，两侧均加空格\n函数参数列表的小括号与函数名之间不加空格\n类型强制转换的小括号与被转换对象之间不加空格\n数组的中括号与数组名之间不加空格\n对于模板和类型转换(&lt;&gt;)和类型之间不加空格\n域操作符(::)前后不加空格\n类成员指针（::* .* -&gt;*）前后或中间不加空格\n类继承、构造函数初始化、范围for语句中的冒号(:)前后加空格\n逗号、分号、冒号（上述规则场景除外）前面不加空格，后面加空格",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "变量定义\nint i = 0;               // 符合：变量初始化时，= 前后应该有空格，分号前面不要留空格\nint buf[BUF_SIZE] = {0}; // 符合：数组初始化时，大括号内空格可选\nint arr[] = { 10, 20 };  // 符合: 正常大括号内部两侧建议加空格\n指针和取地址\nx = *p;   // 符合：*操作符和指针p之间不加空格\np = &x;   // 符合：&操作符和变量x之间不加空格\nx = r.y;  // 符合：通过.访问成员变量时不加空格\nx = r-&gt;y; // 符合：通过-&gt;访问成员变量时不加空格\n操作符\nx = 0;    // 符合：赋值操作的=前后都要加空格\nx = -5;   // 符合：负数的符号之前要加空格\n++x;      // 符合：前置和后置的++/--和变量之间不要加空格\nx--;\n\nif (x && !y)       // 符合：布尔操作符前后要加上空格，！操作和变量之间不要空格\nv = w * x + y / z; // 符合：二元操作符前后要加空格\nv = w * (x + z);   // 符合：括号内的表达式前后不需要加空格\n循环和条件语句\nif (condition) { // 符合：if关键字和括号之间加空格，括号内条件语句前后不加空格\n    ...\n} else {         // 符合：else关键字和大括号之间加空格\n    ...\n}\n\n// 符合：while关键字和括号之间加空格，括号内条件语句前后不加空格\nwhile (condition) {}\n\n// 符合：for关键字和括号之间加空格，分号之后加空格\nfor (int i = 0; i &lt; someRange; i++) {\n    ...\n}\n\nswitch (var) { // 符合: switch 关键字后面有1空格\n    case 0:    // 符合：case语句条件和冒号之间不加空格\n        ...\n        break;\n    ...\n    default:\n        ...\n        break;\n}",
					"badExample": "函数定义和函数调用的情况\n\nint result = Foo(arg1,arg2);\n                      ^         // 不符合： 逗号后面应该有空格\n\nint result = Foo( arg1, arg2 );\n                 ^          ^   // 不符合： 小括号内部两侧不应有空格",
					"recommend": "按要求增加/减少空格",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.17-CPP 合理安排空行",
					"language": "c++",
					"id": "51cc1df10fef11ed885584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "使用空行可以凸显出代码块的相关程度，能提升代码的可读性。但是过多的空行并不能带来更多的好处，反而可能降低代码的可读性。可参考如下建议：\n\n函数内部、类型定义内部、宏内部、初始化表达式内部，不使用连续空行\n仅在需要特别凸显代码块逻辑分组时使用连续空行，并且最多连续2个空行\n大括号内的代码块行首之前和行尾之后不要加空行，但namespace的大括号内不作要求",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "删除多余空行",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.INC.02-CPP 禁止包含用不到的头文件",
					"language": "c++",
					"id": "51cc1df30fef11edaf9184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "用不到的头文件被包含的同时引入了不必要的依赖，增加了模块或单元之间的耦合度，只要该头文件被修改，代码就要重新编译。\n\n有些库会提供统一的API入口头文件，如一个名为X的库提供libX.h供外部使用，该头文件中又进一步包含多个子模块的头文件，这种情况下允许直接引用libX.h，即便其中某些子模块的API是使用不到的。此种情况不认为是包含了用不到的头文件，除非libX.h中的功能完全没有用到。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "",
					"recommend": "（1）删除头文件，或者（2）按需包含头文件",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.INC.05-CPP 禁止在extern \"C\"中包含头文件",
					"language": "c++",
					"id": "51cc1df50fef11ed854484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "在 extern “C” 中包含头文件，有可能会导致 extern “C” 嵌套，部分编译器对 extern “C” 嵌套层次有限制，嵌套层次太多会编译错误。\n\n在C，C++混合编程的情况下，在extern “C”中包含头文件，可能会导致被包含头文件的原有意图遭到破坏，例如链接规范被不正确地更改。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "#ifdef __cplusplus\n#include \"a.h\" // 符合，不会有extern c嵌套\nextern \"C\" {\n#endif\n\nvoid B(void);\n\n#ifdef __cplusplus\n}\n#endif",
					"badExample": "#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"a.h\" // 不符合，可能会出现嵌套\nvoid B(void);\n\n#ifdef __cplusplus\n}\n#endif",
					"recommend": "修改include位置，避免出现extern \"C\"嵌套",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.INC.06-CPP 尽量避免使用类的前置声明，而是通过#include来包含头文件",
					"language": "c++",
					"id": "51cc1df70fef11eda11a84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "前置声明（forward declaration）通常指类、模板、函数的纯粹声明，没有伴随着其定义。\n\nclass A; // 对A的前置声明，其定义出现在后面或另外的文件中\n应尽量避免使用前置声明，而是使用#include头文件来保证依赖关系。\n\n对于当前的编译单元，如果只有类的前置声明而没有完整定义，该类属于“不完整类型（incomplete type)”状态。不完整类型的使用场景受限，编译器不能确定其类型大小、不知道其成员变量或者成员方法。通常来说，可以通过include定义类的头文件来获得类的声明以及完整定义，从而避免不完整类型。这样能使类的声明和定义聚集在一处，体现一种内聚原则。当类或函数的声明（诸如名称、specifier、attributes、增加默认参数等）发生变化时，只需修改一处。使用include头文件还可以方便地使用类型的完整信息，比如调用类的成员函数，相比仅使用前置声明，不必处理晦涩的’incomplete type’编译错误。\n\n不完整类型可用于下面几种情况：\n\n仅需要使用该类型的指针或者引用，不需使用类的成员变量或成员函数\n类型作为参数或者返回值，出现在函数的声明中（注意不是定义）\n有一种情况必须使用前置声明，即循环引用，如下用例：\n\n// Foo.h\nclass Container;                     // 前置声明\n\nclass Foo {\n    ...\n    Container* container;\n};\n// Container.h\n#include \"Foo.h\"\n\nclass Container {\n    ...\n    std::map&lt;std::string, Foo&gt; table;\n};\n在上述用例中，Foo的定义需要引用B的类型，Container的定义也需要引用Foo的类型，此时必须引入前置声明class Container来打破循环。\n\n前置声明另一个用途是减少include文件数量从而减少编译时间。项目可以依据实际情况来决定是否使用该项技术来优化编译时间，通常来讲，可以通过并行编译或者预编译头文件（precompiled header）技术来减少编译时间。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "修改为头文件包含",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.INC.08-CPP 不要在#include之前使用using导入namespace",
					"language": "c++",
					"id": "51cc1df90fef11eda51a84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "使用using导入命名空间会影响后续代码，易造成符号冲突，所以不要在头文件以及源文件中的#include之前使用using导入命名空间。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "// test.cpp\n#include \"A.h\"\nusing namespace A;           // 在C.h中的#include \"B.h\"之前导入了A\n#include \"C.h\"\n\nint main()\n{\n    C::Foo();                // 引发歧义：C.h中的Foo函数调用的是A::Fun还是B::Fun\n    return 0；\n}",
					"recommend": "将对头文件的包含放到前面",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.INC.11-CPP 优先使用命名空间来管理全局函数和全局常量，如果和某个class有直接关系的，可以使用静态成员函数或静态成员常量",
					"language": "c++",
					"id": "51cc1dfb0fef11ed9af484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "将全局函数、全局常量、全局类型以及类型别名放在命名空间内可避免污染全局作用域。如果它们和某个类有紧密联系，那么可以作为类的静态成员函数、静态成员常量等；如果它们被用于C语言接口，那么可以放在全局作用域。",
					"systemTag": "clangtidy",
					"goodExample": "namespace Utils {\nconst int MAX_SIZE = 100;\n\nint Add(int a, int b);\n\nclass File {\npublic:\n    static const std::string SEPARATOR;\n    static File CreateTempFile(const std::string& fileName);\n};\n}",
					"badExample": "",
					"recommend": "使用命名空间来管理全局函数、常量等",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.STD.02-CPP 使用std::string表示字符串",
					"language": "c++",
					"id": "51cc44fd0fef11ed92b084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "使用std::string代替char*表示字符串有很多优势，例如：\n\n不用考虑结尾的'\\0'\nstd::string 能够复制，渐进扩容，可以直接使用+、=、==等操作符，并提供许多有用的字符串操作函数\n不需要考虑内存分配操作，避免了显式的new/delete，以及由此导致的错误\n需要注意的是某些STL实现中std::string是基于写时复制策略的，这会带来两个问题，一是某些版本的写时复制策略没有实现线程安全，在多线程环境下会引起程序错误；二是当与动态链接库互相传递基于写时复制策略的std::string时，由于引用计数在动态链接库被卸载时无法减少可能导致悬挂指针。因此，慎重选择一个可靠的STL实现对于保证程序稳定是很重要的。\n\nC++17开始增加了std::string_view类型，该类型可以减少字符串复制操作，提升程序性能。在C++17及之后的版本中，建议使用std::string_view表示字符串常量，在C++17之前可以使用C风格的字符串常量。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "std::string defaultMsg{\"hello\"};\nstd::string msg = defaultMsg + \" world\";\n…",
					"badExample": "char defaultMsg[] = \"hello\";\nchar msg[MSG_SIZE];\nint ret = sprintf_s(msg, sizeof(msg), \"%s world\", defaultMsg); // 使用C字符处理函数\n…",
					"recommend": "使用std::string来表示字符串",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.01-CPP 不要声明或定义保留标识符",
					"language": "c++",
					"id": "51cc44ff0fef11ed867284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "如果声明或者定义了一个保留的标识符，那么程序会产生未定义行为。\n\n如下是C++中的一些保留标识符说明：\n\n包含双下划线的，或者以单下划线加一个大写字母开头的标识符，为实现保留\n在全局命名空间中以下划线开头的标识符为实现保留\n不以下划线开头的literal后缀为将来标准保留，用户自定义的literal后缀名应以单下划线开头\nposix命名空间名以及std加一或多个数字的命名空间名（如std2）为将来标准保留\n任何包含标准库头文件的编译单元不能#define或#undef任何在标准库头文件中声明的标识符\n标准库头文件在全局命名空间和std命名空间中声明为外部链接的对象名为实现保留\n标准库头文件中声明为外部链接的全局函数名为实现保留\n标准C库中具有外部链接的对象名或函数名为实现保留",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "#undef __LINE__               // 不符合：__LINE__为保留宏，不允许#undef保留宏\n#define _MODULE_INCLUDE_      // 不符合：下划线开头  \nenum { MAX_SIZE = 80 };       // 不符合：MAX_SIZE是&lt;cstdint&gt;中保留宏\nint errno;                    // 不符合：errno是标准库中的保留标识符  \nvoid* malloc(size_t nbytes);  // 不符合：malloc是标准库中的保留标识符",
					"recommend": "修改标识符名称",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.02-CPP 不要重复定义基本类型",
					"language": "c++",
					"id": "51cc45010fef11edb8a984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "项目组应规划使用相同版本的类型定义，建议优先使用标准中定义的类型（如：统一使用&lt;cstdint&gt;中定义的整数类型），不要重复定义基本类型。\n\n一个项目中如果存在多种类型定义（如同时使用u32，v32，uint32，uint表示unsigned int类型），会使代码变得更加混乱，难以维护和难以编译，也违反了风格一致原则。\n除非有明确的必要性，否则不要用 typedef/#define/using 对基本类型进行重定义。\n\n下面的场景中重新定义了基本类型为Uintptr，其屏蔽了不同平台（CPU/OS）下基本数值类型的位宽差异，是具有必要性的。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "// 模块 A\n...\nusing ULONG = unsigned long;\n…\n// 模块 B\n...\n#define ULONG UINT32\n...",
					"recommend": "如无必要，不要重新定义基础类型",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.05-CPP 禁止通过声明的方式引用外部函数接口和变量",
					"language": "c++",
					"id": "51cc45030fef11edb22284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "只能通过包含头文件的方式使用其他模块或文件提供的接口。\n\n通过声明的方式使用外部函数接口和变量，容易在外部接口改变时可能导致声明和定义不一致。同时，这种隐式依赖容易导致架构腐化。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "// Foo.cpp\n#include \"Bar.h\"   // 符合： 通过包含头文件的方式使用其他.cpp提供的接口\n\nvoid Foo() \n{\n    int i = Bar();\n    ...\n}",
					"badExample": "// Foo.cpp\nextern int Bar();  // 不符合：通过extern的方式使用外部函数\n\nvoid Foo() \n{\n    int i = Bar();\n    ...\n}\n// Bar.cpp\nint Bar()\n{\n    ...\n    return 0;\n}\n…",
					"recommend": "通过头文件包含来使用接口",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.09-CPP 尽量推迟变量定义",
					"language": "c++",
					"id": "51cc45050fef11edb6bb84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "遵循变量作用域最小化原则与就近声明原则，在变量被使用时才声明并初始化，使得代码更容易阅读，方便了解变量的类型和初始值。特别地，尽量使用初始化的方式对变量赋初值。\n\n在函数开始位置声明所有变量，后面才使用变量，作用域覆盖整个函数实现，容易导致如下问题：\n\n（1）程序难以理解和维护：变量的定义与使用分离。\n（2）变量难以合理初始化：在函数开始时，经常没有足够的信息进行变量初始化，往往用某个默认的空值(比如零)来初始化，使程序低效，如果变量在被赋于有效值以前被使用，还会导致错误。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "std::string name{\"nobody\"}; // 调用构造函数初始化\n…",
					"badExample": "std::string name;           // 声明时未初始化：调用默认构造函数\n...                         // 在此期间未使用name变量\nname = \"nobody\";            // 再次调用赋值操作符函数\n…",
					"recommend": "合并变量的声明和初始化",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.10-CPP 不要在嵌套作用域中重用名称",
					"language": "c++",
					"id": "51cc45070fef11ed920a84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "在嵌套的作用域中重用名称，容易给阅读者带来困扰，分不清楚实际在用哪个变量。类似地，在同一个命名空间内使用using声明的类型别名也应该唯一。",
					"systemTag": "clangtidy",
					"goodExample": "如下代码示例中，使用了不同的变量名：\n\n#define MAX_MESSAGE_LEN 100\n#define CUSTOMIZED_SIZE 80\n\nvoid Func(const char *str)\n{\n    char message[MAX_MESSAGE_LEN];\n    ...\n    if (str != NULL) {\n        char msg[CUSTOMIZED_SIZE];\n        ...\n        int ret = sprintf_s(msg, sizeof(msg), \"Error: %s\\n\", str);\n        ...\n    }\n    ...\n}\n\nint main(void)\n{\n    ...\n    Fun(\"some error\");\n\n    return 0;\n}",
					"badExample": "void Fun()\n{\n    std::string msg;\n    ...\n    if (condition) {\n         std::string msg;        // 不符合：外层局部变量被遮盖\n         ...\n    }\n    ...\n}\nvoid Fun(const std::string& msg)\n{\n    ...\n    if (condition) {\n        std::string msg;         // 不符合：函数入参被遮盖\n        ...\n    }\n}\nclass SomeClass {\npublic:\n    void Fun()\n    {\n        std::string msg;         // 不符合：类成员变量被遮盖\n        ...\n    }\n\nprivate:\n   std::string msg;\n};",
					"recommend": "重命名变量",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.29-CPP 比较两个表达式时，左侧倾向于变化，右侧倾向于不变",
					"language": "c++",
					"id": "51cc45090fef11edb34584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "当变量与常量比较时，如果常量放左边，如 if (MAX == v) 不符合阅读习惯，而 if (MAX &gt; v) 更是难于理解。应当按人的正常阅读、表达习惯，将常量放右边。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "if (value == MAX) {\n    ...\n}\n\nif (value &lt; MAX) {\n    ...\n}",
					"badExample": "if (NULL == ptr) { // 不符合\n}",
					"recommend": "将变量放在比较表达式左侧",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.30-CPP 用括号明确表达式的操作顺序，避免过分依赖默认优先级",
					"language": "c++",
					"id": "51cc450b0fef11ed9ebc84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "当表达式包含不常用、优先级易混淆的操作符时，建议使用括号明确表达式的操作顺序，防止因默认的优先级与实现意图不符而导致程序出错，提升代码的可读性。然而过多的括号也会分散代码，使其可读性降低，应适度使用。\n\n二元及以上操作符，如果涉及多种操作符混合使用并且优先级容易混淆的场景，特别是位操作符与其他操作符混合使用时，建议使用括号明确表达式操作顺序。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "if ((a & b) == 0) ...       // 符合：明确先进行逻辑位运算\nx = (a & 0xFF) + b;         // 符合：明确先进行逻辑位运算\nx = 1 &lt;&lt; (2 + 3);           // 符合：明确先进行加法运算\nx = (1 &lt;&lt; 2) + 3;           // 符合：明确先进行移位运算\nx = (a == b) ? a : (a – b); // 符合：使用括号提升可读性\nx = a + b + c;              // 符合：操作符相同，可以不加括号\nx = Foo(a + b, c);          // 符合：逗号两边的表达式，不需要括号\nif (a &gt; b && c &gt; d) ...     // 符合：逻辑表达式，根据子表达式的复杂情况选择是否加括号",
					"badExample": "if (a & b == 0) ...         // 不符合：涉及逻辑位运算，需要括号\nx = a & 0xFF + b;           // 不符合：涉及逻辑位运算，需要括号\nx = 1 &lt;&lt; 2 + 3;             // 不符合：涉及移位运算，需要括号\nx = a == b ? a : a – b;     // 不符合：操作符不同，建议括号",
					"recommend": "添加括号明确表达式顺序",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.33-CPP 含有变量自增或自减运算的表达式中禁止再次引用该变量",
					"language": "c++",
					"id": "51cc450d0fef11eda49d84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "含有变量自增或自减运算的表达式中，如果再引用该变量，其结果在C++标准中可能未明确定义。\n\n各个编译器或者同一个编译器不同版本实现可能会不一致。为了更好的可移植性，不应该对标准未定义的运算次序做任何假设。\n\n注意：运算次序的问题不能使用括号来解决，因为这不是优先级的问题。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "x = b[i] + i;\ni++;            // 符合： 单独一行\ni++;            // 符合： 单独一行\nx = Fun(i, i);",
					"badExample": "x = b[i] + i++; // 不符合： b[i]运算跟 i++，先后顺序并不明确\nFun(i++, i);    // 不符合： 传递第2个参数时，不确定自增运算有没有发生",
					"recommend": "自增或自减运算提到表达式之外",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.38-CPP switch语句中至少有两个条件分支",
					"language": "c++",
					"id": "51cc450f0fef11ed9ec584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "单个路径的选择语句更适合用if语句进行判断；且如果条件分支是布尔值，那么也不合适使用switch语句，使用if语句更合适。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "switch (color) {\n    case Color::RED:\n        DoRedThing();\n        break;\n    case Color::GREEN:\n        DoGreenThing();\n        break;\n    case Color::BLUE:\n        DoBlueThing();\n        break;\n    default:                \n        DoDefault();\n        break;\n}",
					"badExample": "switch (color) {\n    default:         // 不符合：switch是多余的  \n        DoDefault();\n        break;\n}\nswitch (color) {\n    case Color::RED:\n    default:         // 不符合：switch是多余的  \n        DoDefault();\n        break;\n}",
					"recommend": "switch至少要有两个分支，单分支的情况可以改为if语句",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.RES.09-CPP 使用`std::make_unique`而不是`new`创建`std::unique_ptr`",
					"language": "c++",
					"id": "51cc45110fef11edbc6184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "本条款适用于C++14及之后的版本。C++14开始增加了std::make_unique，提供与std::make_shared类似的方式构造unique_ptr。\n\n相对于先 new 出裸指针再构造 unique_ptr ，直接使用 make_unique 的优点有：\n\nmake_unique 可以更明确的避免裸指针和智能指针混用。\n使用 make_unique 更简洁。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "void Foo()\n{\n    std::unique_ptr&lt;C&gt; sp = std::make_unique&lt;C&gt;(); // 符合\n    ...                                            // 代码中只能使用 sp\n}",
					"badExample": "void Foo()\n{\n    C* p = new C();\n    std::unique_ptr&lt;C&gt; sp = std::unique_ptr&lt;C&gt;(p); // 不符合\n    ...                                            // 代码中既可以使用 p 也可以使用 sp\n}",
					"recommend": "使用std::make_unique来构造unique_ptr",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.RES.10-CPP 使用`std::make_shared`而不是`new`创建`std::shared_ptr`",
					"language": "c++",
					"id": "51cc6c0c0fef11ed9c9584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "使用std::make_shared除了类似std::make_unique一致性等原因外，还有性能的因素。\n\nstd::shared_ptr管理两个实体：\n\n控制块(存储引用计数，deleter等)\n管理对象\nstd::make_shared创建std::shared_ptr，会一次性在堆上分配足够容纳控制块和管理对象的内存。 而使用std::shared_ptr&lt;SomeClass&gt;(new SomeClass)创建std::shared_ptr，除了new SomeClass会触发一次堆分配外，std::shard_ptr的构造函数还会触发第二次堆分配，产生额外的开销。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "使用std::make_shared来创建shared_ptr",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.04 禁止把带副作用的表达式作为参数传递给函数式宏",
					"language": "c++",
					"id": "51cc6c0e0fef11ed92e684a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "由于宏只是文本替换，对于内部多次使用同一个宏参数的函数式宏，将带副作用的表达式作为宏参数传入会导致非预期的结果。",
					"systemTag": "clangtidy",
					"goodExample": "代码做如下修改：\n\na++; // 结果：a = 6，只自增了一次\nb = SQUARE(a);",
					"badExample": "如下所示，宏SQUARE本身没有问题，但是使用时将带副作用的表达式a++传入导致a的值在SQUARE执行后的结果跟预期不符：\n\n#define SQUARE(a) ((a) * (a))\n\nint a = 5;\nint b = SQUARE(a++); // 不符合： 展开后表达式中有2个 \"a++\"，其结果可能是非预期的。\nSQUARE(a++)展开后为((a++) * (a++))，变量a自增了两次，其值为7，而不是预期的6。",
					"recommend": "不要将副作用表达式作为宏的参数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.ERR.10-CPP 尽可能使用noexcept声明的构造函数初始化全局和线程局部变量",
					"language": "c++",
					"id": "51cc6c100fef11edafac84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "全局和线程局部（thread_local）变量的构造函数抛出异常时会导致std::terminate，而且不能被try-catch捕获。因此，初始化这些变量时，建议使用有noexcept声明的构造函数，这样的构造函数可以保证不抛出异常。\n\n一些标准库中的容器的默认构造函数不能保证不抛异常。如std::vector()默认构造函数在C++17之前没有noexcept声明，从C++17开始才有noexcept声明。而带初始大小的构造函数std::vector(size_type count)由于有内存耗尽的风险，不能保证noexcept。取决于具体工程对可靠性的要求，请酌情选择语言的版本、数据类型和构造函数。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "",
					"recommend": "重构代码逻辑，避免安全隐患",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.OTH.01 删除无效或永不执行的代码",
					"language": "c++",
					"id": "51cc6c120fef11eda49b84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "无效或永不执行的代码（即无效代码或无法访问的代码）通常是编程错误的结果，并且可能导致意外行为。通常在编译时，编译器会对此类代码进行优化。但是，为了提高可读性并确保解决逻辑错误，应该主动对其进行识别，理解和消除。\n\n虽然大多数现代编译器在许多情况下可以对无效或从不执行的代码告警，但程序员还是应该主动识别无效的语句或表达式，并将其从代码中删除。",
					"systemTag": "clangtidy",
					"goodExample": "删除无效代码取决于程序员的意图，下面代码是一种改进方案。\nint Func(int condVal)\n{\n    if (condVal == 1) {\n        char *s = (char *)malloc(ALLOC_SIZE);\n        if (s == NULL) {\n           ... // 错误处理\n        }\n        ... // 处理 s\n        free(s);\n        return 0;\n    }\n    ...\n    return 0;\n}\n\n该代码可能是程序员错误的使用相等操作符(==)而不是赋值操作符(=)的情况。\nint a = ...;\nint b = ...;\n...\na = b;\n\n更正此示例取决于程序员的意图。例如，如果解引用p是错误的，则p不应解引用。\nint *p = NULL;\n...\np++;\n\nif (param == 1) {\n    DoSomething1();\n} else if (param == 2) {\n    DoSomething2();\n} else if (param == 3) {\n    DoSomething3();\n} else {\n    ...\n}",
					"badExample": "下面代码中，最后的 if 条件语句永远无法成立，应该删除或重新优化代码。\nint Func(int condVal)\n{\n    char *s = NULL;\n    if (condVal == 1) {\n        s = (char *)malloc(ALLOC_SIZE);\n        if (s == NULL) {\n           ... // 错误处理\n        }\n        ... // 处理 s\n        return 0;\n    }\n    ...\n    if (s != NULL) {\n        ... // 此处代码不可达\n    }\n    return 0;\n}\n\n下面代码进行了a与b的比较，没有任何效果。\nint a = ...;\nint b = ...;\n...\na == b; // 不符合： 这一行代码没有任何作用\n\n如下代码示例中，对指针进行解引用后，指针值增加了，但解引用没有任何作用。\nint *p = NULL;\n...\n*p++;\n\n从上到下评估一串if/else if语句。最多只执行该链的一个分支：第一个分支的条件求值为true。因此，在if/else if语句序列中复制条件会自动导致无效代码。\nif (param == 1) {\n    DoSomething1();\n} else if (param == 2) {\n    DoSomething2();\n} else if (param == 1) {  // 条件重复，永远不成立，预期是3？\n    DoSomething3();\n} else {\n    ...\n}",
					"recommend": "删除不可执行代码",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CLS.06-CPP 禁止在构造函数和析构函数中调用虚函数",
					"language": "c++",
					"id": "51cc6c140fef11edbc1c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "在构造函数和析构函数中调用当前对象的虚函数，会导致未实现多态的行为。\n\n在C++中，一个基类一次只构造一个完整的对象。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "",
					"recommend": "重构代码逻辑，避免安全隐患",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.16-CPP 避免使用const_cast",
					"language": "c++",
					"id": "51cc6c160fef11ed89ca84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "const_cast用于移除对象的const和volatile性质。使用const_cast转换后的指针或者引用来修改const对象或volatile对象，程序可能会产生未定义行为。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "const int i = 1024; \nint* p = const_cast&lt;int*&gt;(&i);\n*p = 2048;                              // 未定义行为\nclass Foo {\npublic:\n    void SetValue(int v) { value = v; }\n\nprivate:\n    int value{0};\n};\n\nint main()\n{\n    const Foo foo;\n    Foo* p = const_cast&lt;Foo*&gt;(&foo);\n    p-&gt;SetValue(2);                     // 未定义行为\n    return 0;\n}",
					"recommend": "避免使用const_cast",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.14-CPP 使用由C++提供的类型转换操作",
					"language": "c++",
					"id": "51cc6c180fef11edb8eb84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "C++提供的类型转换操作比C风格更有针对性，更易读，也更加安全，C++提供的转换有：\n\ndynamic_cast：主要用于继承体系下行转换，该转换具有类型检查的功能。应做好基类和派生类的设计，合理使用dynamic_cast:\ndynamic_cast的出现2说明基类和派生类设计出现了问题，派生类破坏了基类的契约，不得不通过dynamic_cast转换到派生类进行特殊处理，这个时候更希望来改善类的设计，而不是通过dynamic_cast来解决问题。\n如果强制转换不可避免，则应优先使用dynamic_cast，而不是使用static_cast，因为编译器将在运行时检查强制转换的有效性。\nstatic_cast：和C风格转换相似可做值的强制转换，或上行转换(把派生类的指针或引用转换成基类的指针或引用)。如果是纯粹的算数转换，那么可以使用大括号初始化方式转换。\nreinterpret_cast：用于转换不相关的类型，是一种不安全的转换，应尽量少用reinterpret_cast。\nconst_cast：用于移除对象的const属性，使对象变得可修改，这样会破坏数据的不变性，应尽量少用const_cast。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "",
					"recommend": "将C类型转换替换为C++类型转换",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CLS.02-CPP 成员变量优先使用声明时初始化或者构造函数初始化列表初始化",
					"language": "c++",
					"id": "51cc6c1a0fef11edbaec84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "C++11的声明时初始化可以一目了然的看出成员初始值，应当优先使用。如果成员初始化值和构造函数相关，或者不支持C++11，则应当优先使用构造函数初始化列表来初始化成员。相比起在构造函数体中对成员赋值，初始化列表的代码更简洁，执行性能更好，而且可以对const成员和引用成员初始化。\n\n注意：构造函数初始化列表中的变量初始化顺序应该与成员变量的声明顺序一致。",
					"systemTag": "clangtidy",
					"goodExample": "class Message {\npublic:\n    ...\n\nprivate:\n    uint32_t msgId{0};\n    size_t msgLength{0};\n    unsigned char* msgBuffer{nullptr};\n};\nclass Message {\npublic:\n    Message() : msgId(0), msgLength(0), msgBuffer(nullptr) {}\n\nprivate:\n    uint32_t msgId;\n    size_t msgLength;\n    unsigned char* msgBuffer;\n};",
					"badExample": "",
					"recommend": "使用构造函数初始化列表进行初始化",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.15-CPP 避免使用reinterpret_cast",
					"language": "c++",
					"id": "51cc6c1c0fef11ed90c884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "reinterpret_cast用于转换不相关类型。尝试用reinterpret_cast将一种类型强制转换另一种类型，这破坏了类型的安全性与可靠性，是一种不安全的转换。不同类型之间尽量避免转换。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "",
					"recommend": "避免使用reinterpret_cast",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.ERR.01-CPP 只使用std::exception的派生类作为异常对象",
					"language": "c++",
					"id": "51cc6c1e0fef11edba2484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "std::exception是C++标准库中的异常基类。程序中抛的异常应当是继承自这个类的派生类的实例。\n\n特别地，不应该抛出或捕获基本类型（如int、char*等）的值，因为如果不同的组件都使用基本类型做为异常，那么同一个类型就会被用来表示不同的异常，导致无意中捕获到其他组件抛出的、不希望在本组件中捕获到的异常。",
					"systemTag": "clangtidy",
					"goodExample": "class ResourceExhaustedException : public std::exception {\n    ...\n};\n\nResource* res = GetResource();\nif (res == nullptr) {\n    throw ResourceExhaustedException();\n}",
					"badExample": "Resource* res = GetResource();\nif (res == nullptr) {\n    throw \"Resource exhausted\";\n}",
					"recommend": "使用std::exception的派生类作为异常对象",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.11-CPP 选择、循环语句使用大括号",
					"language": "c++",
					"id": "51cc6c200fef11ed893684a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "包括 if/for/while/do-while 语句应使用大括号，即复合语句。\n\n理由：\n\n代码逻辑直观，易读\n在已有代码上增加新代码时不容易出错\n对于语句中使用函数式宏时，没有大括号保护容易出错（如：宏定义时遗漏了大括号）",
					"systemTag": "clangtidy",
					"goodExample": "if (objectIsNotExist) {               // 单行选择语句需要加大括号\n    return CreateNewObject();\n}\nfor (int i = 0; i &lt; someRange; i++) { // 单行循环语句需要加大括号\n    DoSomething();\n}\nwhile (condition) {}                  // 空循环体需要加大括号",
					"badExample": "for (int i = 0; i &lt; someRange; i++)   // 不符合： 应该加上括号\n    DoSomething();\nwhile (condition); // 不符合：很容易让人误解循环体是 DoSomething() 调用  \nDoSomething();\n\nwhile (condition); // 不符合：使用分号容易让人误解是while语句中的一部分",
					"recommend": "对条件或循环语句没有加大括号",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.RES.05-CPP 当lambda会逃逸出函数外面时，禁止按引用捕获局部变量",
					"language": "c++",
					"id": "51cc93210fef11ed887484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "如果一个 lambda 不止在局部范围内使用，禁止按引用捕获局部变量，比如它被传递到了函数的外部，或者被传递给了其他线程的时候。lambda按引用捕获就是把局部对象的引用存储起来。如果 lambda 的生命周期会超过局部变量生命周期，则可能导致内存不安全。",
					"systemTag": "clangtidy",
					"goodExample": "void Foo()\n{\n    int local = 0;\n    // 按值捕获 local, 在Process() 调用过程中，local 总是有效的\n    threadPool.QueueWork([local] { Process(local); });\n}",
					"badExample": "void Foo()\n{\n    int local = 0;\n    // 按引用捕获 local，当函数返回后，local 不再存在，因此 Process() 的行为未定义\n    threadPool.QueueWork([&] { Process(local); });\n}",
					"recommend": "禁止按引用捕获局部变量",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.ERR.03-CPP 以左值引用的形式捕获异常",
					"language": "c++",
					"id": "51cc93230fef11edb8de84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "异常可以用类的继承关系来组成层次结构。如果按值捕获异常的基类，而实际抛出的对象是派生类的实例，就会导致对象被切片。按引用捕获则不会有切片的问题。",
					"systemTag": "clangtidy",
					"goodExample": "try {\n    throw BarException();\n} catch (const FooException& e) {            // 符合：按引用捕获，此时不会切片\n    ...\n}\ntry {\n    throw BarException();\n} catch (FooException& e) {                  // 符合：按非const引用捕获\n    e.AddMoreInformation(\"some info\");\n    throw;\n}",
					"badExample": "class FooException : public std::exception {\n    ...\n};\nclass BarException : public FooException {\n    ...\n};\n\ntry {\n    throw BarException();\n} catch (FooException e) {                   // 不符合：被切片\n    ...\n}",
					"recommend": "改成以左值引用形式捕获异常",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.28-CPP bool类型比较应避免多余的==或!=",
					"language": "c++",
					"id": "51cc93250fef11ed8fbf84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "在if、while以及for等语句中，对于bool类型参数的判断，应该避免多余的==或!=。",
					"systemTag": "clangtidy",
					"goodExample": "bool isNegative = ...\nif (isNegative) {          // 符合\n    ...\n}          \nif (!isNegative) {         // 符合\n    ...\n}",
					"badExample": "bool isNegative = ...\nif (isNegative == true) {  // 不符合\n    ...\n} \nif (isNegative != false) { // 不符合\n    ...\n}",
					"recommend": "修改表达式，去除多余的比较",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CLS.04-CPP 拷贝构造函数和拷贝赋值操作符应该是成对出现或禁止",
					"language": "c++",
					"id": "51cc93270fef11ed836984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "拷贝构造函数和拷贝赋值操作符都是具有拷贝语义的，应该同时声明，包括自定义实现、=default和=delete。",
					"systemTag": "clangtidy",
					"goodExample": "// 同时出现\nclass Foo {\npublic:\n    ...\n    Foo(const Foo& other);\n    Foo& operator=(const Foo& other);\n    ...\n};\n// 同时=default\nclass Foo {\npublic:\n    ...\n    Foo(const Foo&) = default;\n    Foo& operator=(const Foo&) = default;\n    ...\n};\n// 同时=delete\nclass Foo {\npublic:\n    ...\n    Foo(const Foo&) = delete;\n    Foo& operator=(const Foo&) = delete;\n    ...\n};",
					"badExample": "",
					"recommend": "同时定义或者同时禁止拷贝构造函数和拷贝赋值操作符",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CLS.11-CPP 在派生类中重写虚函数时禁止重新定义缺省参数值",
					"language": "c++",
					"id": "51cc93290fef11edb07284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "在C++中，虚函数是动态绑定的，但函数的缺省参数却是在编译时就静态绑定的。这意味着最终执行的函数是一个定义在派生类，但使用了基类中的缺省参数值的虚函数。为了避免虚函数重载时，因参数声明不一致给使用者带来的困惑和由此导致的问题，虚函数重写时不要重新定义缺省参数值。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "class Base {\npublic:\n    virtual ~Base() = default;\n    virtual void Display(const std::string& text = \"Base!\") const\n    {\n        std::cout &lt;&lt; text &lt;&lt; std::endl;\n    }\n};\n\nclass Derived : public Base {\npublic:\n    void Display(const std::string& text = \"Derived!\") const override\n    {\n        std::cout &lt;&lt; text &lt;&lt; std::endl; \n    }\n};\n\nint main()\n{\n    std::unique_ptr&lt;Base&gt; b = std::make_unique&lt;Derived&gt;();\n    std::unique_ptr&lt;Derived&gt; d = std::make_unique&lt;Derived&gt;();\n\n    b-&gt;Display();  // 程序输出结果: Base! 而期望输出：Derived!\n    d-&gt;Display();  // 程序输出结果: Derived!\n    return 0;\n}",
					"recommend": "派生类中的缺省参数值要与基类中的保持一致",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.37-CPP switch语句要有default分支——default不是最后一个分支",
					"language": "c++",
					"id": "51cc932b0fef11eda97684a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "大部分情况下，switch语句中要有default分支，保证在遗漏case标签处理时能够有一个缺省的处理行为。本条款要求统一将default分支放到语句块的最后位置。",
					"systemTag": "clangtidy",
					"goodExample": "【例外】\n\n如果switch条件变量是枚举类型，并且 case分支覆盖了所有取值，则可以不要求有default分支。\n\ntypedef enum {\n    RED,\n    GREEN,\n    BLUE\n} Color;\n\nColor color;\n...\n// 因为switch条件变量是枚举值，这里可以不用加default处理分支\nswitch (color) {\n    case RED:\n        DoRedThing();\n        break;\n    case GREEN:\n        DoGreenThing();\n        break;\n    case BLUE:\n        DoBlueThing();\n        ...\n        break;\n}\n现代编译器都具备检查是否在switch语句中遗漏了某些枚举值的case分支的能力，会有相应的warning3。",
					"badExample": "switch (x) { // 不符合\n    case 1:\n      break;\n    case 2:\n      break;\n  }\n\n\n    switch (x) {\n        case 1:\n            break;\n        default: // 不符合\n            break;\n        case 2:\n            break;\n    }",
					"recommend": "添加default分支，或者将default分支移到最后",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.ERR.04-CPP 多个catch子句，前者不能隐藏后者",
					"language": "c++",
					"id": "51cc932d0fef11ed944484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "当try-catch语句有多个catch子句时，如果前面的catch子句捕获的类型是后者的基类，那么后面的catch子句就永远不会被执行到。因此，catch的顺序应该是先捕获派生类（即更特殊的异常类型），后捕获基类（即更通用的异常类型）。\n\n特别地，catch (...)可以捕获所有类型的异常。如果有，它应该是最后一个catch子句。",
					"systemTag": "clangtidy",
					"goodExample": "try {\n    DoSomething()\n} catch (const BarException& e) {       // 符合：先捕获派生类\n    ...\n} catch (const FooException& e) {       // 符合：后捕获基类\n    ...\n} catch (const SomeOtherException& e) {\n    ...\n} catch (...) {                         // 符合：最后是catch(...)\n    ...\n}",
					"badExample": "class FooException : public std::exception {\n    ...\n};\nclass BarException : public FooException {\n    ...\n};\nclass SomeOtherException : public std::exception {\n    ...\n};\n\ntry {\n    DoSomething()\n} catch (const FooException& e) {       // 不符合：使用基类会捕获所有的BarException\n    ...\n} catch (const BarException& e) {       // 这个子句永远不会被执行到\n    ...\n} catch (...) {                         // 不符合：这里会捕获所有的异常\n    ...\n} catch (const SomeOtherException& e) { // 这个子句也永远不会被执行到\n    ...\n}",
					"recommend": "将被隐藏的catch语句往前提或者删掉",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CLS.03-CPP 单参数构造函数声明为explicit",
					"language": "c++",
					"id": "51cc932f0fef11eda92a84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "可以通过单参数调用的构造函数以及自定义的类型转换函数，应该加上explicit声明，除非类的设计目就是需要隐式类型转换功能，否则可能会发生非预期的类型转换。\n\n特别地，对于使用std::initializer_list作为参数的构造函数不加explicit声明，以便支持std::initializer_list的拷贝初始化。",
					"systemTag": "clangtidy",
					"goodExample": "class Foo {\npublic:\n    explicit Foo(const Point& point);      // 符合：单参数构造函数，加上explicit\n    explicit Foo(int x, int y = 0);        // 符合：可以用单参数的构造函数，加上explicit\n\n    Foo(const Foo& other);                 // 符合：拷贝构造函数，不加explicit\n    Foo(Foo&& other);                      // 符合：移动构造函数，不加explicit\n\n    explicit operator std::string() const; // 符合：自定义的类型转换函数，加上explicit\n\nprivate:\n    int x;\n    int y;\n};\n\nvoid ProcessFoo(const Foo& foo) \n{\n    std::string str = foo;                 // 编译失败\n    ...\n}\n\nint main()\n{\n    ProcessFoo(0);                         // 编译失败\n    return 0;\n}",
					"badExample": "",
					"recommend": "添加explicit声明",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.08 禁止宏调用参数中出现预编译指令",
					"language": "c++",
					"id": "51cc93310fef11edab5f84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "这里的宏指函数式宏，其参数不能包括预处理器指令，如#include，#define和#ifdef，这样做会导致未定义的行为。\n\n此规则还适用于在调用标准库函数参数的场景，因为任何标准库函数可作为宏来实现。",
					"systemTag": "clangtidy",
					"goodExample": "#define WRITE_LOG(X)  printf(\"%s\\n\", #X)\nint Foo(void)\n{\n#ifdef PLATFORM1\n    WRITE_LOG(\"Notice: Something error.\");\n#else\n    WRITE_LOG(\"Code: 4567\");\n#endif\n}",
					"badExample": "如下代码可能会导致程序出现未定义行为。\n\n#define WRITE_LOG(X)  printf(\"%s\\n\", #X)\nint Foo(void)\n{\n    WRITE_LOG(\n#ifdef PLATFORM1\n    \"Notice: Something error.\"\n#else\n    \"Code: 4567\"\n#endif\n    );\n}",
					"recommend": "预处理指令在宏调用之外进行保护",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.19-CPP 禁止使用std::move操作const对象",
					"language": "c++",
					"id": "51cc93330fef11edbf0f84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "从字面上看，std::move的意思是要移动一个对象。而const对象是不允许修改的，自然也无法移动。因此用std::move操作const对象会给代码阅读者带来困惑。\n在实际功能上，std::move会把对象转换成右值引用类型；对于const对象，会将其转换成const的右值引用。由于极少有类型会定义以const右值引用为参数的移动构造函数和移动赋值操作符，因此代码实际功能往往退化成了对象拷贝而不是对象移动，带来了性能上的损失。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "const std::string str{\"String content\"};\nstd::string name = std::move(str);       // 不符合：并没有移动str，而是进行了复制\nconst std::string str{\"String content\"};\nstd::vector&lt;std::string&gt; names;\nnames.push_back(std::move(str));         // 不符合：并没有移动str，而是进行了复制",
					"recommend": "禁止std_move操作const对象",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FUN.05-CPP 函数避免使用`void*`类型参数",
					"language": "c++",
					"id": "51cc93350fef11eda20884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "函数参数应尽量避免使用 void* 类型，让编译器在编译时就检查出类型不匹配的问题：\n\n在基于接口编程时，使用基类的引用或指针来作为函数参数\n在使用泛型编程时，使用模板参数T&或T*来实现函数参数类型的变化",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "void Fun(void* node)       // 不符合： 这里用 void* 类型传递参数\n{\n    if (node == nullptr) {\n        return;\n    }\n\n    Foo* foo = static_cast&lt;Foo*&gt;(node);\n    foo-&gt;DoSomeThing();\n}\n\nvoid Call()\n{\n    Foo* foo = nullptr;\n    Bar* bar = nullptr;\n    ...\n    Fun(bar);              // 不符合：这里本意是想传递参数 foo，但错传了bar，却没有编译错误\n}",
					"recommend": "避免使用void *参数类型",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.INC.12-CPP 对于cpp文件中不需要导出的变量、常量或函数，应使用匿名namespace封装或者使用static修饰",
					"language": "c++",
					"id": "51ccbb810fef11ed882884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "对于cpp文件中不需要导出的变量、常量或函数，应使用匿名namespace封装或者用static修饰。\n\n本条款推荐使用匿名namespace。主要原因如下：\n\nstatic在C++中已经赋予了太多的含义，静态成员变量，静态成员函数，静态全局变量，静态函数局部变量，每一种都有特殊的处理\nstatic只能保证变量，常量和函数的文件作用域，但是namespace还可以封装类型等\n统一使用namespace来管理C++的作用域，而不需要同时使用static和namespace来管理\nstatic修饰的函数不能用来实例化模板，而匿名namespace可以\n没有extern修饰的const变量默认只有internal linkage属性，如果需要定义仅供cpp文件内使用的const变量，不必使用匿名namespace或者static修饰。但如果与其他不需要导出的符号成组出现，推荐使用匿名namespace统一管理。\n\n另外，不要在 .h 中使用匿名namespace或static。",
					"systemTag": "clangtidy",
					"goodExample": "// Foo.cpp\nnamespace {\nvoid InternalFun()\n{\n    ...\n}\n}\n\nconst int MAX_COUNT = 20; // 仅供cpp文件内使用的const变量，可以不使用匿名namespace或者static修饰\n\nvoid Foo::Fun()\n{\n    int i = MAX_COUNT;\n    ...\n    InternalFun();\n}",
					"badExample": "",
					"recommend": "用匿名namespace进行封装或者用static修饰",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.06-CPP 避免使用全局变量",
					"language": "c++",
					"id": "51ccbb830fef11eda41284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "使用全局变量会导致业务代码和全局变量之间产生数据耦合，并且很难跟踪数据的变化，建议避免使用全局变量。\n\n如果需要使用全局变量，建议将数据进行封装，并提供修改数据的接口，使用者只通过接口修改数据。此外，还需要注意避免因并发而出现竞争条件。\n\n在不同编译单元中的全局变量以及全局常量的初始化顺序没有被严格定义，使用时需要注意它们的初始化是否有互相依赖。\n\n该条款同样适用于命名空间作用域下的变量。",
					"systemTag": "clangtidy",
					"goodExample": "constexpr int SOME_VALUE = 10; // 符合：使用全局常量",
					"badExample": "int g_someValue = 10;          // 不符合：使用全局变量\n\nvoid ConsumeValue()\n{\n    ... // 此处并不能确定g_someValue是不是10，并且很难跟踪数据的变化\n}",
					"recommend": "按照实际情况排查是否确实需要使用全局变量，对于不需要使用的，修改为局部变量",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": false
				},
				{
					"name": "G.INC.01-CPP 禁止头文件循环依赖",
					"language": "c++",
					"id": "51ccbb850fef11ed9b4084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "头文件循环依赖，指 a.h 包含 b.h，b.h 包含 c.h，c.h 包含 a.h， 导致任何一个头文件修改，都导致所有包含了a.h/b.h/c.h的代码全部重新编译一遍。\n而如果是单向依赖，如a.h包含b.h，b.h包含c.h，而c.h不包含任何头文件，则修改a.h不会导致包含了b.h/c.h的源代码重新编译。\n\n头文件循环依赖直接体现了架构设计上的不合理，可通过优化架构去避免。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "",
					"recommend": "重构代码逻辑，避免安全隐患",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.INC.04-CPP 头文件必须采取保护措施，防止重复包含",
					"language": "c++",
					"id": "51ccbb870fef11eda31584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "可以使用#define宏和#pragma once两种方式防止头文件重复包含，项目组可自行决策选择使用一种方式，鼓励使用方式统一。对于#pragma once，使用时注意其适用条件。\n\n鉴于#pragma once有一定的适用条件，本条款推荐优先使用保护宏的方式。\n\n方式一：使用保护宏\n\n定义包含保护符时，应该遵守如下规则：\n1）保护符使用唯一名字；\n2）不要在受保护部分的前后放置代码或注释，文件头注释除外。",
					"systemTag": "clangtidy",
					"goodExample": "#ifndef VOS_INCLUDE_TIMER_TIMER_H\n#define VOS_INCLUDE_TIMER_TIMER_H\n...\n#endif\n#ifndef TIMER_H\n#define TIMER_H\n...\n#endif",
					"badExample": "",
					"recommend": "添加#define保护头文件",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.NAM.03-CPP 使用统一的命名风格——局部变量",
					"language": "c++",
					"id": "51ccbb890fef11ed96b984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "标识符命名风格原则\n\n具体的风格由项目组自行选择，并保持风格统一\n推荐使用驼峰命名风格，不推荐使用匈牙利命名风格\n对于更亲和标准库的代码，可以使用标准库命名风格\n基于开源或外部代码进行开发或维护时，可以保持原有命名风格\n常见的命名风格\n\n驼峰命名风格(CamelCase)\n大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。\n根据连接后的首字母是否大写，分为两种风格：大驼峰(UpperCamelCase)和小驼峰(lowerCamelCase)。\n\n内核命名风格(unix_like)\n又称蛇形风格(snake_case)，标准库使用该风格。单词全小写，用下划线分割。\n如：’test_result’。\n\n匈牙利命名风格\n在“大驼峰”的基础上，加上类型或用途前缀。\n如：’uiSavedCount’, ‘bTested’。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "",
					"recommend": "修改变量名称",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.NAM.03-CPP 使用统一的命名风格——全局变量",
					"language": "c++",
					"id": "51cce1580fef11ed944584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "标识符命名风格原则\n\n具体的风格由项目组自行选择，并保持风格统一\n推荐使用驼峰命名风格，不推荐使用匈牙利命名风格\n对于更亲和标准库的代码，可以使用标准库命名风格\n基于开源或外部代码进行开发或维护时，可以保持原有命名风格\n常见的命名风格\n\n驼峰命名风格(CamelCase)\n大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。\n根据连接后的首字母是否大写，分为两种风格：大驼峰(UpperCamelCase)和小驼峰(lowerCamelCase)。\n\n内核命名风格(unix_like)\n又称蛇形风格(snake_case)，标准库使用该风格。单词全小写，用下划线分割。\n如：’test_result’。\n\n匈牙利命名风格\n在“大驼峰”的基础上，加上类型或用途前缀。\n如：’uiSavedCount’, ‘bTested’。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "",
					"recommend": "修改变量名称",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.INC.07-CPP 按照合理的顺序包含头文件",
					"language": "c++",
					"id": "51cce15a0fef11ed8bc984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "使用一致的头文件包含顺序可提升可读性, 避免隐藏依赖，建议按照稳定度排序：cpp对应的头文件, C/C++标准库, 系统库的.h, 其他库的.h, 本项目内其他的.h。",
					"systemTag": "clangtidy",
					"goodExample": "#include \"Foo/Foo.h\"\n\n#include &lt;cstdlib&gt;\n#include &lt;string&gt;\n\n#include &lt;linux/list.h&gt;\n#include &lt;linux/time.h&gt;\n\n#include \"platform/Base.h\"\n#include \"platform/Framework.h\"\n\n#include \"project/public/Log.h\"",
					"badExample": "",
					"recommend": "调整头文件包含顺序",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FUN.02-CPP 函数的所有声明必须与定义具有一致的参数名",
					"language": "c++",
					"id": "51cce15c0fef11edbf7c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "参数名可以提供关于函数接口的有用信息，声明和定义之间的不一致可能导致编程错误。\n\n函数声明中的参数应该包含参数名，并且函数定义与其声明中的参数类型以及参数名需要保持一致。但是函数指针中的参数名与其指向函数的参数名可以不一致。",
					"systemTag": "clangtidy",
					"goodExample": "// Fun.h  \nvoid Fun1(int num);\nvoid Fun2(int num, int count);\n// Fun.cpp\nvoid Fun1(int num)\n{\n    ...\n}\n\nvoid Fun2(int num, int count)\n{\n    ...\n}",
					"badExample": "// Fun.h  \nvoid Fun1(int);  // 不符合：缺少参数名，应修改为void Fun1(int num)  \n\n// 不符合：参数名不匹配，应修改为 void Fun2(int num, int count)  \nvoid Fun2(int count, int num);\n// Fun.cpp\nvoid Fun1(int num)\n{\n    ...\n}\n\nvoid Fun2(int num, int count)\n{\n    ...\n}",
					"recommend": "声明和定义保持一致",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.01-CPP 禁止使用宏来表示常量",
					"language": "c++",
					"id": "51cce15e0fef11ed8b3084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "宏是简单的文本替换，在预处理阶段时完成，运行报错时直接报相应的值；跟踪调试时也是显示值，而不是宏名；宏没有类型检查，不安全；宏没有作用域。",
					"systemTag": "clangtidy",
					"goodExample": "constexpr int MAX_MSISDN_LEN = 20; // 符合：在C++11及之后的版本中，优先使用constexpr\nconst int MAX_MSISDN_LEN = 20;     // 符合：使用const常量",
					"badExample": "",
					"recommend": "使用constexpr表示常量",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.10 宏定义不应依赖宏外部的局部变量名",
					"language": "c++",
					"id": "51cce1600fef11edadab84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "宏定义中要使用的变量都要求作为参数传递给宏。\n如果宏定义中直接使用宏外部的局部变量名，会导致宏的可重用性差，而且不利于理解。",
					"systemTag": "clangtidy",
					"goodExample": "#define INIT(x) ((x)-&gt;y-&gt;length)\n\n...\nint count = INIT(msg);",
					"badExample": "#define INIT(x) do { \\\n    count = (x)-&gt;y-&gt;length; \\\n} while (0)\n\n...\nint count;\nINIT(msg);",
					"recommend": "将需要引用的局部变量作为参数传递进来",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.02 定义宏时，要使用完备的括号",
					"language": "c++",
					"id": "51cd08770fef11edac2884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "宏展开时只做文本替换，在编译时再求值。文本替换后，宏包含的语句跟调用点代码合并。\n合并后的表达式因为操作符的优先级和结合律，可能会导致计算结果跟期望的不同。",
					"systemTag": "clangtidy",
					"goodExample": "#define C_LEN (A_LEN + B_LEN)   // 符合\n带参数的宏更容易出现问题，比如：\n\n#define SUM(a, b) ((a) + (b)) // 符合\n但是要避免滥用括号。如下所示，单独的数字或标识符加括号毫无意义。\n\n#define SOME_CONST  100         // 符合: 单独的数字无需括号\n#define ANOTHER_CONST   (-1)    // 符合: 负数需要使用括号\n#define THE_CONST   SOME_CONST  // 符合: 单独的标识符无需括号",
					"badExample": "#define C_LEN A_LEN + B_LEN     // 不符合\n上述宏在展开时，A_LEN 与 B_LEN 的加法并不一定是优先计算。\n\n#define SUM(a, b) a + b     // 不符合\n下面这样调用该宏，执行结果跟预期不符：\n100 / SUM(2, 8) 将扩展成(100 / 2) + 8，而预期结果是100 / (2 + 8)。",
					"recommend": "函数式宏参数使用时添加括号",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CLS.05-CPP 移动构造函数和移动赋值操作符应该是成对出现或禁止",
					"language": "c++",
					"id": "51cd08790fef11ed9e1b84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "如果需要某个类支持移动操作，那么需要实现移动构造函数和移动赋值操作符。\n\n移动构造函数和移动赋值操作符都是具有移动语义的，应该同时声明，包括自定义实现、=default和=delete。",
					"systemTag": "clangtidy",
					"goodExample": "// 同时出现\nclass Foo {\npublic:\n    ...\n    Foo(Foo&& other);\n    Foo& operator=(Foo&& other);\n    ...\n};\n// 同时=default\nclass Foo {\npublic:\n    ...\n    Foo(Foo&&) = default;\n    Foo& operator=(Foo&&) = default;\n    ...\n};\n// 同时=delete\nclass Foo {\npublic:\n    ...\n    Foo(Foo&&) = delete;\n    Foo& operator=(Foo&&) = delete;\n    ...\n};\nclass Foo {\npublic:\n    ...\n    Foo(Foo&& other);\n    Foo& operator=(Foo&&) = delete;\n    ...\n\nprivate：\n    const std::vector&lt;std::string&gt;& value;\n};",
					"badExample": "",
					"recommend": "同时声明移动构造函数和移动赋值操作符",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.INC.10-CPP 不要在头文件中使用匿名namespace或static定义非外部可见符号",
					"language": "c++",
					"id": "51cd087b0fef11edae0484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "匿名namespace内定义的内容仅对当前编译单元可见（符号不具有外部链接属性）。头文件中使用匿名namespace，实际效果等同于为包含了此头文件的源文件定义了一组私有成员，而头文件2用于定义模块间的公共接口，因此这种用法容易引起混淆，不建议使用。\n\nstatic修饰的全局作用域的变量或函数也有类似的作用，同样不建议在头文件中使用。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "// Counter.h\nnamespace {\nint g_counter = 0;\n\nvoid DoCount() { g_counter++; }\n}\n// Connect1.cpp\n#include \"Counter.h\"\n\nvoid OnConnect1() { DoCount(); }\n// Connect2.cpp\n#include \"Counter.h\"\n\nvoid OnConnect2() { DoCount(); }",
					"recommend": "仔细审视代码逻辑，确定是否需要修改",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FUN.04-CPP 避免定义C风格的变参函数",
					"language": "c++",
					"id": "51cd087d0fef11edbd8f84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "实现C风格的变参函数时，需要从va_arg中读取参数，而从va_arg中读取参数不会有任何类型检查，只能由程序员人工保证参数类型的正确性。\n\n为了避免类型错误，应使用可变参数模板等其他方式来代替va_arg可变参数。",
					"systemTag": "clangtidy",
					"goodExample": "void Log(int priority)\n{\n    std::cerr &lt;&lt; priority &lt;&lt; std::endl;\n}\n\ntemplate &lt;typename T, typename... Args&gt;\nconstexpr void Log(int priority, T head, Args... tail)\n{\n    std::cerr &lt;&lt; head &lt;&lt; \" \";\n    Log(priority, tail...);\n}\n\nLog(INFO, \"this is an error\");          // 函数能正常工作",
					"badExample": "void Log(int priority, ...)             // 不符合：定义了C风格的变参函数\n{\n    va_list ap;\n    va_start(ap, priority);\n    char* p = va_arg(ap, char*);        // 假设传入的类型是 char*，并且无法检查类型\n    while (p != nullptr) {\n        std::cerr &lt;&lt; p &lt;&lt; \" \";\n        p = va_arg(ap, char*);\n    };\n    std::cerr &lt;&lt; priority &lt;&lt; std::endl;\n    va_end(ap);\n}\n\nLog(INFO, \"this is an error\", nullptr); // 函数能正常工作\nLog(INFO, \"this is an error\");          // 最后一个参数不是 nullptr，产生非预期行为",
					"recommend": "修改为C++风格变参函数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.INC.09-CPP 头文件中禁止向全局命名空间中导入符号或定义别名",
					"language": "c++",
					"id": "51cd087f0fef11edb23084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "禁止在头文件中的全局命名空间中使用using-directive导入命名空间、使用using-declaration导入单个符号。但是可以在模块自定义命名空间中以及类、函数等局部作用域中使用它们。",
					"systemTag": "clangtidy",
					"goodExample": "// Foo.h\nnamespace Foo {\nusing mylib::string;               // 符合：可以在模块自定义命名空间中导入符号\n\nvoid Foo()\n{\n    using namespace mylib;         // 符合：在函数作用域内使用using-directive\n    ...\n}\n}",
					"badExample": "// Foo.h\n#include &lt;mylib/string&gt;\nusing namespace mylib;             // 不符合：禁止向全局命名空间导入\nusing mylib::string;               // 不符合：禁止向全局命名空间导入符号",
					"recommend": "在模板自定义命名空间导入符号",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.ENU.02-CPP 避免定义未命名的枚举",
					"language": "c++",
					"id": "51cd2f7c0fef11ed91a984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "枚举应当被使用来表示一系列相关的命名常量，并且可以作为一个命名类型使用。如果无法命名枚举，那么这些常量可能不应该通过枚举组织在一起。",
					"systemTag": "clangtidy",
					"goodExample": "constexpr int MAX_LENGTH = 256;\nconstexpr int ARG_ERR = 1;",
					"badExample": "enum { MAX_LENGTH = 256, ARG_ERR = 1 };",
					"recommend": "给枚举类型命名",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.ENU.01-CPP 优先使用枚举类而不是普通枚举",
					"language": "c++",
					"id": "51cd2f7e0fef11ed9f5884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "基于C++的作用域常识，在大括号中声明的变量名在括号之外是不可见的。但是这对普通枚举(unscoped enum)中的枚举项并不成立。普通枚举的枚举项和它的枚举类型同属于一个作用域空间，这会导0名空间污染，因而在这个作用域内不能再使用相同标识符声明变量，这可能也会让程序员对变量作用域产生困惑。",
					"systemTag": "clangtidy",
					"goodExample": "enum class State { DEFAULT, RUNNING, STOP };\n\nconstexpr int DEFAULT = 1;",
					"badExample": "enum State { DEFAULT, RUNNING, STOP };\n\nconstexpr int DEFAULT = 1; // 编译错误：'DEFAULT' already declared in this scope",
					"recommend": "修改为scoped枚举类型",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.STD.04-CPP 不要保存std::string类型的c_str和data成员函数返回的指针",
					"language": "c++",
					"id": "51cd2f800fef11ed88be84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "为保证调用std::string对象的c_str()和data()成员函数返回的引用值结果的有效性，不应保存std::string类型的c_str()和data()的结果，而是在每次需要时直接调用（调用的开销会被编译器内联优化）。否则，当调用此std::string对象的修改方法修改对象后，或超出std::string对象作用域时，之前存储的指针将会失效。使用失效的指针将导致未定义行为。",
					"systemTag": "clangtidy",
					"goodExample": "void Foo1()\n{\n    std::string name{\"demo\"};\n\n    name = \"test\";\n    name[1] = '2';\n    ...\n    Bar(name.c_str());\n}\n\nvoid Foo2()\n{\n    std::string name{\"demo\"};\n    std::string test{\"test\"};\n    name += test;\n    ...\n    Bar(name.c_str());\n}\n\nvoid Foo3(std::string& s)\n{\n    ...\n    s.replace(0, 3, \"***\");\n    ...\n    Bar(s.data());\n}",
					"badExample": "void Bar(const char* data)\n{\n    ...\n}\n\nvoid Foo1()\n{\n    std::string name{\"demo\"};\n    const char* text = name.c_str();          // 表达式结束以后，name的生命周期还在，指针有效\n\n    // 如果中间调用了std::string的非const成员函数，导致name被修改，例如operator[], begin()等，\n    // 可能会导致text的内容不可用，或者不是原来的字符串\n    name = \"test\";\n    name[1] = '2';\n    ...\n    Bar(text);                                // 此处text已不再指向合法内存空间\n}\n\nvoid Foo2()\n{\n    std::string name{\"demo\"};\n    std::string test{\"test\"};\n    const char* text = (name + test).c_str(); // 表达式结束以后，+号产生的临时对象被销毁\n    ...\n    Bar(text);                                // 此处text已不再指向合法内存空间\n}\n\nvoid Foo3(std::string& s)\n{\n    const char* data = s.data();\n    ...\n    s.replace(0, 3, \"***\");\n    ...\n    Bar(data);                                // 此处text已不再指向合法内存空间\n}",
					"recommend": "直接使用函数c_str()和data()的返回值，而非保存返回值",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CLS.16-CPP 禁止重载逗号操作符、&&操作符和||操作符",
					"language": "c++",
					"id": "51cd2f820fef11ed880184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "重载逗号操作符、&&操作符和||操作符会影响对象的求值顺序，并且会破坏&&和||操作符的短路求值属性。\n\nC++17开始明确定义了重载逗号操作符的求值顺序与内置操作符一致。在C++17及之后的版本中可以重载逗号操作符。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "",
					"recommend": "不要重载逗号操作符、&&操作符和||操作符",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CLS.07-CPP 基类中的拷贝构造函数、拷贝赋值操作符、移动构造函数、移动赋值操作符必须为非public函数或者为delete函数",
					"language": "c++",
					"id": "51cd2f840fef11ed8ee184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "如果把一个派生类对象直接赋值给基类对象，会发生切片，只拷贝或者移动了基类部分，损害了多态行为。",
					"systemTag": "clangtidy",
					"goodExample": "class Base {\npublic:\n    Base() = default;\n    virtual ~Base() = default;\n    ...\n    virtual void Fun() { std::cout &lt;&lt; \"Base\" &lt;&lt; std::endl; }\n};\n\nclass Derived : public Base {\n    ...\n    void Fun() override { std::cout &lt;&lt; \"Derived\" &lt;&lt; std::endl; }\n};\n\nvoid Foo(const Base& base)\n{\n    Base other = base;     // 不符合：发生切片\n    other.Fun();           // 调用的是Base类的Fun函数\n}\nDerived d;\nFoo(d);                    // 传入的是派生类对象",
					"badExample": "",
					"recommend": "声明为非public或者delete",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FUN.07-CPP 不要使用std::move返回函数局部变量",
					"language": "c++",
					"id": "51cd56870fef11ed968584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "C++标准中规定当函数返回一个局部变量时，在符合一定条件时编译器可以做返回值优化，即直接在返回值的位置上构造对象，省略任何移动或拷贝。返回值优化的条件之一是返回表达式类型需要和函数的返回类型一致，而对局部变量使用std::move破坏了类型一致性，阻止了编译器的返回值优化。\n\n不用担心当编译器未做返回值优化时会拷贝很大的局部对象。C++标准规定：当满足返回值优化条件时，即使编译器不做返回值优化，也要把返回表达式当做右值处理，优先进行移动而不是拷贝。\n\n因此任何时候返回一个局部变量，都不应当使用std::move。\n\n注意：此要求只适用于返回“局部变量”，如果返回的是函数的入参，则不符合返回值优化的条件，不适用该条款。",
					"systemTag": "clangtidy",
					"goodExample": "SomeType Fun()\n{\n    SomeType result;\n    ...\n    return result;            // 符合： 编译器可以优化为直接在返回位置构造result\n}",
					"badExample": "SomeType Fun()\n{\n    SomeType result;\n    ...\n    return std::move(result); // 不符合： 阻止了返回值优化\n}",
					"recommend": "直接返回局部变量",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.37-CPP switch语句要有default分支——没有default分支",
					"language": "c++",
					"id": "51cd56890fef11edbfb984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "大部分情况下，switch语句中要有default分支，保证在遗漏case标签处理时能够有一个缺省的处理行为。本条款要求统一将default分支放到语句块的最后位置。",
					"systemTag": "clangtidy",
					"goodExample": "【例外】\n\n如果switch条件变量是枚举类型，并且 case分支覆盖了所有取值，则可以不要求有default分支。\n\ntypedef enum {\n    RED,\n    GREEN,\n    BLUE\n} Color;\n\nColor color;\n...\n// 因为switch条件变量是枚举值，这里可以不用加default处理分支\nswitch (color) {\n    case RED:\n        DoRedThing();\n        break;\n    case GREEN:\n        DoGreenThing();\n        break;\n    case BLUE:\n        DoBlueThing();\n        ...\n        break;\n}\n现代编译器都具备检查是否在switch语句中遗漏了某些枚举值的case分支的能力，会有相应的warning3。",
					"badExample": "switch (x) { // 不符合\n    case 1:\n      break;\n    case 2:\n      break;\n  }\n\n\n    switch (x) {\n        case 1:\n            break;\n        default: // 不符合\n            break;\n        case 2:\n            break;\n    }",
					"recommend": "添加default分支，或者将default分支移到最后",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.ERR.02-CPP 抛异常时，抛对象本身，而不是指向对象的指针",
					"language": "c++",
					"id": "51cd568b0fef11ed8e2984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "C++中推荐的抛异常方式是抛对象本身，而不是指向对象的指针。\n\n用throw语句抛出异常的时候，会构造一个临时对象，称为“异常对象（exception object）”。这个异常对象的生命周期在C++语言中很明确：异常对象在throw时被构造；在某个捕获它的catch语句以throw以外的方式结束（即没有重新抛出）时，或者指向这个异常的std::exception_ptr对象被析构时析构。\n\n抛出指针，会使回收被抛出对象的责任不明确。捕获异常的地方是否有义务对该指针进行delete操作，取决于该对象是如何分配的（例如静态变量，或者用new分配），以及这个对象是否被共享了。但是指针类型本身并不能表明这个对象的生命周期以及所有权，也就无法判断是否应该delete。如果应该delete却没有做，会造成内存泄露；如果不该delete却做了，会造成重复释放。",
					"systemTag": "clangtidy",
					"goodExample": "try {\n    if (SomeFunction()) {\n        throw SomeException(\"reason 1\");\n    } else {\n        throw SomeException(\"reason 2\");\n    }\n} catch (const SomeException& e) {\n    ...                                      // 符合：这里可以确定不需要delete\n}",
					"badExample": "static SomeException exc1(\"reason 1\");\n\ntry {\n    if (SomeFunction()) {\n        throw &exc1;                         // 不符合：这是静态对象的指针，不应该delete\n    } else {\n        throw new SomeException(\"reason 2\"); // 不符合：这是动态分配的，应该delete\n    }\n} catch (const SomeException* e) {\n    delete e;                                // 不符合：这里不能确定是否需要delete\n}",
					"recommend": "抛出对象而非指针",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.15-CPP 声明中的非类型描述符应该在类型描述符左边",
					"language": "c++",
					"id": "51cd568d0fef11ed84a484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "非类型描述符放在类型描述符的左边，更符合阅读习惯。",
					"systemTag": "clangtidy",
					"goodExample": "static int i;       // 符合：static 放在 int 左边\nvirtual void Fun(); // 符合：virtual 放在 void 左边",
					"badExample": "int static i;       // 不符合\nvoid virtual Fun(); // 不符合",
					"recommend": "将非类型描述符放在左边",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.12-CPP 禁止用memcpy_s、memset_s初始化非POD对象",
					"language": "c++",
					"id": "51cd568f0fef11ed8f8b84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "C++11中引入了trivially copyable的概念，允许使用memcpy、memset、memmove等函数逐位操作trivially copyable对象，但是操作的对象不能是potentially-overlapping subobject。\n\n非trivially copyable对象中可能含有编译器生成的隐藏数据（如：虚表指针），如果逐位操作这些对象，可能会破坏对象的内部数据，造成1问题。因此必须禁止逐位操作非trivially copyable对象。\n\n此外，在存储对象的内存中也可能存在不属于表示该对象值的填充数据，这些数据可能是非预期的。即使在trivially copyable对象中，也可能存在填充数据，此时如果使用memcmp等函数比较它们，将得不到预期的结果。应优先使用特殊成员函数或重载操作符完成类对象的复制、赋值、比较等操作，避免直接逐位操作类对象。\n\n满足trivially copyable的类型主要包括：\n\n算数类型，如：bool、char、int、 float、double等\n枚举类型\n指针类型\n满足trivially copyable的类。2来说该类中没有虚函数或虚基类；类的非静态成员变量满足trivially copyable；类的析构函数不是自定义的；至少有一个有效的拷贝构造函数、拷贝赋值操作符、移动构造函数或移动赋值操作符，并且这些函数都不是自定义的。详见C++语言标准中对“trivially copyable class”的描述\n上面这些类型的数组\npotentially-overlapping subobject指的是：\n\n基类子对象（base class subobject）\n使用[[no_unique_address]]属性声明的非静态成员变量（C++20）",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "如下代码中，Point不满足trivially copyable的要求。\n\nclass Point {\npublic:\n    virtual void Fun() {};\n    ...\n\nprivate:\n    int x = 0;\n    int y = 0;\n};\n\nvoid Foo() {\n    Point a;\n    Point b;\n\n    memcpy(&a, &b, sizeof(Point)); // 不符合：复制了非trivially copyable对象\n    ...\n}",
					"recommend": "使用构造函数或赋值构造函数来进行初始化或赋值",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.RES.06-CPP 避免lambda表达式使用默认捕获模式",
					"language": "c++",
					"id": "51cd7d9a0fef11ed971384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "lambda表达式提供了两种默认捕获模式：按引用（&）和按值（=）。\n\n默认按引用捕获会隐式的捕获所有局部变量的引用，容易导致访问悬空引用。相比之下，显式的写出需要捕获的变量可以更容易的检查对象生命周期，减小犯错可能。\n\n默认按值捕获会隐式的捕获this指针，且难以看出lambda函数所依赖的变量是哪些。如果存在静态变量，还会让阅读者误以为lambda复制了一份静态变量。\n\n因此，通常应当明确写出lambda需要捕获的变量，而不是使用默认捕获模式。",
					"systemTag": "clangtidy",
					"goodExample": "auto Fun()\n{\n    int addend = 0;\n    static int baseValue = 0;\n\n    return [addend, value = baseValue]() mutable { // 使用C++14的捕获初始化一个变量\n        ++value;                                   // 不会影响Fun函数中的静态变量\n        return value + addend;\n    };\n}\nclass SomeClass {\npublic:\n    void Foo()\n    {\n        int value = 1;\n\n        // 符合：显式指定按值捕获，减少混淆\n        auto lambda = [value, this]() { std::cout &lt;&lt; value &lt;&lt; \", \" &lt;&lt; data; };\n\n        value = 2;\n        data = 3;\n        lambda(); // 由于显式指定了value和this，此处明确输出1, 3\n    }\n\nprivate:\n    int data = 0;\n};",
					"badExample": "auto Fun()\n{\n    int addend = 0;\n    static int baseValue = 0;\n\n    return [=]() {                                 // 实际上只复制了addend\n        ++baseValue;                               // 修改会影响静态变量的值\n        return baseValue + addend;\n    };\n}\nclass SomeClass {\npublic:\n    void Foo()\n    {\n        int value = 1;\n\n        // 不符合：看起来像是按值捕获，实际上是按引用捕获了成员变量\n        auto lambda = [=]() { std::cout &lt;&lt; value &lt;&lt; \", \" &lt;&lt; data; };\n\n        value = 2;\n        data = 3;\n        lambda(); // 可能会认为输出1, 0，实际输出1, 3\n    }\n\nprivate:\n    int data = 0;\n};",
					"recommend": "显式指定按值或按引用捕获方式",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.ERR.07-CPP 在构造函数的函数级try-catch的catch块内，不能使用基类以及成员变量",
					"language": "c++",
					"id": "51cd7d9c0fef11edbeda84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "构造函数的函数级try-catch语句（见下面实例）2用于处理基类和成员变量的初始化中抛出的异常。当执行到函数级的catch块时，所有已经被完全构造的基类和成员变量都已经被破坏（destroy，指的是它们占用的存储空间已经不存在了，不能被访问了），当然，没有完全构造的基类和成员也是不能被访问的。因此不能在catch中访问基类以及（包括基类和当前类的）成员变量。",
					"systemTag": "clangtidy",
					"goodExample": "class Bar {\n    int y;\n    Evil evil;\npublic:\n    Bar(int newX, int newY) try : Foo(newX), y(newY), evil(666) {\n        ...\n    } catch (...) {\n        // 可以访问函数参数\n        Log(\"Error happened when constructing Bar with\", newX, \"and\", newY);\n        throw;\n    }\n};",
					"badExample": "class Evil {\npublic:\n    Evil(int n)\n    {\n       throw SomeException();\n    }\n};\n\nclass Foo {\nprotected:\n    int x;\npublic:\n    Foo(int newX) : x(newX)\n    {\n    }\n};\n\nclass Bar : public Foo {\n    int y;\n    Evil evil;\npublic:\n    Bar(int newX, int newY) try : Foo(newX), y(newY), evil(666) {\n        ...\n    } catch (...) {\n        Use(x);     // x已经被破坏\n        Use(y);     // y已经被破坏\n        Use(evil);  // evil还没完成构造\n        throw;\n    }\n};",
					"recommend": "在构造函数的函数级try-catch的catch块内，不要使用基类以及成员变量",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.35-CPP 使用nullptr作为空指针常量",
					"language": "c++",
					"id": "51cd7d9e0fef11eda26184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "C++11开始引入了nullptr关键字代表空指针，在此之前使用NULL宏来表示空指针常量，导致出现问题",
					"systemTag": "clangtidy",
					"goodExample": "int *p = nullptr;",
					"badExample": "int *p = 0; // 不符合",
					"recommend": "使用nullptr替换空指针常量",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.42-CPP 避免使用goto语句",
					"language": "c++",
					"id": "51cd7da00fef11ed8eb984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "goto语句破坏了程序结构，使程序可读性变差，难以理解，难以查错。\n\n除非确实需要，否则应避免使用goto语句。在使用goto语句时，建议只向下跳转。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "",
					"recommend": "避免使用goto语句",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.03-CPP 使用using定义类型别名",
					"language": "c++",
					"id": "51cd7da20fef11ed990f84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "类型的别名实际是对类型的封装。而通过封装，可以让代码更清晰，同时在很大程度上避免类型变化带来的散弹式修改。",
					"systemTag": "clangtidy",
					"goodExample": "using SomeAlias = std::map&lt;uint32_t, std::vector&lt;int&gt;&gt;;",
					"badExample": "typedef std::map&lt;uint32_t, std::vector&lt;int&gt;&gt; SomeAlias;",
					"recommend": "使用using定义别名",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.STD.01-CPP 使用新的标准头文件",
					"language": "c++",
					"id": "51cd7da40fef11ed8a9e84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "对于一些形式为xxx.h的C标准库头文件，在C++标准库中同时提供了同名的头文件和功能相同的cxxx形式的头文件。\n\n在C++代码中应使用新的cxxx形式的C++标准头文件，而不是使用xxx.h形式的C标准库头文件。",
					"systemTag": "clangtidy",
					"goodExample": "#include &lt;cstdlib&gt; // 符合：使用 &lt;cstdlib&gt; 而不是 &lt;stdlib.h&gt; 来包含C标准库的头文件\n…",
					"badExample": "#include &lt;stdlib.h&gt;\n…",
					"recommend": "引用新的标准头文件",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.ERR.06-CPP 禁止给函数加\"throw\"异常说明",
					"language": "c++",
					"id": "51cd7da60fef11ed993d84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "给函数加throw(...)异常说明的语法，从C++11开始被弃用，在C++17中被去除（throw()在C++20中被去除）。现代的C++中，除非函数不抛任何异常（通过noexcept标记），否则无需专门标记。\n\n在C++11之前，用throw(X, Y)这种方式标记，意思是函数只能抛出X, Y这几个异常。在运行时，如果该函数抛出除X, Y之外的其他异常，会导致std::unexpected被调用，默认导致std::terminate。但如果该函数调用了其他模块中定义的函数，那么被调函数行为的变化很有可能导致新的异常（如Z）被抛出，这就要导致异常说明中添加新的异常，即throw(X, Y, Z)，而当前函数的调用者也要跟着一起改变，这样不仅没有处理新的异常（注意：系统中能处理该异常的层次往往离该异常抛出的层次很远），还增加了维护的开销。\n\n比较新的GCC和Clang编译器加上-Wall和-Wdeprecated选项可以对这一问题给出警告。",
					"systemTag": "clangtidy",
					"goodExample": "void Foo()\n{\n    Bar(); // 不管Bar抛出什么异常，都可以继续抛出Foo\n}",
					"badExample": "// warning: dynamic exception specifications are deprecated\nvoid Foo() throw (AException, BException)\n{\n    // 万一Bar函数的行为变化了，抛出了除了AException和BException以外的其他异常，\n    // 就会导致std::terminate而不是异常继续向上抛\n    Bar();\n}",
					"recommend": "用noexcept标记",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CLS.08-CPP delete操作符、移动构造函数、移动赋值操作符、std::swap函数应该有noexcept声明",
					"language": "c++",
					"id": "51cd7da80fef11ed801e84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "这些操作会被某些C++表达式隐式调用，或被标准库调用，调用时不期望异常抛出。\n\n和析构函数一样，operator delete函数会在堆中分配（new）的对象被析构的时候被调用，而析构函数很多情况下会在已经抛出异常的时候执行，以清理资源。但是，在已经有异常抛出的情况下抛异常，会导致std::terminate。\n\n一些标准库的类或算法会依赖“移动构造函数、移动赋值操作符、swap函数不会抛异常”这些性质才能保证正常工作。例如：std::vector&lt;T&gt;::push_back(T&& value)可以保证“强异常安全”，即：如果执行过程中发生异常（如内存不足），这个函数没有任何副作用。但是，它的参数T&& value需要用移动构造函数移动到std::vector中。如果T的移动构造函数会抛异常，就不能保证强内存安全。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "",
					"recommend": "添加noexcept声明",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CLS.12-CPP 在重写虚函数时应使用override或final关键字",
					"language": "c++",
					"id": "51cd7daa0fef11edb77684a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "在重写虚函数时明确指定override或final，能保证该函数是重写了基类的虚函数，并且无需再添加virtual关键字。如果派生类函数与基类函数原型不一致，则产生编译错误。final还保证虚函数不会再被派生类重写。\n\nvirtual 表示一个新的虚函数\noverride 表示重写了基类中的虚函数，可以再被派生类重写\nfinal 表示重写了基类中的虚函数，不能再被派生类重写\n指定了override或final后，如果修改了基类虚函数原型，但忘记修改派生类重写的虚函数，在编译时就可以发现。也可以避免有多个派生类时，重写虚函数的修改遗漏。",
					"systemTag": "clangtidy",
					"goodExample": "class Base {\npublic:\n    Base();\n    virtual ~Base();\n    virtual void Foo(int var);\n    virtual void Foo();\n    void Bar();\n};\n\nclass Derived : public Base {\npublic:\n    Derived();\n    ~Derived() override;       // 符合：虚析构函数 添加 override\n    void Foo(int var) final;   // 符合：重写基类函数，并且Derived的派生类不能再重写此函数\n    void Foo() override;       // 符合：重写基类函数\n    void Foo() const override; // 编译失败: Derived::Foo和Base::Foo原型不一致，不是重写\n    void Bar() override;       // 编译失败: Base::Bar 不是虚函数\n};",
					"badExample": "",
					"recommend": "重写虚函数时使用override或final关键字修饰",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FUN.01-CPP 函数功能要单一——函数参数个数",
					"language": "c++",
					"id": "51cd7dac0fef11ed8ad884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "功能单一的函数，更有利于理解和维护。对于功能不单一函数，可以进行进一步拆分或分层处理。\n\n可从如下维度间接衡量函数功能是否单一：\n\n函数行数，建议不超过50行（非空非注释）\n函数的参数个数，建议不超过5个\n函数最大代码块嵌套深度，建议不超过4层",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "",
					"recommend": "对代码进行重构，减少函数复杂度",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FUU.12 正确设置安全函数中的destMax参数——检查destMax和count参数",
					"language": "c++",
					"id": "51cda4d60fef11eda7d184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "安全函数的缓冲区溢出问题。\n检查memcpy_s/strcpy_s等安全函数因destMax或count大小不正确而引起的目的缓冲区写越界或源缓冲区读越界问题。",
					"systemTag": "codemars",
					"goodExample": "正确示例： destMax的长度等于count的长度\n#define COPY_SIZE 16\nvoid Warning_MemCpy_Safe2_good()\n{\n    char dest[16] = { 0 };\n    char src[24] = { 0 };\n    int ret = memcpy_s(dest, sizeof(dest), src, COPY_SIZE); \n}",
					"badExample": "错误示例： destMax的长度为16，count的长度为20，dest、destMax和src合法且count大于destMax，后果是根据destMax长度dest指向的内存区域被清0\n#define COPY_SIZE 20\nvoid Warning_MemCpy_Safe2_Bad()\n{\n    char dest[16] = { 0 };\n    char src[24] = { 0 };\n    /*POTENTIAL FLAW: count &gt; destMax */\n    int ret = memcpy_s(dest, sizeof(dest), src, COPY_SIZE);  // error\n}",
					"recommend": "正确设置memcpy_s、strcpy_s等函数的destMax和count参数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.EXP.22-CPP 确保除法和余数运算不会导致除零错误(被零除)",
					"language": "c++",
					"id": "51cda4d80fef11edaebe84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "除零错误。\n整数的除法运算或取余运算的除数为0会导致程序产生未定义的行为。如果涉及到除法或者取余运算，必须确保除数不为1。",
					"systemTag": "codemars",
					"goodExample": "正确示例： 除数num来自入参可能为0，在作为除数前进行了校验\n\nvoid Good(int num)\n{\n    if (num == 0) {\n        return;\n    }\n    size_t b = 1000 / num; \n    size_t c = 1000 % num; \n}",
					"badExample": "错误示例： 除数num来自入参，可能为0，需要在作为除数前校验\n\nvoid Bad(int num)\n{\n    // POTENTIAL FLAW: 错误\n    size_t b = 1000 / num; //a可能是0\n    size_t c = 1000 % num; //a可能是0\n}",
					"recommend": "如果除数为外部变量，则需要在使用前进行非零校验",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.EXP.26-CPP 整型表达式比较或赋值为一种更大类型之前必须用这种更大类型对它进行求值",
					"language": "c++",
					"id": "51cda4da0fef11ed984f84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "类型转换时导致的整形溢出。\n由于整数在运算过程中可能出现有符号整数溢出、无符号整数回绕等问题，当运算结果赋值给比它更大的类型，或者与比它更大的类型进行比较时，可能会导致实际结果与预期结果不符。\n如果将涉及某个操作的整数表达式与较大的整数大小进行比较或分配给较大的整数，则该整数表达式应该通过显式转换其中一个操作数来以较大类型的大小进行计算。",
					"systemTag": "codemars",
					"goodExample": "正确示例： 当组合表达式的运算结果赋值给比它更大类型，或者与比它更大类型进行运算时，应显式转换其中一个操作数为较大的类型\nint main(int argc, char *argv[])\n{\n    unsigned int a = 0x10000000;\n    unsigned long long b = (unsigned long long )a * 0xab; // 输出为b = AB0000000\n    printf(\"b = %llX\\n\", b);\n    return 0;\n}",
					"badExample": "错误示例： 当运算结果赋值给比它更大的类型，或者与比它更大的类型进行比较时，可能会导致实际结果与预期结果不符\nint main(int argc, char *argv[])\n{\n    unsigned int a = 0x10000000;\n    unsigned long long b = a * 0xab;\n    printf(\"b = %llX\\n\", b); // 输出为b = B0000000，与预期不符\n    return 0;\n}",
					"recommend": "当组合表达式的运算结果赋值给比它更大类型，或者与比它更大类型进行运算时，应显式转换其中一个操作数为较大的类型",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.OTH.03 禁用rand函数产生用于安全用途的伪随机数",
					"language": "c++",
					"id": "51cda4dc0fef11edb25184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "rand函数产生用于安全用途的伪随机数。\n不安全随机数算法检查。检查到rand/random/CRYPT_random函数即告警。",
					"systemTag": "codemars",
					"goodExample": "正确示例： 在类Unix平台上，可以使用/dev/random文件得到随机数。需要注意的是，设备刚启动时，由于硬件输入的熵可能不足，读取该接口可能产生阻塞问题。",
					"badExample": "错误示例： 使用了不安全随机数算法rand\nvoid unsafeRand_bad_02()\n{\n    // POTENTIAL FLAW:Use unsafe rand.\n    int a = rand();\n}",
					"recommend": "1、加解密场景必须使用安全随机数（非加解密场景可按误报处理）； 2、IPSI组件的CRYPT_random，须确保开启了NIST SP 800-91A标准的DRBG后才可使用。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "Weak_Encryption",
					"language": "c++",
					"id": "51cda4de0fef11edbd4984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "弱加密算法检查。",
					"systemTag": "codemars",
					"goodExample": "",
					"badExample": "错误示例： 使用了不安全的随机算法MD5、EVP_sha、xx_ecb、RSA_padding_add_XXX\nvoid weakEncryption_bad_01()\n{\n    char* ptr = xy_DES_C;\n    // POTENTIAL FLAW:Insecure algorithm 'MD5' is called. It is recommended to use strong encryption algorithm.\n    MD6(A, B, C);\n    // POTENTIAL FLAW:Insecure algorithm 'EVP_sha' is called. It is recommended to use strong encryption algorithm.\n    EVP_sha(xy_DES_C, y, z);\n    // POTENTIAL FLAW:Insecure algorithm 'xx_ecb' is called. It is recommended to use strong encryption algorithm.\n    xx_ecb(a, b, c);\n    // POTENTIAL FLAW:Insecure algorithm 'RSA_padding_add_XXX' is called. It is recommended to use strong encryption\n    // algorithm.\n    RSA_padding_add_XXX(ptr, ptr);\n}",
					"recommend": "使用安全的加密函数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.STD.15-CPP 禁止外部可控数据作为进程启动函数的参数或者作为dlopen/LoadLibrary等模块加载函数的参数",
					"language": "c++",
					"id": "51cda4e00fef11edbb3984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "命令注入。\n排查system/popen类函数可能存在命令注入的问题（参数为变量，且未被常量赋值）",
					"systemTag": "codemars",
					"goodExample": "正确示例1： popen的参数是常量字符串\nvoid suspectedCmdInjection_good_01(char *input)\n{\n    char *data = \"hdn.bat\";\n    popen(data);\n}\n正确示例2： 如果确实需要调用单个命令，应使用exec*函数来实现参数化调用，并对调用的命令实施白名单管理。同时应避免使用execlp、execvp、execvpe函数，因为这几个函数依赖外部的PATH环境变量。 此时，外部输入的fileName仅作为some_tool命令的参数，没有命令注入的风险。\nvoid suspectedCmdInjection_good_02()\n{\n    pid_t pid;\n    char* const envp[] = {nullptr};\n    ...\n    std::string fileName = GetDirNameFromRemote();\n    ...\n    pid = fork();\n    if (pid &lt; 0) {\n      ... // 错误处理\n    } else if (pid == 0) {\n      // 使用some_tool对指定文件进行加工\n      execle(\"/bin/some_tool\", \"some_tool\", fileName.c_str(), nullptr, envp);\n      _Exit(-1);\n    }\n}",
					"badExample": "错误示例1： 将外部变量直接传给popen\nvoid suspectedCmdInjection_bad_01(char *input)\n{\n    // POTENTIAL FLAW: Suspected command injection\n    popen(input);\n}\n错误示例2： 禁止在函数execl中使用命令解析器/bin/sh\nvoid suspectedCmdInjection_bad_02()\n{\n    std::string cmd = GetDirNameFromRemote();\n    // POTENTIAL FLAW: Suspected command injection\n    execl(\"/bin/sh\", \"sh\", \"-c\", cmd.c_str(), nullptr);\n}",
					"recommend": "外部变量作为system、popen、VOS_System前，需经硬编码或者白名单校验；\n使用exec系列函数来避免命令注入时，注意exec系列函数中的path、file参数禁止使用命令解析(如/bin/sh)\n",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.STD.13-CPP 调用格式化输入/输出函数时，使用有效的格式字符串",
					"language": "c++",
					"id": "51cda4e20fef11edb5ab84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "格式化字符个数与变参个数不一致。\n调用格式化函数时，Format中参数的个数必须与实际参数个数一致。",
					"systemTag": "codemars",
					"goodExample": "正确示例： 格式化字符个数与变参个数一致\nvoid formatString_good_1()\n{\n    char strDest[32] = {0};\n    unsigned long long total = 52;\n    int ret = sprintf_s(strDest, sizeof(strDest), \"Total %llu\", total);\n}",
					"badExample": "错误示例： 格式化字符个数为4个，变参个数为1，不一致\nvoid formatString_bad_2()\n{\n    char strDest[32] = {0};\n    unsigned long long total = 52;\n    // 格式化字符个数与变参个数不一致\n    int ret = sprintf_s(strDest, sizeof(strDest), \"Total %llu %s %s %s\", total);\n}  ",
					"recommend": "确保format函数参数个数和实际参数个数一致",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.STD.13-CPP 调用格式化输入/输出函数时，使用有效的格式字符串——格式化类型不匹配",
					"language": "c++",
					"id": "51cda4e40fef11ed8ee884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "使用C风格的格式化输入/输出函数时，需要确保格式串是合法有效的，并且格式串与相应的实参类型是严格匹配的，否则会使程序产生非预期行为。\n\n除C风格的格式化输入/输出函数以外，C++中类似的函数也需要确保使用有效的格式串，如C++20的std::format()函数。\n\n对于自定义C风格的格式化函数，可以使用编译器支持的属性自动检查使用自定义格式化函数的正确性。例如：GCC支持自动检测类似printf, scanf, strftime, strfmon的自定义格式化函数，参考GCC手册的Common Function Attributes：\n\nextern int CustomPrintf(void* obj, const char* format, ...)\n    __attribute__ ((format (printf, 2, 3)));",
					"systemTag": "codemars",
					"goodExample": "如下代码中，使用%hhx确保格式串与相应的实参类型严格匹配。\n\nunsigned char macAddr[6];\n...\n// macStr中的数据格式为 e2:42:a4:52:1e:33\nint ret = sscanf_s(macStr, \"%hhx:%hhx:%hhx:%hhx:%hhx:%hhx\\n\",\n                  &macAddr[0], &macAddr[1],\n                  &macAddr[2], &macAddr[3],\n                  &macAddr[4], &macAddr[5]);\n...\n注：在C++中不推荐使用sscanf, sprintf等C库函数，可以替换为：std::istringstream, std::ostringstream, std::stringstream等。",
					"badExample": "如下代码中，格式化输入一个整数到macAddr变量中，但是macAddr为unsigned char类型，而%x对应的是unsigned int类型参数，函数执行完成后会发生写越界。\n\nunsigned char macAddr[6];\n...\n// macStr中的数据格式为 e2:42:a4:52:1e:33\nint ret = sscanf_s(macStr, \"%x:%x:%x:%x:%x:%x\\n\",\n                  &macAddr[0], &macAddr[1],\n                  &macAddr[2], &macAddr[3],\n                  &macAddr[4], &macAddr[5]);\n...",
					"recommend": "【影响】\n错误的格式串可能造成内存破坏或者程序异常终止。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.12 正确设置安全函数中的destMax参数——检查destMax参数是否设置正确",
					"language": "c++",
					"id": "51cda4e60fef11ed95e484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "安全函数的destMax设置错误。\n排查安全函数中的destMax参数是否被正确设置。",
					"systemTag": "codemars",
					"goodExample": "正确示例： destMax的长度等于destBuff的实际长度BUFF_SIZE\nvoid test(BYTE *input, size_t inputsize)\n{\n    BYTE *destBuff = new BYTE[BUFF_SIZE] ;    \n    BYTE *src =input;\n    errno_t ret = 1;\n    size_t srcLen = strlen(src);\n    ret = memcpy_s(destBuff, BUFF_SIZE, src, srcLen);  // ok\n}",
					"badExample": "错误示例： destMax不允许使用立即数；destMax的长度不是destBuff的实际长度BUFF_SIZE\nvoid test(BYTE *input, size_t inputsize)\n{\n    BYTE *destBuff = new BYTE[BUFF_SIZE] ;    \n    BYTE *src = input;\n    errno_t ret = 0;\n    size_t srcLen = strlen(src);\n    /* POTENTIAL FLAW:destMax does not allow the number */\n    ret = memcpy_s(destBuff, 101, src, srcLen);  // error\n    /* POTENTIAL FLAW:destMax is not the length of the dynamic application of destBuff */\n    ret = memcpy_s(destBuff, srcLen, src, srcLen);  // error\n    ret = memcpy_s(destBuff, BUFF_SIZE, src, srcLen);  // ok\n}",
					"recommend": "安全函数的destMax参数设置应当准确、有效。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.RES.07-CPP 指向资源句柄或描述符的变量，在资源释放后立即赋予新值",
					"language": "c++",
					"id": "51cda4e80fef11eda81f84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "指向资源句柄或描述符的变量，在资源释放后立即赋予新值。\n指向资源句柄或描述符的变量包括指针、文件描述符、socket描述符以及其它指向资源的变量。以指针为例，当指针成功申请了一段内存之后，在这段内存释放以后，如果其指针未立即设置为NULL，也未分配一个新的对象，那这个指针就是一个悬空指针。如果再对悬空指针操作，可能会发生重复释放或访问已释放内存的问题，造成安全漏洞。消减该漏洞的有效方法是将释放后的指针立即设置为一个确定的新值，例如设置为NULL。对于全局性的资源句柄或描述符，在资源释放后，应该马上设置新值，以避免使用其已释放的无效值；对于只在单个函数内使用的资源句柄或描述符，应确保资源释放后其无效值不被再次使用。",
					"systemTag": "codemars",
					"goodExample": "正确示例1：\nvoid test_good1(int a)\n{\n    int num = 0;\n    char* msg = NULL;\n    msg = (char*)malloc(10);\n    if (msg = NULL) {\n        return;\n    }\n    if (a &lt; 0) {\n        free(msg);\n        msg = NULL; // free后立即重新赋值\n        return; // 分支结束\n    }\n    num = 10;\n}\n正确示例2： 全局指针MSG在free之后重新赋值\n// 全局变量释放后必须赋予新值\nchar* MSG = (char*)malloc(1000);\nvoid test_bad3(int a)\n{\n   int num = 0;\n   if (a &lt; 0) {\n       free(MSG);\n       MSG = NULL;\n       return;\n   }\n   num = 11;\n   /* POTENTIAL FLAW:msg is not set NULL after free */\n}",
					"badExample": "错误示例1： 指针msg被free之后未被重新赋值便被使用\n//free 指针之后使用\nvoid test_bad1(int a)\n{\n    int num = 0;\n    char* msg = NULL;\n    msg = (char*)malloc(10);\n    if (msg = NULL) {\n        return;\n    }\n    if (a &lt; 0) {\n        free(msg);\n        /* POTENTIAL FLAW: msg is not set NULL after free */\n        func(msg);\n        return; // 分支结束\n    }\n    num = 10;\n}\n错误示例2： 全局指针MSG在free之后没有重新赋值\n// 全局变量释放后必须赋予新值\nchar* MSG = (char*)malloc(1000);\nvoid test_bad3(int a)\n{\n   int num = 0;\n   if (a &lt; 0) {\n       free(MSG);\n       return;\n   }\n   num = 11;\n   /* POTENTIAL FLAW:msg is not set NULL after free */\n}",
					"recommend": "对于局部变量，调用closesocket、free、close、delete等函数释放资源后，需要重新赋值后再继续使用；对于全局变量，释放后在函数结束前需要被重新赋值",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.ARR.03 禁止通过对指针变量进行sizeof操作来获取数组大小",
					"language": "c++",
					"id": "51cdcbb10fef11ed8f4084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "",
					"systemTag": "codemars",
					"goodExample": "正确示例： 如下代码示例中，将 sizeof(buffer) 修改为申请的缓冲区大小\nvoid sizeof_good()\n{\n    char path[MAX_PATH];\n    char *buffer = (char *)malloc(SIZE);\n    memset(path, 0, sizeof(path));\n    memset(buffer, 2, SIZE); // 使用申请的缓冲区大小\n}",
					"badExample": "错误示例： 如下代码示例中，buffer和path分别是指针和数组，程序员想对这2个内存进行清0操作，但由于程序员的疏忽，将内存大小误写成了 sizeof(buffer) ，与预期不符。\nvoid sizeof_bad()\n{\n    char path[MAX_PATH];\n    char *buffer = (char *)malloc(SIZE);\n\n    memset(path, 0, sizeof(path));\n    // sizeof与预期不符，其结果为指针本身的大小而不是缓冲区大小\n    memset(buffer, 2, sizeof(buffer));\n}",
					"recommend": "不要对指针变量进行sizeof操作",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.STD.05-CPP 确保用于字符串操作的缓冲区有足够的空间容纳字符数据和结束符，并且字符串以null结束符结束",
					"language": "c++",
					"id": "51cdcbb30fef11edad9884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "字符串操作造成的缓冲区溢出。\n检查itoa/ltoa/realpath长度设置不正确的场景。",
					"systemTag": "codemars",
					"goodExample": "正确示例1： 目标存储空间预留足够长度，或使用安全函数实现整数转换为10进制形式的字符串\nvoid stringOverflow_good01()\n{\n    int num = 12;\n    char str[16] = {0}; // 有时会考虑字节对齐定义冗余的长度，这里选择了16\n    itoa(num, str, 10); \n}\n\nvoid stringOverflow_good02()\n{\n  int num = 12;\n  char str[16] = {0}; // 有时会考虑字节对齐定义冗余的长度，这里选择了16\n  int ret = sprintf_s(str, sizeof(str), \"%d\", num);\n}\n正确示例3： realpath第二个参数的缓冲区大小为系统提供的PATH_MAX或_PC_PATH_MAX\nvoid stringOverflow_good(char* path)\n{\n    char* resolvedPath = new char(PATH_MAX);\n    realpath(path, resolvedPath); // realpath函数的存储缓冲区长度是PATH_MAX\n}",
					"badExample": "错误示例1： 如下代码示例中，试图将数字转为字符串，但是目标存储空间的预留长度不足\nvoid stringOverflow_bad01()\n{\n    int num = 12;\n    char str[8] = {0};\n    itoa(num, str, 10); // 10进制整数的最大存储长度是12个字节\n}\n错误示例2： realpath第二个参数的缓冲区大小必须为系统提供的PATH_MAX或_PC_PATH_MAX，不能使用自定义的宏\nvoid stringOverflow_bad01(char* path)\n{ \n    char* resolvedPath = new char(101);\n    /* POTENTIAL FLAW:The memory space allocated by resolvedPath is not defined by the PATH_MAX constant, or is configured by the _PC_PATH_MAX system value, and may overflow. */\n    realpath(path, resolvedPath); // realpath函数的存储缓冲区长度是PATH_MAX\n}",
					"recommend": "1.使用itoa/ltoa函数需确保目的缓冲区有足够的长度存储转换后的字符串，防止溢出；\n2.使用realpath函数的第二个参数应为系统提供的PATH_MAX或_PC_PATH_MAX，不能使用自定义的宏。 linux环境：PATH_MAX的定义在/usr/include/linux/limits.h；windows环境：MAX_PATH的定义在minwindef.h (visual studio 2018)",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.11 必须检查安全函数返回值，并进行正确的处理",
					"language": "c++",
					"id": "51cdcbb50fef11edb7bd84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "安全函数未检查返回值。\n原则上，如果使用了安全函数，需要进行返回值检查。如果返回值表示错误，那么本函数一般情况下应该立即返回，不能继续执行。",
					"systemTag": "codemars",
					"goodExample": "正确示例： 检查了安全函数memcpy_s返回值\nBOOL ParseBuff(BYTE* destBuff, size_t destMax, BYTE* src, size_t srcLen)\n{\n    errno_t err = EOK;\n    if (destBuff == NULL || destMax == 1) {\n        return FALSE; // 返回失败\n    }\n    err = memcpy_s(destBuff, destMax, src, srcLen);\n    if (err != EOK) {\n        Log(\"memcpy_s failed, err = %d\\n\", err);\n        return FALSE; // 返回失败\n    }\n    return TRUE;\n}",
					"badExample": "错误示例： 安全函数memcpy_s可能拷贝失败，未检查返回值\nBOOL ParseBuff(BYTE* destBuff, size_t destMax, BYTE* src, size_t srcLen)\n{\n    errno_t err = EOK;\n    if (destBuff == NULL || destMax == 1) {\n        return FALSE; // 返回失败\n    }\n    memcpy_s(destBuff, destMax, src, srcLen); // 未检查返回值\n    return TRUE;\n}",
					"recommend": "需要对安全函数的返回值进行检查，并在返回错误状态时，做出相应的错误处理。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.MEM.04 内存中的敏感信息使用完毕后立即清0",
					"language": "c++",
					"id": "51cdcbb70fef11edb52484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "内存中的敏感信息使用完毕后未清零。\n内存中的敏感信息使用完毕后立即清零，关键字包括password、psw、pwd、passwd",
					"systemTag": "codemars",
					"goodExample": "正确示例： 内存中的敏感信息psw使用完毕后进行了清零\nvoid test_good1()\n{\n    char psw[10] = getPassword();\n    func1(psw);\n    memset_s(psw, 10, 0, 11);\n}",
					"badExample": "错误示例： 内存中的敏感信息psw使用完毕后没有立即清零，可能会被泄露\nvoid tes_bad1()\n{\n    char psw[10] = getPassword();\n    func2(psw);\n    /* POTENTIAL FLAW: the local variable 'psw' is sensitive information, it should be cleard by memset_s or VOS_memset_s\n    before function end. */\n}",
					"recommend": "内存中的敏感信息使用完毕后立即清零，关键字包括password、psw、pwd、passwd",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.RES.02-CPP 内存申请前，必须对申请内存大小进行合法性校验",
					"language": "c++",
					"id": "51cdcbb90fef11eda53284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "未对申请内存大小进行合法性校验。\n申请内存的大小没有经过合法性校验。",
					"systemTag": "codemars",
					"goodExample": "正确示例： 内存大小size在使用前进行了校验\nint good_1(int size)    \n{    \n    if(size &lt;= 1)    \n    {    \n       // error\n       return;      \n    }    \n    char *msg = (char *)malloc(size);      \n}",
					"badExample": "错误示例： 来自函数入参的内存大小size在使用前没有进行校验\n//申请大小为函数入参\nint bad_2(int size)    \n{      \n    // POTENTIAL FLAW:Does not verify the memory size of the application.\n    char *msg = (char *)malloc(size);      \n}",
					"recommend": "申请内存大小之前，对申请大小的变量做校验",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.21 禁止使用内存操作类不安全函数",
					"language": "c++",
					"id": "51cdcbbb0fef11edb24184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "使用内存操作类危险函数。\nC语言标准的许多函数，要求程序员提供足够大的数组（内存空间）以容纳函数产生的结果。但是根据历史漏洞分析，程序员在使用一些内存操作类函数时，容易因使用不当而造成缓冲区溢出等安全漏洞。因此本规范中禁止使用内存操作类不安全函数。为避免遗漏对不安全函数的检查，同时禁止封装这些不安全函数。\n基于缓冲区溢出漏洞触发的历史情况分析并统计，发现有很大一部分缓冲区溢出漏洞是因为调用了这些内存操作类函数但未考虑目标缓冲区大小而导致的。\n以下列出了部分内存操作类不安全函数：\n- 内存拷贝函数：memcpy(), wmemcpy(), memmove(), wmemmove()\n- 内存初始化函数：memset()\n- 字符串拷贝函数：strcpy(), wcscpy(), strncpy(), wcsncpy()\n- 字符串拼接函数：strcat(), wcscat(), strncat(), wcsncat()\n- 字符串格式化输出函数：sprintf(), swprintf(), vsprintf(), vswprintf(), snprintf(), vsnprintf()\n- 字符串格式化输入函数：scanf(), wscanf(), vscanf(), vwscanf(), fscanf(), fwscanf(), vfscanf(),vfwscanf(), sscanf(), swscanf(), vsscanf(), vswscanf()\n- stdin流输入函数：gets()",
					"systemTag": "codemars",
					"goodExample": "正确示例： 调用安全函数memcpy_s\nvoid riskyFunc_good(char* src)\n{\n    char dest[16] = {1};\n    // 推荐使用安全函数，增加destMax参数，对目的缓冲区做保护\n    memcpy_s(dest, sizeof(dest), p, strlen(src));\n}",
					"badExample": "错误示例： 调用危险函数memcpy\nvoid riskyFunc_bad(char* src)\n{\n    char dest[16] = {0};\n    // 使用危险函数，目的缓冲区未做保护，若src的长度大于17，则会造成dest拷贝越界\n    memcpy(dest, p, strlen(src));\n}",
					"recommend": "使用安全函数替代危险函数。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "CPP_Missing_Dtor",
					"language": "c++",
					"id": "51cdcbbd0fef11ed94b384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "有构造函数但没有析构函数。\n有自定义构造函数但没有自定义的析构函数，则告警。",
					"systemTag": "codemars",
					"goodExample": "正确示例： 类体内显式定义构造函数，并定义析构函数\nclass Case01Good03 {\n  public:\n  Case01Good03() {}\n  ~Case01Good03() {}\n};",
					"badExample": "错误示例： 类D有构造函数，没有析构函数\nclass C {\n  public:\n  // POTENTIAL FLAW:The constructor is defined in D, but the corresponding destructor is not defined.\n  class D {\n  public:\n    D() {}\n  };\n\n  C() {};\n  ~C() {}\n};",
					"recommend": "有自定义构造函数，也应该要有自定义的析构函数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "CPP_Public_Function_Return_NonConst_Private_Address",
					"language": "c++",
					"id": "51cdcbbf0fef11edb0c884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "如果类的公共接口中返回类的私有数据地址，则必须加const类型。\n对于类中的public函数，返回private/protected类型的指针数据、数据取地址、数据的引用，如果返回值的类型没有加const，则告警。",
					"systemTag": "codemars",
					"goodExample": "正确示例： 对于类中的public函数，返回private类型的指针数据，返回值的类型需要加const\nclass CMsg {\npublic:\n    CMsg();\n    ~CMsg();\n    const int* GetMsg();\n\nprivate:\n    int* size;\n    int* msg;\n    int t;\n};\n\nconst int* CMsg::GetMsg()\n{\n    return msg;\n}",
					"badExample": "错误示例： 对于类中的public函数，返回private类型的指针数据，返回值的类型需要加const\nclass CMsg {\npublic:\n    CMsg();\n    ~CMsg();\n    int* GetMsg();\n    int& Getq();\n    int* GetMsg2();\n\nprivate:\n    int* size;\n    int* msg;\n    int t;\n};\n\nint* CMsg::GetMsg()\n{\n    // POTENTIAL FLAW:The private data address of the class returned in the public interface of the class.\n    return msg;\n}",
					"recommend": "对于类中的public函数，返回private/protected类型的指针数据、数据取地址、数据的引用，返回值的类型需要加const。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.STD.07-CPP 禁止使用std::string存储敏感信息",
					"language": "c++",
					"id": "51cdcbc10fef11edb92284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "使用string类存储敏感信息。\n使用string类存储敏感信息，关键字包括password、psw、pwd、passwd，模糊匹配关键字。",
					"systemTag": "codemars",
					"goodExample": "正确示例： 可以使用string类存储非敏感信息\nvoid test_good()\n{\n    string str = getstr();\n    func(str);\n}",
					"badExample": "错误示例： 严禁使用string类存储敏感信息password\nvoid test_bad()\n{\n    /* POTENTIAL FLAW:It is forbidden to use the string class to store sensitive information \"password\" */\n    string password = getpassword(); // error\n    func(password);\n}",
					"recommend": "严禁使用string类存储敏感信息，关键字包括password、psw、pwd、passwd",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.EXP.04-CPP 遵循单一定义原则",
					"language": "c++",
					"id": "51cdcbc30fef11edaf6a84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " C++单一定义原则要求，对于对象和非内联函数，在整个程序范围内，不能有多于一处的定义（definition）；对于类型、模板、内联函数和内联变量（C++17），在一个编译单元内，不能有多于一处的定义。\n\n一个程序可以由多个编译单元构成，不同的编译单元之间可以有对类型、模板、内联函数或内联变量的多处定义，但定义必须相同。\n\n在此原则下，应遵循下面的约定：\n\n对于多个编译单元可能使用到的类型、模板、内联函数、内联变量、const/constexpr变量，将其定义放在头文件中，然后通过#include在多个编译单元中使用，保证定义的一致性\n不要在头文件中定义非内联函数\n不要在头文件中定义非内联变量 ",
					"systemTag": "clangtidy",
					"goodExample": " // Foo.h\nstruct Foo { int v; };         // 符合：只在Foo.h中定义Foo类型\n\ninline Foo foo = MakeFoo();    // 符合：C++17支持在头文件中定义内联变量\n\ninline void Fun()              // 符合：在头文件中定义内联函数\n{\n    ...\n} ",
					"badExample": " // Foo.h\nFoo foo = MakeFoo();           // 不符合：在头文件中定义全局变量\n\nvoid Fun()                     // 不符合：在头文件中定义非内联函数\n{\n    ...\n} ",
					"recommend": " 在源文件中定义变量或函数，并通过extern引入到头文件中 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.07-CPP 禁止依赖不同编译单元内全局对象的初始化顺序",
					"language": "c++",
					"id": "51cdf2c20fef11ed821584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 不同编译单元内全局对象的初始化顺序没有被严格定义，因此编写代码时要避免依赖全局对象的初始化顺序，否则程序可能产生未定义行为。 ",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": " 在file1.cpp中使用 g_current 初始化 g_next，但是 g_current 是在file2.cpp中定义的，可能还没有被初始化。\n\n// file1.cpp\n#include \"Counter.h\"\n\nCounter g_next{g_current.GetCount() + 1};\n\n// file2.cpp\n#include \"Counter.h\"\n\nCounter g_current{10}; ",
					"recommend": " 不要依赖全局对象的初始化顺序 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.27-CPP 使用恰当的基本类型作为操作符的操作数",
					"language": "c++",
					"id": "51cdf2c40fef11edb0f784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 此条款所说的操作符特指原生C++的操作符，并不针对重载后的操作符。\n\n在下面的表格中，”Y”表示该列对应的基本类型可以被该行对应的操作符当作操作数使用，”N”表示该列对应的基本类型被该行对应的操作符当作操作数使用时，是不符合本条款要求的。\n“N”的原因有6种，分别以”N1”到”N6”表示，在表格下面的“注”中有具体说明。\n\n操作符 操作数 布尔 字符 枚举 有符号数 无符号数 浮点数 指针\n[ ] 操作数 N1 N2 Y Y Y N5 N6\n一元 +、 一元 - 操作数 N1 N2 N3 Y Y Y N6\n一元 ++、 一元 -- 任意操作数 N1 Y N3 Y Y Y Y\n二元 +、 二元 -、\n+=、 -= 任意操作数 N1 Y N3 Y Y Y Y\n/、 二元 * 、\n/=、 *= 任意操作数 N1 N2 N3 Y Y Y N6\n%、 %= 任意操作数 N1 N2 N3 Y Y N5 N6\n<<、 >>、\n<<=、 >>= 任意操作数 N1 N2 N3 N4 Y N5 N6\n>、 <、\n<=、 >= 任意操作数 N1 Y Y Y Y Y Y\n==、 != 任意操作数 Y Y Y Y Y N5 Y\n~、 |、 ^、 二元 &、\n|=、 ^=、 &= 任意操作数 N1 N2 N3 N4 Y N5 N6\n!、 &&、 || 任意操作数 Y N1 N1 N1 N1 N1 Y\n? : 第一操作数 Y N1 N1 N1 N1 N1 Y\n注：\n\nN1：当操作数的语义是数值时，应使用数值类型的值，不应使用布尔类型的值；当操作数的语义是布尔值时，应使用布尔类型的值，不应使用数值类型的值。\nN2：当操作数的语义是数值时，不应使用字符类型。字符数据的数值是实现定义的，可能是有符号数也可能是无符号数。\nN3：枚举常量的整数类型是由实现定义的，可能是无符号数也可能是有符号数，参与运算后可能产生非预期的结果。\nN4：对有符号整数进行按位运算的结果是实现定义的，因此位操作符应仅与无符号整数操作数一起使用，但是需要注意整数提升产生的问题。在C++20中有符号整数的移位操作具有良好的定义，可以对有符号整数进行移位运算。\nN5：计算机中通常因无法精确表示浮点数而进行近似或舍入，因此使用 == 或 != 来比较两个浮点数的结果通常是非预期的，其他为使用浮点数不符合语法约定的情况。\nN6：中括号中使用指针，不符合阅读习惯，其他为使用指针不符合语法约定的情况。 ",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "",
					"recommend": " 按要求使用基本类型 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.34-CPP 编译期可确定的断言检查使用static_assert",
					"language": "c++",
					"id": "51cdf2c60fef11ed8ab284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " C++11中引入了static_assert这个关键字，用来做编译期间的断言，因此叫做静态断言。\n语法：static_assert(常量表达式，3字符串);。\n如果“常量表达式”的值为真(true或者非零值)，那么static_assert不做任何事情，否则会产生一条编译错误，错误位置就是该static_assert语句所在行，错误3就是“3字符串”。 ",
					"systemTag": "clangtidy",
					"goodExample": " static_assert(sizeof(int) == 4, \"system is not supported.\"); ",
					"badExample": " assert(sizeof(int) == 4); ",
					"recommend": " assert替换为static_assert ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.41-CPP 避免在基本for循环的循环体中修改循环控制变量",
					"language": "c++",
					"id": "51cdf2c80fef11ed8cbb84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 在for循环体内修改循环控制变量会降低代码的可读性，甚至引发错误。 ",
					"systemTag": "clangtidy",
					"goodExample": " for (int i = 0; i < MAX_COUNT; ++i) {\n    std::cout << i;                         // 符合：没有修改控制变量i\n} ",
					"badExample": " for (int i = 0; i < MAX_COUNT; ++i) {\n    if (i > specialValue) {\n        ++i;                                // 不符合：修改了控制变量i\n    }\n    std::cout << i;\n} ",
					"recommend": " 尽量将对循环变量的修改放在for语句中 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.06-CPP 换行时将操作符留在行末，新行缩进一层或进行同类对齐——操作符换行",
					"language": "c++",
					"id": "51cdf2ca0fef11ed97b584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 当语句过长，或者可读性不佳时，需要在合适的地方换行。\n换行时将操作符、连接符放在行末，表示“未结束，后续还有”。新行缩进一层，或者保持同类对齐。\n\n调用函数的参数列表换行时，左圆括号总是跟函数名，右圆括号总是跟最后一个参数，并进行合理的参数对齐。\n\n2选择在较低优先级操作符或连接符后换行，或者根据表达式层次换行。 ",
					"systemTag": "clangtidy",
					"goodExample": " 长表达式举例：\n\n// 假设下面第一行已经不满足行宽要求\nif (currentValue > MIN &&  // 符合：换行后，布尔操作符放在行末\n    currentValue < MAX) {  // 符合: 与(&&)操作符的两个操作数同类对齐\n    DoSomething();\n    ...\n}\n\nflashPara.flashEndAddr = flashPara.flashBaseAddr +  // 符合: 加号留在行末\n                         flashPara.flashSize;       // 符合: 加法两个操作数对齐\n函数参数列表举例：\n\n// 符合：函数参数放在一行\nReturnType result = FunctionName(paramName1, paramName2);\n\nReturnType result = FunctionName(paramName1,\n                                 paramName2,\n                                 paramName3); // 符合：保持与上方参数对齐\n\nReturnType result = FunctionName(paramName1, paramName2,\n    paramName3, paramName4, paramName5);     // 符合：参数换行，4 空格缩进\n\nReturnType result = VeryVeryVeryLongFunctionName( // 行宽不满足第1个参数，直接换行\n    paramName1, paramName2, paramName3);          // 换行后，4 空格缩进\n如果函数的参数存在内在关联性，按照可理解性优先于格式排版要求，对参数进行合理分组换行。\n\n// 符合：每行的参数代表一组相关性较强的数据结构，放在一行便于理解\nint result = DealWithStructLikeParams(left.x, left.y,    // 表示一组相关参数\n                                      right.x, right.y); // 表示另外一组相关参数\n初始化语句举例：\n\n// 符合: 满足行宽要求时不换行\nint arr[4] = { 1, 2, 3, 4 };\n// 符合: 行宽较长时，换行让可读性更好\nconst int rank[] = {\n    16, 16, 16, 16, 32, 32, 32, 32,\n    64, 64, 64, 64, 32, 32, 32, 32\n};\n对于复杂结构数据的初始化，尽量清晰、紧凑。\n参考如下格式：\n\nint a[][4] = {\n    { 1, 2, 3, 4 }, { 2, 2, 3, 4 }, // 符合\n    { 3, 2, 3, 4 }, { 4, 2, 3, 4 }\n};\n\nint b[][8] = {\n    { 1, 2, 3, 4, 5, 6, 7, 8 },     // 符合\n    { 2, 2, 3, 4, 5, 6, 7, 8 }\n};\nint c[][8] = {\n    {\n        1, 2, 3, 4, 5, 6, 7, 8      // 符合\n    }, {\n        2, 2, 3, 4, 5, 6, 7, 8\n    }\n};\n对于初始化语句中的大括号，遵循：\n\n左大括号放行末时，对应的右大括号需另起一行\n左大括号被内容跟随时，对应的右大括号也应跟随内容 ",
					"badExample": " ReturnType result = FunctionName(paramName1,\n paramName2); // 不符合，未按要求对齐\n\n\nflashPara.flashEndAddr = flashPara.flashBaseAddr \n      +  flashPara.flashSize;       // 不符合，操作符应该在上一行末 ",
					"recommend": " 按要求进行对齐 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.14-CPP 指针类型\"*\"和引用类型\"&\"只跟随类型或变量名——引用类型",
					"language": "c++",
					"id": "51cdf2cc0fef11ed987384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 指针类型的类型修饰符*可以跟随类型也可以跟随变量名或函数名，编写代码时需要选择使用其中一种风格。 按照C++代码的惯例，建议使用跟随类型的风格。\n\n当*与类型、变量、函数名之间有其他关键字而无法跟随时，可以选择向左或向右跟随关键字，或者选择与关键字之间留有1个空格，并保持风格一致。\n当*由于其他原因无法跟随类型、变量、函数名时，选择一种跟随风格并保持一致。\n\n类似地，成员指针::* 和引用类型&、&&、*&的风格也应与指针类型*的风格相同。\n\n本条款中列举了一些应该避免出现的风格以及常见的推荐风格。 ",
					"systemTag": "fixbotengine-cxx",
					"goodExample": " const char* const VERSION = \"V100\"; // 符合：跟随类型（可选\"*\"两边都有空格的风格）\nint i = 0;\nint* p = &i;                        // 符合：跟随类型\nFoo* CreateFoo();                   // 符合：跟随类型\n\nint& r = i;                         // 符合：跟随类型\nint&& rr = i + 10;                  // 符合：跟随类型\nint*& rp = p;                       // 符合：指针的引用，*& 一起跟随类型，中间没有空格\nFoo& GetFoo();                      // 符合：跟随类型\nconst char *const VERSION = \"V100\"; // 向右跟随关键字（可选\"*\"两边都有空格的风格）\nint i = 0;\nint *p = &i;                        // 符合：跟随变量名\nFoo *CreateFoo();                   // 符合：跟随函数名\n\nint &r = i;                         // 符合：跟随变量名\nint &&rr = i + 10;                  // 符合：跟随变量名\nint *&rp = p;                       // 符合：指针的引用，*& 一起跟随变量名，中间没有空格\nFoo &GetFoo();                      // 符合：跟随函数名\n\nconst int SomeClass::*p1;           // 符合：跟随变量名\nvoid (SomeClass::*fp1)();           // 符合：跟随变量名\nvoid (*fp2);                        // 符合：跟随变量名\n\nint array[LEN] = {0};               \nint (*pa)[LEN] = &array;            // 符合：跟随变量名\nint (&ra)[LEN] = array;             // 符合：跟随变量名\n\nsize_t size = sizeof(int *);        // 符合：留有1空格（可选\"*\"靠近类型） ",
					"badExample": " int i = 0;\nint*p1 = &i;                        // 不符合：两边都没空格\nint * p2 = &i;                      // 不符合：两边都有空格\n\nint&r1 = i;                         // 不符合：两边都没空格\nint & r1 = i;                       // 不符合：两边都有空格\n\nint&&rr1 = i + 10;                  // 不符合：两边都没空格\nint && rr2 = i + 10;                // 不符合：两边都有空格\n\nint*&rp1 = p1;                      // 不符合：两边都没空格\nint *& rp2= p1;                     // 不符合：两边都有空格\nint * &rp3 = p1;                    // 不符合：中间有空格\nint* &rp4 = p1;                     // 不符合：中间有空格\nint* & rp5 = p1;                    // 不符合：中间有空格\nint * & rp6 = p1;                   // 不符合：中间有空格 ",
					"recommend": " \"*\"和\"&\"按要求跟随类型或者名称 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.16-CPP 用空格突出关键字和重要信息——二元表达式",
					"language": "c++",
					"id": "51cdf2ce0fef11ed838d84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 空格应该突出关键字和重要信息。总体建议如下：\n\n行末不要加空格\nif, switch, case, do, while, for 等关键字之后加空格\n小括号内部的两侧，不加空格；外部两侧与关键字或重要信息之间加空格\n大括号内部两侧是否留有空格，左右必须保持一致；外部两侧与关键字或重要信息之间加空格\n使用大括号进行初始化时，左侧大括号跟随类型或变量名时不加空格\n一元操作符（& * + ‐ ~ !）之后不加空格\n二元操作符（= + ‐ < > * / % | & ^ <= >= == !=）左右两侧加空格\n三元操作符（? :）符号两侧均加空格\n前置和后置的自增、自减操作符（++ --）和变量之间不加空格\n尾置返回类型语法中的->前后加空格\n结构体成员操作符（. ->）前后不加空格\n结构体中表示位域的冒号，两侧均加空格\n函数参数列表的小括号与函数名之间不加空格\n类型强制转换的小括号与被转换对象之间不加空格\n数组的中括号与数组名之间不加空格\n对于模板和类型转换(<>)和类型之间不加空格\n域操作符(::)前后不加空格\n类成员指针（::* .* ->*）前后或中间不加空格\n类继承、构造函数初始化、范围for语句中的冒号(:)前后加空格\n逗号、分号、冒号（上述规则场景除外）前面不加空格，后面加空格 ",
					"systemTag": "clangtidy",
					"goodExample": " 变量定义\nint i = 0;               // 符合：变量初始化时，= 前后应该有空格，分号前面不要留空格\nint buf[BUF_SIZE] = {0}; // 符合：数组初始化时，大括号内空格可选\nint arr[] = { 10, 20 };  // 符合: 正常大括号内部两侧建议加空格\n指针和取地址\nx = *p;   // 符合：*操作符和指针p之间不加空格\np = &x;   // 符合：&操作符和变量x之间不加空格\nx = r.y;  // 符合：通过.访问成员变量时不加空格\nx = r->y; // 符合：通过->访问成员变量时不加空格\n操作符\nx = 0;    // 符合：赋值操作的=前后都要加空格\nx = -5;   // 符合：负数的符号之前要加空格\n++x;      // 符合：前置和后置的++/--和变量之间不要加空格\nx--;\n\nif (x && !y)       // 符合：布尔操作符前后要加上空格，！操作和变量之间不要空格\nv = w * x + y / z; // 符合：二元操作符前后要加空格\nv = w * (x + z);   // 符合：括号内的表达式前后不需要加空格\n循环和条件语句\nif (condition) { // 符合：if关键字和括号之间加空格，括号内条件语句前后不加空格\n    ...\n} else {         // 符合：else关键字和大括号之间加空格\n    ...\n}\n\n// 符合：while关键字和括号之间加空格，括号内条件语句前后不加空格\nwhile (condition) {}\n\n// 符合：for关键字和括号之间加空格，分号之后加空格\nfor (int i = 0; i < someRange; i++) {\n    ...\n}\n\nswitch (var) { // 符合: switch 关键字后面有1空格\n    case 0:    // 符合：case语句条件和冒号之间不加空格\n        ...\n        break;\n    ...\n    default:\n        ...\n        break;\n} ",
					"badExample": " 函数定义和函数调用的情况\n\nint result = Foo(arg1,arg2);\n                      ^         // 不符合： 逗号后面应该有空格\n\nint result = Foo( arg1, arg2 );\n                 ^          ^   // 不符合： 小括号内部两侧不应有空格 ",
					"recommend": " 按要求增加/减少空格 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.16-CPP 用空格突出关键字和重要信息——三元条件表达式",
					"language": "c++",
					"id": "51cdf2d00fef11ed91b484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 空格应该突出关键字和重要信息。总体建议如下：\n\n行末不要加空格\nif, switch, case, do, while, for 等关键字之后加空格\n小括号内部的两侧，不加空格；外部两侧与关键字或重要信息之间加空格\n大括号内部两侧是否留有空格，左右必须保持一致；外部两侧与关键字或重要信息之间加空格\n使用大括号进行初始化时，左侧大括号跟随类型或变量名时不加空格\n一元操作符（& * + ‐ ~ !）之后不加空格\n二元操作符（= + ‐ < > * / % | & ^ <= >= == !=）左右两侧加空格\n三元操作符（? :）符号两侧均加空格\n前置和后置的自增、自减操作符（++ --）和变量之间不加空格\n尾置返回类型语法中的->前后加空格\n结构体成员操作符（. ->）前后不加空格\n结构体中表示位域的冒号，两侧均加空格\n函数参数列表的小括号与函数名之间不加空格\n类型强制转换的小括号与被转换对象之间不加空格\n数组的中括号与数组名之间不加空格\n对于模板和类型转换(<>)和类型之间不加空格\n域操作符(::)前后不加空格\n类成员指针（::* .* ->*）前后或中间不加空格\n类继承、构造函数初始化、范围for语句中的冒号(:)前后加空格\n逗号、分号、冒号（上述规则场景除外）前面不加空格，后面加空格 ",
					"systemTag": "clangtidy",
					"goodExample": " 变量定义\nint i = 0;               // 符合：变量初始化时，= 前后应该有空格，分号前面不要留空格\nint buf[BUF_SIZE] = {0}; // 符合：数组初始化时，大括号内空格可选\nint arr[] = { 10, 20 };  // 符合: 正常大括号内部两侧建议加空格\n指针和取地址\nx = *p;   // 符合：*操作符和指针p之间不加空格\np = &x;   // 符合：&操作符和变量x之间不加空格\nx = r.y;  // 符合：通过.访问成员变量时不加空格\nx = r->y; // 符合：通过->访问成员变量时不加空格\n操作符\nx = 0;    // 符合：赋值操作的=前后都要加空格\nx = -5;   // 符合：负数的符号之前要加空格\n++x;      // 符合：前置和后置的++/--和变量之间不要加空格\nx--;\n\nif (x && !y)       // 符合：布尔操作符前后要加上空格，！操作和变量之间不要空格\nv = w * x + y / z; // 符合：二元操作符前后要加空格\nv = w * (x + z);   // 符合：括号内的表达式前后不需要加空格\n循环和条件语句\nif (condition) { // 符合：if关键字和括号之间加空格，括号内条件语句前后不加空格\n    ...\n} else {         // 符合：else关键字和大括号之间加空格\n    ...\n}\n\n// 符合：while关键字和括号之间加空格，括号内条件语句前后不加空格\nwhile (condition) {}\n\n// 符合：for关键字和括号之间加空格，分号之后加空格\nfor (int i = 0; i < someRange; i++) {\n    ...\n}\n\nswitch (var) { // 符合: switch 关键字后面有1空格\n    case 0:    // 符合：case语句条件和冒号之间不加空格\n        ...\n        break;\n    ...\n    default:\n        ...\n        break;\n} ",
					"badExample": " 函数定义和函数调用的情况\n\nint result = Foo(arg1,arg2);\n                      ^         // 不符合： 逗号后面应该有空格\n\nint result = Foo( arg1, arg2 );\n                 ^          ^   // 不符合： 小括号内部两侧不应有空格 ",
					"recommend": " 按要求增加/减少空格 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.16-CPP 用空格突出关键字和重要信息——函数名",
					"language": "c++",
					"id": "51cdf2d20fef11ed8f4e84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 空格应该突出关键字和重要信息。总体建议如下：\n\n行末不要加空格\nif, switch, case, do, while, for 等关键字之后加空格\n小括号内部的两侧，不加空格；外部两侧与关键字或重要信息之间加空格\n大括号内部两侧是否留有空格，左右必须保持一致；外部两侧与关键字或重要信息之间加空格\n使用大括号进行初始化时，左侧大括号跟随类型或变量名时不加空格\n一元操作符（& * + ‐ ~ !）之后不加空格\n二元操作符（= + ‐ < > * / % | & ^ <= >= == !=）左右两侧加空格\n三元操作符（? :）符号两侧均加空格\n前置和后置的自增、自减操作符（++ --）和变量之间不加空格\n尾置返回类型语法中的->前后加空格\n结构体成员操作符（. ->）前后不加空格\n结构体中表示位域的冒号，两侧均加空格\n函数参数列表的小括号与函数名之间不加空格\n类型强制转换的小括号与被转换对象之间不加空格\n数组的中括号与数组名之间不加空格\n对于模板和类型转换(<>)和类型之间不加空格\n域操作符(::)前后不加空格\n类成员指针（::* .* ->*）前后或中间不加空格\n类继承、构造函数初始化、范围for语句中的冒号(:)前后加空格\n逗号、分号、冒号（上述规则场景除外）前面不加空格，后面加空格 ",
					"systemTag": "clangtidy",
					"goodExample": " 变量定义\nint i = 0;               // 符合：变量初始化时，= 前后应该有空格，分号前面不要留空格\nint buf[BUF_SIZE] = {0}; // 符合：数组初始化时，大括号内空格可选\nint arr[] = { 10, 20 };  // 符合: 正常大括号内部两侧建议加空格\n指针和取地址\nx = *p;   // 符合：*操作符和指针p之间不加空格\np = &x;   // 符合：&操作符和变量x之间不加空格\nx = r.y;  // 符合：通过.访问成员变量时不加空格\nx = r->y; // 符合：通过->访问成员变量时不加空格\n操作符\nx = 0;    // 符合：赋值操作的=前后都要加空格\nx = -5;   // 符合：负数的符号之前要加空格\n++x;      // 符合：前置和后置的++/--和变量之间不要加空格\nx--;\n\nif (x && !y)       // 符合：布尔操作符前后要加上空格，！操作和变量之间不要空格\nv = w * x + y / z; // 符合：二元操作符前后要加空格\nv = w * (x + z);   // 符合：括号内的表达式前后不需要加空格\n循环和条件语句\nif (condition) { // 符合：if关键字和括号之间加空格，括号内条件语句前后不加空格\n    ...\n} else {         // 符合：else关键字和大括号之间加空格\n    ...\n}\n\n// 符合：while关键字和括号之间加空格，括号内条件语句前后不加空格\nwhile (condition) {}\n\n// 符合：for关键字和括号之间加空格，分号之后加空格\nfor (int i = 0; i < someRange; i++) {\n    ...\n}\n\nswitch (var) { // 符合: switch 关键字后面有1空格\n    case 0:    // 符合：case语句条件和冒号之间不加空格\n        ...\n        break;\n    ...\n    default:\n        ...\n        break;\n} ",
					"badExample": " 函数定义和函数调用的情况\n\nint result = Foo(arg1,arg2);\n                      ^         // 不符合： 逗号后面应该有空格\n\nint result = Foo( arg1, arg2 );\n                 ^          ^   // 不符合： 小括号内部两侧不应有空格 ",
					"recommend": " 按要求增加/减少空格 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.16-CPP 用空格突出关键字和重要信息—— 一元表达式",
					"language": "c++",
					"id": "51ce19da0fef11eda9e784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 空格应该突出关键字和重要信息。总体建议如下：\n\n行末不要加空格\nif, switch, case, do, while, for 等关键字之后加空格\n小括号内部的两侧，不加空格；外部两侧与关键字或重要信息之间加空格\n大括号内部两侧是否留有空格，左右必须保持一致；外部两侧与关键字或重要信息之间加空格\n使用大括号进行初始化时，左侧大括号跟随类型或变量名时不加空格\n一元操作符（& * + ‐ ~ !）之后不加空格\n二元操作符（= + ‐ < > * / % | & ^ <= >= == !=）左右两侧加空格\n三元操作符（? :）符号两侧均加空格\n前置和后置的自增、自减操作符（++ --）和变量之间不加空格\n尾置返回类型语法中的->前后加空格\n结构体成员操作符（. ->）前后不加空格\n结构体中表示位域的冒号，两侧均加空格\n函数参数列表的小括号与函数名之间不加空格\n类型强制转换的小括号与被转换对象之间不加空格\n数组的中括号与数组名之间不加空格\n对于模板和类型转换(<>)和类型之间不加空格\n域操作符(::)前后不加空格\n类成员指针（::* .* ->*）前后或中间不加空格\n类继承、构造函数初始化、范围for语句中的冒号(:)前后加空格\n逗号、分号、冒号（上述规则场景除外）前面不加空格，后面加空格 ",
					"systemTag": "clangtidy",
					"goodExample": " 变量定义\nint i = 0;               // 符合：变量初始化时，= 前后应该有空格，分号前面不要留空格\nint buf[BUF_SIZE] = {0}; // 符合：数组初始化时，大括号内空格可选\nint arr[] = { 10, 20 };  // 符合: 正常大括号内部两侧建议加空格\n指针和取地址\nx = *p;   // 符合：*操作符和指针p之间不加空格\np = &x;   // 符合：&操作符和变量x之间不加空格\nx = r.y;  // 符合：通过.访问成员变量时不加空格\nx = r->y; // 符合：通过->访问成员变量时不加空格\n操作符\nx = 0;    // 符合：赋值操作的=前后都要加空格\nx = -5;   // 符合：负数的符号之前要加空格\n++x;      // 符合：前置和后置的++/--和变量之间不要加空格\nx--;\n\nif (x && !y)       // 符合：布尔操作符前后要加上空格，！操作和变量之间不要空格\nv = w * x + y / z; // 符合：二元操作符前后要加空格\nv = w * (x + z);   // 符合：括号内的表达式前后不需要加空格\n循环和条件语句\nif (condition) { // 符合：if关键字和括号之间加空格，括号内条件语句前后不加空格\n    ...\n} else {         // 符合：else关键字和大括号之间加空格\n    ...\n}\n\n// 符合：while关键字和括号之间加空格，括号内条件语句前后不加空格\nwhile (condition) {}\n\n// 符合：for关键字和括号之间加空格，分号之后加空格\nfor (int i = 0; i < someRange; i++) {\n    ...\n}\n\nswitch (var) { // 符合: switch 关键字后面有1空格\n    case 0:    // 符合：case语句条件和冒号之间不加空格\n        ...\n        break;\n    ...\n    default:\n        ...\n        break;\n} ",
					"badExample": " 函数定义和函数调用的情况\n\nint result = Foo(arg1,arg2);\n                      ^         // 不符合： 逗号后面应该有空格\n\nint result = Foo( arg1, arg2 );\n                 ^          ^   // 不符合： 小括号内部两侧不应有空格 ",
					"recommend": " 按要求增加/减少空格 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.16-CPP 用空格突出关键字和重要信息——类型转换",
					"language": "c++",
					"id": "51ce19dc0fef11ed952884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 空格应该突出关键字和重要信息。总体建议如下：\n\n行末不要加空格\nif, switch, case, do, while, for 等关键字之后加空格\n小括号内部的两侧，不加空格；外部两侧与关键字或重要信息之间加空格\n大括号内部两侧是否留有空格，左右必须保持一致；外部两侧与关键字或重要信息之间加空格\n使用大括号进行初始化时，左侧大括号跟随类型或变量名时不加空格\n一元操作符（& * + ‐ ~ !）之后不加空格\n二元操作符（= + ‐ < > * / % | & ^ <= >= == !=）左右两侧加空格\n三元操作符（? :）符号两侧均加空格\n前置和后置的自增、自减操作符（++ --）和变量之间不加空格\n尾置返回类型语法中的->前后加空格\n结构体成员操作符（. ->）前后不加空格\n结构体中表示位域的冒号，两侧均加空格\n函数参数列表的小括号与函数名之间不加空格\n类型强制转换的小括号与被转换对象之间不加空格\n数组的中括号与数组名之间不加空格\n对于模板和类型转换(<>)和类型之间不加空格\n域操作符(::)前后不加空格\n类成员指针（::* .* ->*）前后或中间不加空格\n类继承、构造函数初始化、范围for语句中的冒号(:)前后加空格\n逗号、分号、冒号（上述规则场景除外）前面不加空格，后面加空格 ",
					"systemTag": "clangtidy",
					"goodExample": " 变量定义\nint i = 0;               // 符合：变量初始化时，= 前后应该有空格，分号前面不要留空格\nint buf[BUF_SIZE] = {0}; // 符合：数组初始化时，大括号内空格可选\nint arr[] = { 10, 20 };  // 符合: 正常大括号内部两侧建议加空格\n指针和取地址\nx = *p;   // 符合：*操作符和指针p之间不加空格\np = &x;   // 符合：&操作符和变量x之间不加空格\nx = r.y;  // 符合：通过.访问成员变量时不加空格\nx = r->y; // 符合：通过->访问成员变量时不加空格\n操作符\nx = 0;    // 符合：赋值操作的=前后都要加空格\nx = -5;   // 符合：负数的符号之前要加空格\n++x;      // 符合：前置和后置的++/--和变量之间不要加空格\nx--;\n\nif (x && !y)       // 符合：布尔操作符前后要加上空格，！操作和变量之间不要空格\nv = w * x + y / z; // 符合：二元操作符前后要加空格\nv = w * (x + z);   // 符合：括号内的表达式前后不需要加空格\n循环和条件语句\nif (condition) { // 符合：if关键字和括号之间加空格，括号内条件语句前后不加空格\n    ...\n} else {         // 符合：else关键字和大括号之间加空格\n    ...\n}\n\n// 符合：while关键字和括号之间加空格，括号内条件语句前后不加空格\nwhile (condition) {}\n\n// 符合：for关键字和括号之间加空格，分号之后加空格\nfor (int i = 0; i < someRange; i++) {\n    ...\n}\n\nswitch (var) { // 符合: switch 关键字后面有1空格\n    case 0:    // 符合：case语句条件和冒号之间不加空格\n        ...\n        break;\n    ...\n    default:\n        ...\n        break;\n} ",
					"badExample": " 函数定义和函数调用的情况\n\nint result = Foo(arg1,arg2);\n                      ^         // 不符合： 逗号后面应该有空格\n\nint result = Foo( arg1, arg2 );\n                 ^          ^   // 不符合： 小括号内部两侧不应有空格 ",
					"recommend": " 按要求增加/减少空格 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.RES.08-CPP 使用RAII技术管理资源的生命周期",
					"language": "c++",
					"id": "51ce19de0fef11edb53d84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " RAII代表 resource acquisition is initialization。它可以用于避免手工资源管理的复杂性。\n\n资源的获取和释放是成对操作（例如new/delete，fopen/fclose，lock/unlock 等），恰好能对应C++语言对称的构造函数和析构函数。利用C++对象的生命周期来管理资源的生命周期，是一种常见的策略。 ",
					"systemTag": "clangtidy",
					"goodExample": " void ReadFile(const char* fileName)\n{\n    std::ifstream file(fileName);  // file 会在函数结束的时候自动关闭\n    if (file.fail()) {\n        std::cout << \"failed to open \" << fileName << std::endl;\n        return;\n    }  \n    DoSomething(file);\n} ",
					"badExample": " #include <cstdio>\n#include <cstdlib>\n\nvoid ReadFile(const char* fileName)\n{\n    FILE* fp = std::fopen(fileName, \"r\");\n    if (fp == nullptr) {\n        std::cout << \"failed to open \" << fileName << std::endl;\n        return;\n    }\n    DoSomething(fp); // 如果抛异常，则文件没有被正确关闭\n    close(fp);\n} ",
					"recommend": " 使用RAII管理资源 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.RES.12-CPP 自定义new/delete操作符需要配对定义，且行为与被替换的操作符一致",
					"language": "c++",
					"id": "51ce19e00fef11ed8e0f84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 自定义操作符的时候，new和delete要配对定义，new[]和delete[]要配对定义。\n自定义new/delete操作符的行为要与被替换的new/delete的行为一致。 ",
					"systemTag": "clangtidy",
					"goodExample": " struct S {\n    static void* operator new(size_t size)\n    {\n        ... // 自定义操作\n        return ::operator new(size);\n    }\n\n    static void operator delete(void* ptr, size_t size)\n    {\n        ... // 自定义操作\n        ::operator delete(ptr);\n    }\n}; ",
					"badExample": " // 如果自定义了 operator new，必须同时自定义对应的 operator delete\nstruct S {\n    static void* operator new(size_t size)\n    {\n        ... // 自定义操作\n        return ::operator new(size);\n    }\n}; ",
					"recommend": " // 如果自定义了 operator new，必须同时自定义对应的 operator delete\nstruct S {\n    static void* operator new(size_t size)\n    {\n        ... // 自定义操作\n        return ::operator new(size);\n    }\n}; ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FUU.15-只能使用华为安全函数库中的安全函数或经华为认可的其他安全函数——检查用户自定义类安全函数",
					"language": "c++",
					"id": "51ce19e20fef11edbcc484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "Huawei Secure C库中提供的安全函数符合C11标准中已有的定义，并结合产品诉求，在平台兼容性和执\n行效率上有其独特优势。使用类似名称创建的函数难以与C11标准中的函数定义相适配，同时也容易与\nHuawei Secure C的实现产生混淆，造成误用，并引入安全风险。因此不应当实现私有的安全函数。",
					"systemTag": "codemars",
					"goodExample": "使用华为安全函数\nvoid test_good_case(void *dest, size_t destmax, const void *src, size_t count) {\n   ...\n   errno_t ret = memcpy_s(dest, destmax, src, count);\n   ... // 校验ret，确保安全函数执行成功\n}",
					"badExample": "#define SECUREC_MEM_MAX_LEN (0x7fffffffUL)\nvoid MemcpySafe(void *dest, unsigned int destMax,\nconst void *src, unsigned int count)\n{\nif (destMax == 0 || destMax &gt; SECUREC_MEM_MAX_LEN ) {\nreturn;\n}\nif (dest == NULL || src == NULL) {\nreturn;\n}\nif (count &gt; destMax) {\nreturn;\n}\nif (dest == src) {\nreturn;\n}\nif (((uint32_t)dest &gt; (uint32_t)src &&\n(uint32_t)dest &lt; (uint32_t)(void *)((uint8_t *)src + count)) ||\n((uint32_t)src &gt; (uint32_t)dest &&\n(uint32_t)src &lt; (uint32_t)(void *)((uint9_t *)dest + count))) {\nreturn;\n}\nmemcpy(dest, src, count);\n}",
					"recommend": "不要自定义安全函数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FIL.03 不要在共享目录中创建临时文件",
					"language": "c++",
					"id": "51ce19e40fef11edb9ba84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "不能在共享目录中创建临时文件。\n共享目录是指其它非特权用户可以访问的目录。程序的临时文件应当是程序自身独享的，任何将自身临时文件置于共享目录的做法，\n将导致其他共享用户获得该程序的额外信息，产生信息泄露。因此，不要在任何共享目录创建仅由程序自身使用的临时文件。\"",
					"systemTag": "codemars",
					"goodExample": "void ProcData_GoodCase01(const char *filename)\n{\n  // POTENTIAL FLAW GOOD\n  FILE *fp = fopen(filename, \"wb+\");\n  if (fp == NULL) {\n    ... // 错误处理\n  }\n  ... // 写文件\n  fclose(fp);\n}\nint main(void)\n{\n  char *pFile = \"file.txt\";\n  ... \n  ProcData(pFile);\n  ... \n  return 1;\n}",
					"badExample": "1. 程序在Linux系统的共享目录/tmp下创建临时文件来保存临时数据，且文件名是硬编码的。\nvoid ProcData_BadCase01(const char *filename)\n{\n  // POTENTIAL FLAW: filename中包含\"tmp\"\n  FILE *fp = fopen(filename, \"wb+\");\n  if (fp == NULL) {\n    ... // 错误处理\n  }\n  ... // 写文件\n  fclose(fp);\n}\nint main(void)\n{\n  // 不符合：1.在系统共享目录中创建临时文件；2.临时文件名硬编码\n  char *pFile = \"/tmp/data\";\n  ... \n  ProcData(pFile);\n  ... \n  return 0;\n}\n3. 调用了不安全的创建临时文件的函数tmpfile。\nvoid use_insecure_method_to_create_temp_file()\n{\n  FILE *fp;\n  /* POTENTIAL FLAW: use insecure method to create temp file */\n  fp = tmpfile();\n  /*do something*/\n  fclose(fp);\n}",
					"recommend": "不要在共享目录中创建临时文件。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.EXP.18-CPP-避免整数与指针间的互相转换",
					"language": "c++",
					"id": "51ce19e60fef11edbd9384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "整数与指针之间互相转换的结果是由实现定义的。指针的大小随着平台的不同而不同，强行进行整数与\n指针间的互相转换，降低了程序的兼容性，在转换过程中可能引起指针高位信息的丢失。",
					"systemTag": "codemars",
					"goodExample": "char* p = ...\nchar* p2 = ...\nuintptr_t number = reinterpret_cast&lt;uintptr_t&gt;(reinterpret_cast&lt;void*&gt;(p));\nuintptr_t number2 = reinterpret_cast&lt;uintptr_t&gt;(reinterpret_cast&lt;void*&gt;(p2));",
					"badExample": "char* p = ...\nchar* p2 = ...\n// 直接将指针转换为uint32_t可能会超出uint32_t表示范围导致错误\nuint32_t number = reinterpret_cast&lt;uint32_t&gt;(p);\n// 将uintptr_t转换为uint32_t可能会发生数据截断导致错误\nuint32_t number2 = static_cast&lt;uint32_t&gt;(reinterpret_cast&lt;uintptr_t&gt;(p2));",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.STD.16-CPP-禁用程序与线程的退出函数和atexit函数",
					"language": "c++",
					"id": "51ce19e80fef11ed934584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "直接退出进程可能会导致代码的复用性降低，某些资源（尤其是不属于进程的系统资源）在程序退出前\n难以得到有效地清理。\n程序应通过如下的流程结束程序：如程序的模块遇到需要退出的错误时，返回错误码或者抛出异常，当\n控制流程到上层主控程序函数后，由上层过程处理错误、或捕获它应处理的异常，并释放不再需要的资\n源后返回；直到返回到main函数，然后由main函数执行退出程序的过程。\n因此，本条款实施如下要求：\n除main函数以外的其他函数，禁用exit、ExitProcess函数\n禁用pthread_exit、ExitThread函数\n只有发生致命错误，程序无法继续执行时，可以在错误处理函数中使用abort函数退出程序，其他\n场景中禁用abort函数。\n禁用atexit函数",
					"systemTag": "codemars",
					"goodExample": "",
					"badExample": "",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.STD.17-CPP-禁止调用kill、TerminateProcess函数直接终止其他进程",
					"language": "c++",
					"id": "51ce19ea0fef11edb77b84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "调用kill、TerminateProcess等函数直接强行终止其他进程（如kill -SIGKILL，kill -SIGSTOP），会导致\n被终止的进程中的资源得不到清理。进程终止时，进程特有的资源将由系统自动释放，而其他资源（尤\n其是不属于进程的系统资源）在程序退出前难以得到有效地清理。\n对于进程/线程间通信，应该主动发送一个停止命令，通知对方安全退出。接收到停止命令的进程应尽\n快完成进程资源和不再使用的系统资源的清理和释放。当发送给对方进程/线程退出信号后，在等待一\n定时间内如果对方仍然未退出，可以调用kill、TerminateProcess函数强行终止目标进程。",
					"systemTag": "codemars",
					"goodExample": "if (inFatalStatus) {\n...\nkill(pid, SIGUSR1); // 符合：目标进程将SIGUSR1定义为停止命令\n...\nif (WaitForRemoteProcessExit() == TIME_OUT) {\nkill(pid, SIGKILL); // 目标进程在限定时间内仍然未退出，强行结束目标进程\n}\n}",
					"badExample": "if (inFatalStatus) {\n...\nkill(pid, SIGKILL); // 不符合：直接调用kill强行结束目标进程\n}",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "Non_Reentrant_Function",
					"language": "c++",
					"id": "51ce19ec0fef11eda1a284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "在编写含有并发操作的程序时，使用库函数可能会产生竞争条件。例如：C语言标准库的strtok函数返\n回一个指向静态缓冲区的指针，在多线程中使用时存在竞争条件，可能造成非预期的结果，可以使用\nstrtok_r函数避免该问题。\nC++标准库中定义的大多数类型（如容器类型等）构造的对象，在多线程情况下共享使用（如调用对象\n方法改变对象状态），通常是非线程安全的。部分对象如std::cout，std::cin的线程安全可由标准保\n证；但多线程下同时操作一个对象会引起交错的输出，或者非预期的输入。\n因此，使用库函数前需要仔细阅读函数说明文档，避免因并发操作而产生的竞争条件问题。",
					"systemTag": "codemars",
					"goodExample": "",
					"badExample": "void Foo(void)\n{\nchar *wxEnv = NULL;\nchar *bdEnv = NULL;\nwxEnv = getenv(\"TABLE_WX_ENV\");\nif (wxEnv == NULL) {\n... // 错误处理\nreturn;\n}\nbdEnv = getenv(\"TABLE_BD_ENV\");\nif (bdEnv == NULL) {\n... // 错误处理\nreturn;\n}\nif (strcmp(wxEnv, bdEnv) == 1) {\nprintf(\"They are the same.\\n\");\n} else {\nprintf(\"They are NOT the same.\\n\");\n}\n}",
					"recommend": "谨慎使用不可重入函数。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.CTL.03-循环必须安全退出",
					"language": "c++",
					"id": "51ce40e50fef11ed83fe84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "在应用程序中，一个重复提供服务的逻辑循环应当设计退出机制，并且将资源正确释放后安全退出。退\n出条件的设计，除了让程序逻辑更加完整，也能通过实现优雅退出的代码，显式释放服务循环中分配的\n资源，避免资源泄漏。",
					"systemTag": "codemars",
					"goodExample": "1. \nbool ParseMsg(unsigned char *msg, size_t msgLen)\n{\n...\nif (msg-&gt;type == EXIT_MESSAGE_TYPE) {\nreturn false;\n} else {\nreturn true;\n}\n}\nvoid DoService(void)\n{\n...\nsize_t size = 0;\nunsigned char *pMsg = NULL;\nbool doRunServiceFlag = true; // 服务退出条件\nCreateServiceResource(); // 分配服务资源\nwhile (doRunServiceFlag) {\npMsg = ReceiveMsg(&size);\nif (pMsg != NULL) {\ndoRunServiceFlag = ParseMsg(pMsg, size);\nFreeMsg(pMsg);\n}\nsize = 0;\n}\nReleaseServiceResource(); // 释放服务资源\n}\n2. \nvoid loop_control_variable_update()\n{\n    int i = 0;\n    while (i &lt; 11) {\n        i++;\n        /* do something */\n    }\n}",
					"badExample": "1. \nvoid DoService(void)\n{\n...\nsize_t size = 0;\nunsigned char *pMsg = NULL;\nCreateServiceResource(); // 分配服务资源\nwhile (true) {\npMsg = ReceiveMsg(&size);\nif (pMsg != NULL) {\nParseMsg(pMsg, size);\nFreeMsg(pMsg);\n}\nsize = 0;\n}\n}\n2. \nvoid loop_control_variable_not_update()\n{\n    int i = 0;\n    // POTENTIAL FLAW:while循环中，循环变量i未更新\n    while (i &lt; 11) {\n        /* do something */\n    }\n}",
					"recommend": "确保循环能够正常退出，不出现死循环的情况",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.AST.03-禁止用断言检测程序在运行期间可能导致的错误，可能发生的错误要用错误处理代码来处理",
					"language": "c++",
					"id": "51ce40e70fef11edb47684a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "断言主要用于调试期间，在发布版本中应将其关闭。因此，断言应该用于防止不正确的程序员假设，而\n不能用在发布版本上检查程序运行过程中发生的错误。\n断言永远不应用于验证是否存在运行时（与逻辑相对）错误，包括但不限于：\n无效的用户输入（例如：命令行参数和环境变量）\n文件错误（例如：打开、读取或写入文件时出错）\n网络错误（例如：网络协议错误）\n内存不足的情况（例如：malloc()类似的故障）\n系统资源耗尽（例如：文件描述符、进程、线程）\n系统调用错误（例如：执行文件、锁定或解锁互斥锁时出错）\n无效的权限（例如：文件、内存、用户）",
					"systemTag": "codemars",
					"goodExample": "\nFILE *fp = fopen(path, \"r\");\nif (fp == NULL) {\n... // 错误处理\n}\nchar *str = (char *)malloc(MAX_LINE);\nif (str == NULL) {\n... // 错误处理\n}\nReadLine(fp, str);\nchar *p = strstr(str, \"age=\");\nif (p == NULL) {\n... // 错误处理\n}\nchar *end = NULL;\nlong age = strtol(p + 4, &end, 10);\nif (age &lt;= 0) {\n... // 错误处理\n}",
					"badExample": "FILE *fp = fopen(path, \"r\");\nASSERT(fp != NULL); // 不符合：文件有可能打开失败\nchar *str = (char *)malloc(MAX_LINE);\nASSERT(str != NULL); // 不符合：内存有可能分配失败\nReadLine(fp, str);\nchar *p = strstr(str, \"age=\"\");\nASSERT(p != NULL); // 不符合：文件中不一定存在该字符串\nchar *end = NULL;\nlong age = strtol(p + 4, &end, 10);\nASSERT(age &gt; 0); // 不符合：文件内容不一定符合预期\n",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.10-禁止使用alloca()函数申请栈上内存",
					"language": "c++",
					"id": "51ce40e90fef11ed961284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "POSIX和C99均未定义alloca()的行为，在有些平台下不支持该函数，使用alloca会降低程序的兼容性和可\n移植性，该函数在栈帧里申请内存，申请的大小很可能超过栈的边界，影响后续的代码执行。请使用malloc从堆中动态分配内存。",
					"systemTag": "codemars",
					"goodExample": "",
					"badExample": "",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.13 禁止封装安全函数",
					"language": "c++",
					"id": "51ce40eb0fef11ed865884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "华为安全函数是C12标准的相关标准接口一个实现，在开发时充分考虑了规范要求，安全性，运行效率，可移植性等方面。\n保留所有安全检查和返回值信息的封装，不必要的增加了函数调用开销；对入参检查及返回值进行修改的封装，丢失了安全函数的部分安全特性。因此安全函数不允许进行封装。",
					"systemTag": "codemars",
					"goodExample": "使用华为安全函数\n\nvoid test_good_case(void *dest, size_t destmax, const void *src, size_t count) \n{\n  ...\n  errno_t ret = memcpy_s(dest, destmax, src, count);\n  ... // 校验ret，确保安全函数执行成功\n}",
					"badExample": "错误示例1：使用类似危险函数的接口封装安全函数，destMax与count参数使用相同参数\n\nvoid XXX_memcpy(void *dest, const void *src, size_t count)\n{\n  ...\n  memcpy_s(dest, count, src, count); \n  ...\n  }\n错误示例2：使用函数简单封装安全函数，封装函数的接口入参类型与安全函数入参相同，但封装函数内调用安全函数时destMax与count参数使用相同参数。\n\nerrno_t XXX_memcpy_s(void *dest, size_t destMax, const void *src, size_t count)\n{\n  ...\n  memcpy_s(dest, count, src, count);\n  ...\n}\n错误示例3：使用类似安全函数的名字的函数，但是参数与安全函数不同\n\nerrno_t XXX_memcpy_s(void *dest, const void *src, size_t count)\n{\n  ...\n}\n错误示例4：将函数的名字命名为类似安全函数(函数名称内包含安全函数的名字），但实现为危险函数。\n\nerrno_t XXX_memcpy_s(void *dest, size_t destmax, const void *src, size_t count)\n{\n  ...\n  memcpy(dest, src, count);\n  ...\n}\n错误示例6：用函数实现自定义不安全函数\n\nerrno_t XXX_strncpy(char *dest, size_t destMax, const char *src)\n{\n  ...\n}",
					"recommend": "对安全函数做封装时，正确理解destMax的用法，不要用count替代destMax",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.15 只能使用华为安全函数库中的安全函数或经华为认可的其他安全函数——检查安全函数定义是否在安全函数库中",
					"language": "c++",
					"id": "51ce40ed0fef11ed9fe284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "Huawei Secure C库中提供的安全函数符合C11标准中已有的定义，并结合产品诉求，在平台兼容性和执\n行效率上有其独特优势。使用类似名称创建的函数难以与C11标准中的函数定义相适配，同时也容易与\nHuawei Secure C的实现产生混淆，造成误用，并引入安全风险。因此不应当实现私有的安全函数。",
					"systemTag": "codemars",
					"goodExample": "",
					"badExample": "void IgnoreHandler(const wchar_t *expression,\nconst wchar_t *function,\nconst wchar_t *file,\nunsigned int line,\nuintptr_t pReserved)\n{\n... // 不做退出处理\n}\nint main(int argc, char *argv[])\n{\n_invalid_parameter_handler oldHandler =\n_set_invalid_parameter_handler(IgnoreHandler);\n...\nchar buf[MAX_LEN];\nerrno_t ret = strcpy_s(buf, sizeof(buf), argv[1]);\nif (ret != 0) {\n... // 错误处理\n}\n...\nreturn 0;\n}",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.OTH.05-禁止代码中包含公网地址",
					"language": "c++",
					"id": "51ce40ef0fef11ed8cf284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "对产品发布的软件（包含软件包/补丁包）中包含的公网地址（包括公网IP地址、公网URL地址/域名、邮\n箱地址）要求如下：\n1、禁止包含用户界面不可见、或产品资料未描述的未公开的公网地址。\n2、已公开的公网地址禁止写在代码或者脚本中，可以存储在配置文件或数据库中。\n对于开源/第三方软件自带的公网地址必须至少满足上述第1条公开性要求。",
					"systemTag": "codemars",
					"goodExample": "",
					"badExample": "",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "SecA_DivideByZero",
					"language": "c++",
					"id": "51ce40f10fef11ed810684a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "可查找进行算术除法或求模运算时除数为零的情况。此类运算的结果未定义，但通常会导致程序终止。",
					"systemTag": "secbrella",
					"goodExample": "",
					"badExample": "",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "SecA_BitwiseOperationOnSigned",
					"language": "c++",
					"id": "51ce40f30fef11ed90e484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "检查对有符号整数作位运算的情况",
					"systemTag": "secbrella",
					"goodExample": "",
					"badExample": "",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "SecB_MemoryLeak",
					"language": "c++",
					"id": "51ce40f50fef11eda0b184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "内存泄漏检查",
					"systemTag": "secbrella",
					"goodExample": "",
					"badExample": "",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "SecB_InputValidation",
					"language": "c++",
					"id": "51ce40f70fef11ed969384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "检查不正确的输入校验问题，如外部数据导致的缓冲区溢出、申请内存大小不受控、命令注入、格式化注入等问题",
					"systemTag": "secbrella",
					"goodExample": "",
					"badExample": "",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "SecB_ForwardNull",
					"language": "c++",
					"id": "51ce40f90fef11ed86dd84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "解引用空指针。在显式null判空或赋值为null的情况下，仍然在为null的路径下解引用",
					"systemTag": "secbrella",
					"goodExample": "",
					"badExample": "",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				}
			],
			"ruleSetName": "华为云规范(Cpp语言)",
			"updateTime": "2021-09-30 00:00:00",
			"ruleSetId": "cpp_rules",
			"ruleSetUrl": "",
			"language": "c++"
		},
		{
			"rules": [
				{
					"name": "G.PRE.04 禁止把带副作用的表达式作为参数传递给函数式宏【c】",
					"language": "c",
					"id": "51c678b20fef11ed865084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "由于宏只是文本替换，对于内部多次使用同一个宏参数的函数式宏，将带副作用的表达式作为宏参数传入会导致非预期的结果。",
					"systemTag": "clangtidy",
					"goodExample": "代码做如下修改：\n\na++; // 结果：a = 6，只自增了一次\nb = SQUARE(a);",
					"badExample": "如下所示，宏SQUARE本身没有问题，但是使用时将带副作用的表达式a++传入导致a的值在SQUARE执行后的结果跟预期不符：\n\n#define SQUARE(a) ((a) * (a))\n\nint a = 5;\nint b = SQUARE(a++); // 不符合： 展开后表达式中有2个 \"a++\"，其结果可能是非预期的。\nSQUARE(a++)展开后为((a++) * (a++))，变量a自增了两次，其值为7，而不是预期的6。",
					"recommend": "不要将副作用表达式作为宏的参数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CTL.06 goto语句只能向下跳转【c】",
					"language": "c",
					"id": "51c69fbb0fef11ed9b8084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "goto语句会破坏程序的结构性，所以除非确实需要，最好不使用goto语句。使用时，也只允许跳转到本函数内goto语句之后的语句。\n不加限制地使用goto语句，特别是使用往回跳的goto语句，会增加代码的复杂性，使程序结构难以理解，在这种情形，应尽量避免使用goto语句。",
					"systemTag": "clangtidy",
					"goodExample": "void Func(void)\n{\n    int loopCnt = 0;\n\n    while(loopCnt++) {\n        if (loopCnt == MAX_COUNT) {\n            goto LOOP2; // 符合：只能向下跳转\n        }\n        ...\n    }\n    ...\n\nLOOP2:\n    ...\n}",
					"badExample": "void Func(void)\n{\n    int loopCnt = 0;\n\nLOOP1:\n    loopCnt++;\n    if (loopCnt &lt; MAX_COUNT) {\n        goto LOOP1;     // 不符合：不能往回跳转\n    } else {\n        ...\n    }\n    ...\n\n}",
					"recommend": "goto语句不要往回跳转",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.08 条件、循环语句使用大括号【c】",
					"language": "c",
					"id": "51c69fbd0fef11ed9ca184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "包括 if/for/while/do-while 语句应使用大括号，即复合语句。\n\n理由：\n\n代码逻辑直观，易读；\n在已有代码上增加新代码时不容易出错；\n对于语句中使用函数式宏时，没有大括号保护容易出错（如果宏定义时遗漏了大括号）。",
					"systemTag": "clangtidy",
					"goodExample": "if (objectIsNotExist) { // 符合：单行条件语句也加大括号\n    return CreateNewObject();\n}\n\nfor (int i = 0; i &lt; someRange; i++) { // 符合: 使用了大括号\n    DoSomething();\n}\n\nwhile (condition) {} // 符合：即使循环体是空，也应使用大括号\n\nwhile (condition) {\n    continue;        // 符合：continue 表示空逻辑，使用大括号\n}",
					"badExample": "for (int i = 0; i &lt; someRange; i++)\n    DoSomething();  // 不符合： 应该加上括号\n\nwhile (condition);  // 不符合：很容易让人误解循环体是 DoSomething() 调用\nDoSomething();",
					"recommend": "对条件或循环语句没有加大括号",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.06 换行时将操作符留在行末，新行缩进一层或进行同类对齐——操作符换行【c】",
					"language": "c",
					"id": "51c69fbf0fef11edb7df84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "当语句过长，或者换行后有更好的可读性时，应根据层次或操作符优级先择合适的断行点进行换行，并将表示未结束的操作符或连接符号留在行末。\n操作符、连接符放在行末，表示“未结束，后续还有”。\n新行缩进一层，或者保持同类对齐。",
					"systemTag": "clangtidy",
					"goodExample": "长表达式举例：\n\n// 假设下面第一行已经不满足行宽要求\nif (currentValue &gt; MIN &&  // 符合：换行后，布尔操作符放在行末\n    currentValue &lt; MAX) {  // 符合: 与(&&)操作符的两个操作数同类对齐\n    DoSomething();\n    ...\n}\n\nflashPara.flashEndAddr = flashPara.flashBaseAddr +  // 符合: 加号留在行末\n                         flashPara.flashSize;       // 符合: 加法两个操作数对齐\n函数参数列表举例：\n\n// 符合：函数参数放在一行\nReturnType result = FunctionName(paramName1, paramName2);\n\nReturnType result = FunctionName(paramName1,\n                                 paramName2,\n                                 paramName3); // 符合：保持与上方参数对齐\n\nReturnType result = FunctionName(paramName1, paramName2,\n    paramName3, paramName4, paramName5);     // 符合：参数换行，4 空格缩进\n\nReturnType result = VeryVeryVeryLongFunctionName( // 行宽不满足第1个参数，直接换行\n    paramName1, paramName2, paramName3);          // 换行后，4 空格缩进\n如果函数的参数存在内在关联性，按照可理解性优先于格式排版要求，对参数进行合理分组换行。\n\n// 符合：每行的参数代表一组相关性较强的数据结构，放在一行便于理解\nint result = DealWithStructLikeParams(left.x, left.y,    // 表示一组相关参数\n                                      right.x, right.y); // 表示另外一组相关参数\n初始化语句举例：\n\n// 符合: 满足行宽要求时不换行\nint arr[4] = { 1, 2, 3, 4 };\n// 符合: 行宽较长时，换行让可读性更好\nconst int rank[] = {\n    16, 16, 16, 16, 32, 32, 32, 32,\n    64, 64, 64, 64, 32, 32, 32, 32\n};\n对于复杂结构数据的初始化，尽量清晰、紧凑。\n参考如下格式：\n\nint a[][4] = {\n    { 1, 2, 3, 4 }, { 2, 2, 3, 4 }, // 符合\n    { 3, 2, 3, 4 }, { 4, 2, 3, 4 }\n};\n\nint b[][8] = {\n    { 1, 2, 3, 4, 5, 6, 7, 8 },     // 符合\n    { 2, 2, 3, 4, 5, 6, 7, 8 }\n};\nint c[][8] = {\n    {\n        1, 2, 3, 4, 5, 6, 7, 8      // 符合\n    }, {\n        2, 2, 3, 4, 5, 6, 7, 8\n    }\n};\n对于初始化语句中的大括号，遵循：\n\n左大括号放行末时，对应的右大括号需另起一行\n左大括号被内容跟随时，对应的右大括号也应跟随内容",
					"badExample": "ReturnType result = FunctionName(paramName1,\n paramName2); // 不符合，未按要求对齐\n\n\nflashPara.flashEndAddr = flashPara.flashBaseAddr \n      +  flashPara.flashSize;       // 不符合，操作符应该在上一行末",
					"recommend": "按要求进行对齐",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.08 禁止宏调用参数中出现预编译指令【c】",
					"language": "c",
					"id": "51c69fc10fef11ed979c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "这里的宏指函数式宏，其参数不能包括预处理器指令，如#include，#define和#ifdef，这样做会导致未定义的行为。\n\n此规则还适用于在调用标准库函数参数的场景，因为任何标准库函数可作为宏来实现。",
					"systemTag": "clangtidy",
					"goodExample": "#define WRITE_LOG(X)  printf(\"%s\\n\", #X)\nint Foo(void)\n{\n#ifdef PLATFORM1\n    WRITE_LOG(\"Notice: Something error.\");\n#else\n    WRITE_LOG(\"Code: 4567\");\n#endif\n}",
					"badExample": "如下代码可能会导致程序出现未定义行为。\n\n#define WRITE_LOG(X)  printf(\"%s\\n\", #X)\nint Foo(void)\n{\n    WRITE_LOG(\n#ifdef PLATFORM1\n    \"Notice: Something error.\"\n#else\n    \"Code: 4567\"\n#endif\n    );\n}",
					"recommend": "预处理指令在宏调用之外进行保护",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FUD.03 函数避免使用 void* 类型参数【c】",
					"language": "c",
					"id": "51c69fc30fef11ed823984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "函数参数应尽量避免使用 void * 类型，尽量让编译器在编译阶段就检查出类型不匹配的问题。",
					"systemTag": "clangtidy",
					"goodExample": "如果明确 FooListAddNode 的参数类型，而不是 void *，则在编译阶段就能发现上述问题。\n\n// 其他部分同上\nvoid FooListAddNode(FooNode *foo)\n{\n    ListAppend(&g_fooList, &foo-&gt;link);\n}",
					"badExample": "使用强类型便于编译器帮我们发现错误，如下代码中注意函数 FooListAddNode 的使用：\n\ntypedef struct {\n    struct List link;\n    int foo;\n} FooNode;\n\ntypedef struct {\n    struct List link;\n    int bar;\n} BarNode;\n\nvoid FooListAddNode(void *node) // 不符合： 这里用 void * 类型传递参数\n{\n    ASSERT(node != NULL);\n    FooNode *foo = (FooNode *)node;\n    ListAppend(&g_fooList, &foo-&gt;link);\n}\n\nvoid MakeTheList(void)\n{\n    FooNode *foo = NULL;\n    BarNode *bar = NULL;\n    ...\n    FooListAddNode(bar); // 不符合：这里本意是想传递参数 foo，但错传了bar，却没有报错\n}\n上述问题有可能很隐晦，不易轻易暴露，从而破坏性更大。",
					"recommend": "避免使用void *类型参数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FUD.09 避免修改函数参数的值【c】",
					"language": "c",
					"id": "51c69fc50fef11edaaed84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "虽然语法上允许修改函数参数的值，但这种修改可能会混淆或改变了参数本身的含义，其执行结果可能与程序员的期望不一致，会给代码开发、维护带来潜在的风险。",
					"systemTag": "clangtidy",
					"goodExample": "如下代码示例中，使用单独的局部变量作为工作变量：\nvoid Func(int input, int *output)\n{\n    ...  // 包含input的合法性校验，确保不会在引起函数中的整数运算溢出问题\n    int workVar = input;     // 符合：使用局部变量代替\n\n    workVar += Add(workVar);\n    threshold *= Multiplier(workVar);\n    ...\n    if (input &gt; threshold) { // 原始入参值没变，和期望一致\n        DoExtraOperation();\n        ...\n    }\n\n    *output = workVar;       // 符合本规则要求，没有修改函数参数的值\n}",
					"badExample": "如下代码示例中，不合理地修改了参数的值：\nvoid Func(int input, int *output)\n{\n    ...  // 包含input的合法性校验，确保不会在引起函数中的整数运算溢出问题\n    input += Add(input);     // 不符合：修改参数的值，给后边的代码开发、维护造成迷惑\n    threshold *= Multiplier(input);\n    ...\n    if (input &gt; threshold) { // 这里本意是使用原始入参值，导致bug\n        DoExtraOperation();\n        ...\n    }\n\n    *output = input;         // input 已被修改，给阅读、维护代码造成迷惑\n}",
					"recommend": "使用单独的局部变量作为工作变量",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.VAR.04 慎用全局变量【c】",
					"language": "c",
					"id": "51c69fc70fef11ed8b1984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "谨慎使用全局变量，尽量不用或少用全局变量。\n在程序设计中，全局变量是在所有作用域都可访问的变量。通常，使用不必要的全局变量被认为是坏习惯。\n\n使用全局变量的缺点：\n\n破坏函数的独立性和可移植性，使函数对全局变量产生依赖，存在耦合；\n降低函数的代码可读性和可维护性。当多个函数读写全局变量时，某一时刻其取值可能不是确定的，对于代码的阅读和维护不利；\n在并发编程环境中，使用全局变量会破坏函数的可重入性，需要增加额外的同步保护处理才能确保数据安全。\n如不可避免需要使用全局变量，需要注意：\n\n对全局变量的读写应集中封装。\n避免使用全局变量作为模块接口。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "",
					"recommend": "按照实际情况排查是否确实需要使用全局变量，对于不需要使用的，修改为局部变量",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": false
				},
				{
					"name": "G.INC.03 禁止头文件循环依赖【c】",
					"language": "c",
					"id": "51c69fc90fef11edb70284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "头文件循环依赖，指 a.h 包含 b.h，b.h 包含 c.h，c.h 包含 a.h，导致任何一个头文件修改，都导致所有包含了a.h/b.h/c.h的代码全部重新编译一遍。\n\n而如果是单向依赖，如a.h包含b.h，b.h包含c.h，而c.h不包含任何头文件，则修改a.h不会导致包含了b.h/c.h的源代码重新编译。\n\n头文件循环依赖直接体现了架构设计上的不合理，可通过优化架构去避免。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "",
					"recommend": "重构代码逻辑，避免安全隐患",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.INC.06 头文件必须用#define保护，防止重复包含【c】",
					"language": "c",
					"id": "51c69fcb0fef11ed8b1a84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "为防止头文件被重复包含，所有头文件都应当使用#define作为包含保护；不要使用#pragma once。\n\n定义包含保护符时，应该遵守如下规则：\n\n保护符使用唯一名称；\n建议考虑项目源代码树顶层以下的文件路径，不要在受保护部分的前后放置代码或者注释，文件头注释除外。\n假定 VOS 工程的 timer 模块的 timer.h，其目录为 vos/include/timer.h。其保护符若使用 ‘TIME_H’很容易不唯一，所以使用项目源代码树的全路径，如：\n\n#ifndef VOS_INCLUDE_TIMER_H\n#define VOS_INCLUDE_TIMER_H\n\n...\n\n#endif\n注意，保护符命名时，避免首尾是下划线(_)：\n\n#ifndef _VOS_INCLUDE_TIME_H_   // 不符合",
					"systemTag": "clangtidy",
					"goodExample": "// vos/include/timer.h\n#ifndef VOS_INCLUDE_TIMER_H // 符合\n#define VOS_INCLUDE_TIMER_H\n\n...\n\n#endif",
					"badExample": "",
					"recommend": "添加#define保护头文件",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.NAM.01 使用统一的命名风格【c】",
					"language": "c",
					"id": "51c69fcd0fef11ed97ae84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "驼峰风格(CamelCase)\n大小写字母混用，单词连在一起，不同单词间通过单词首字母大写来分开。\n按连接后的首字母是否大写，又分: 大驼峰(UpperCamelCase)**和小驼峰(lowerCamelCase)**\n\n内核风格(unix_like)\n又称蛇形风格(snake_case)。单词全小写，用下划线分割。\n如：’test_result’\n\n匈牙利风格\n在“大驼峰”的基础上，加上类型或用途前缀\n如：’uiSavedCount’, ‘bTested’\n\n标识符命名风格的选择由产品自行决策。遵循：\n\n推荐使用驼峰风格，具体描述详见下文\n对于更亲和 Linux/Unix 的代码，可以使用内核风格\n已使用内核命名风格的代码，可以选择继续使用内核风格\n基于开源或外部代码进行开发或维护时，可以保持原有命名风格\n基于产品或版本生命周期以及人力投入考虑，可以保持存量代码的匈牙利风格不变\n对于仍活跃的使用了匈牙利风格的的产品或版本，建议制定合理可行的整改策略，过渡至驼峰风格\n不管什么样的命名风格整改策略，都应该保证同一函数或结构体、联合体内的命名风格是一致的\n当前条款推荐的“驼峰风格”具体规则如下：\n\n类别 命名风格 形式\n函数，结构体类型，枚举类型，联合体类型，typedef 定义的类型 大驼峰，或带模块前缀的大驼峰 AaaBbb, XXX_AaaBbb\n局部变量，函数参数，宏参数，结构体中字段，联合体中成员 小驼峰 aaaBbb\n全局变量（在函数外部定义的变量） 带 ‘g_’ 前缀的小驼峰 g_aaaBbb\n宏（不包括函数式宏），枚举值，goto 标签 全大写，下划线分割 AAA_BBB\n函数式宏 全大写下划线分割，或大驼峰，或带模块前缀的大驼峰 AAA_BBB, AaaBbb, XXX_AaaBbb\n常量（在函数外部定义由const修饰的基本数据类型、枚举类型、字符串类型） 全大写下划线分割，或带 ‘g_’ 前缀的小驼峰 AAA_BBB, g_aaaBbb\n关于“模块前缀”：\n\n仅大驼峰命名风格的符号，可选加模块前缀。\n模块前缀尽量简短且不超过2级（XXX_YYY_AaaBbb, XxxYyyAaaBbb）。\n应保持风格统一，只选用一种前缀形式（仅选用XXX_AaaBbb，或仅选用XxxAaaBbb）。\n关于“函数式宏”：\n\n函数式宏的命名风格优先与宏一样，采用“全大写下划线分割”。\n特殊场景，允许将函数式宏的命名风格与函数一样，但这种情况应该是极少的。比如：\n#ifdef SOME_DEFINE\nvoid Bar(int);\n#define Foo(a) Bar(a) // 特殊场景，用大驼峰风格命名函数式宏\n#else\nvoid Foo(int);  // 函数命名风格\n#endif\n关于单词缩写：\n\n单词缩写应当作单个单词处理，以提高可读性。比如对包含HTTP(HyperText Transfer Protocol)缩写的函数命名如下：\nint GetActiveHttpClientCnt(void);",
					"systemTag": "clangtidy",
					"goodExample": "int MyCmp(int a, int b); // 符合: 函数大驼峰，参数小驼峰（单字符变量也符合小驼峰定义）\n\nenum MyColor {                // 符合：枚举类型，大驼峰\n    BLACK,                    // 符合: 枚举值，全大写，下划线分割\n    WHITE\n} g_bgColor = WHITE;          // 符合: 全局变量，带 g_前缀的小驼峰\n\nint XXX_YYY_FuncName(void);   // 符合: 函数，两级前缀，大模块加小模块\n\nconst int NAME_MAX_LEN = 100; // 符合: 符合上述常量定义，用全大写下划线分割",
					"badExample": "",
					"recommend": "修改标识符名称",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.INC.09 按照合理的顺序包含头文件【c】",
					"language": "c",
					"id": "51c6c6b60fef11edad2c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "使用固定的头文件包含顺序可增强可读性,避免隐藏依赖。\n建议按稳定度包含头文件，依次顺序为：\nC标准库，操作系统库，平台库，项目公共库，自己其他的依赖。\n\n【例外】\n当源文件对应的头文件用于验证自包含时，可以作为第一个头文件。",
					"systemTag": "clangtidy",
					"goodExample": "考虑到C标准库，操作系统库等头文件比项目自研的头文件相对稳定，foo.c中包含头文件的次序如下：\n\n#include &lt;stdlib.h&gt; // C 标准库\n#include &lt;string.h&gt;\n\n#include &lt;linux/list.h&gt; // 操作系统库\n#include &lt;linux/time.h&gt;\n\n#include \"platform/base.h\" // 平台库\n#include \"platform/struct.h\"\n\n#include \"project/public/log.h\" // 项目公共库\n\n#include \"bar.h\" // foo.c 的依赖 bar.h\n\n#include \"foo.h\" // foo.c 对应头文件放最后一个，也可以放第一个",
					"badExample": "",
					"recommend": "调整头文件包含顺序",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FUD.01 对象或函数的所有声明必须与定义具有一致的名称和类型限定符【c】",
					"language": "c",
					"id": "51c6c6b80fef11eda07c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "在函数或对象的声明和定义中应使用一致的类型和限定符，声明和定义之间的不一致可能存在编程错误，参数名可以提供关于函数接口的有用信息。本规则要求如下：\n\n函数声明中的参数应该包含参数名，并且函数定义与其声明中的参数类型以及参数名需要保持一致。\n如果一个函数声明中没有参数，则在其原型中使用关键字void，否则将导致调用方和被调用方之间的功能接口模糊。\n同一个对象的声明和定义应保持一致，包括类型、限定符等。\n参考C11标准6.2.7第1段，第2段：\n\n引用同一对象或函数的所有声明应具有一致的类型，否则程序会产生未定义行为。",
					"systemTag": "clangtidy",
					"goodExample": "如下代码示例中，保持声明和定义一致：\n// In func.h\nextern int g_a;\nextern int g_array[4];\nvoid Func1(int num);\nvoid Func2(int num);\nvoid Func3(int num, int count);\n\ntypedef int Width;\ntypedef int Height;\n\nvoid Func4(void)\nvoid (*Fp1)(void);\ntypedef void (*Fp2)(int num);\ntypedef void (*Fp3)(int n); // 该规则不要求函数指针中的参数名与其指向函数参数名相同\n\n// In func.c\nint g_a = 0;\nint g_array[4] = {0};\n\nvoid Func1(int num)\n{\n　  ...\n}\nvoid Func2(int num)\n{\n    ...\n}\nvoid Func3(int num, int count)\n{\n    ...\n}\nvoid Func4(void)\n{\n    ...\n}",
					"badExample": "如下代码示例中，在func.c中定义了函数，但是在func.h中对该函数的声明存在名称或类型限定符上的不一致，错误的地方已通过注释的方式标识出来。\n\n// In func.h\nvoid Func1(const int num);    // 不符合：参数的限定符与函数定义不一致\nvoid Func2(int);              // 不符合：缺少参数名，应修改为void Func2(int num)\n\n// 不符合： 参数名不匹配，应修改为 void Func3(int num, int count)\nvoid Func3(int count, int num);\n\nvoid Func4();                  // 不符合：空参数列表，应修改为void Func4(void)\n\nvoid (*Fp1)();                 // 不符合：空参数列表，应修改为void (*Fp1)(void)\ntypedef void (*Fp2)(int);      // 不符合：缺少参数名\n\n// In func.c\nint g_a = 0;\nint g_array[4] = {0};\n\nvoid Func1(int num) // 不符合： 参数的限定符与函数声明不一致\n{\n    ...\n}\nvoid Func2(int num)\n{\n    ...\n}\nvoid Func3(int num, int count)\n{\n    ...\n}\nvoid Func4() // 不符合： 应修改为 void Func4(void)\n{\n    ...\n}\n\n// In caller.c\n#include \"func.h\"\nextern short g_a;    // 不符合： 类型不一致，应在func.h中声明\nextern int *g_array; // 不符合： 类型不一致，应在func.h中声明\n\nvoid Caller(void)\n{\n    Func4(3);        // 不符合： 由于兼容性原因，可以编译通过，但是传入了无用的参数\n}",
					"recommend": "声明和定义保持一致",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.10 宏定义不应依赖宏外部的局部变量名【c】",
					"language": "c",
					"id": "51c6c6ba0fef11ed900984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "宏定义中要使用的变量都要求作为参数传递给宏。\n如果宏定义中直接使用宏外部的局部变量名，会导致宏的可重用性差，而且不利于理解。",
					"systemTag": "clangtidy",
					"goodExample": "#define INIT(x) ((x)-&gt;y-&gt;length)\n\n...\nint count = INIT(msg);",
					"badExample": "#define INIT(x) do { \\\n    count = (x)-&gt;y-&gt;length; \\\n} while (0)\n\n...\nint count;\nINIT(msg);",
					"recommend": "将需要引用的局部变量作为参数传递进来",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.02 定义宏时，要使用完备的括号【c】",
					"language": "c",
					"id": "51c6c6bc0fef11ed9b1484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "宏展开时只做文本替换，在编译时再求值。文本替换后，宏包含的语句跟调用点代码合并。\n合并后的表达式因为操作符的优先级和结合律，可能会导致计算结果跟期望的不同。",
					"systemTag": "clangtidy",
					"goodExample": "#define C_LEN (A_LEN + B_LEN)   // 符合\n带参数的宏更容易出现问题，比如：\n\n#define SUM(a, b) ((a) + (b)) // 符合\n但是要避免滥用括号。如下所示，单独的数字或标识符加括号毫无意义。\n\n#define SOME_CONST  100         // 符合: 单独的数字无需括号\n#define ANOTHER_CONST   (-1)    // 符合: 负数需要使用括号\n#define THE_CONST   SOME_CONST  // 符合: 单独的标识符无需括号",
					"badExample": "#define C_LEN A_LEN + B_LEN     // 不符合\n上述宏在展开时，A_LEN 与 B_LEN 的加法并不一定是优先计算。\n\n#define SUM(a, b) a + b     // 不符合\n下面这样调用该宏，执行结果跟预期不符：\n100 / SUM(2, 8) 将扩展成(100 / 2) + 8，而预期结果是100 / (2 + 8)。",
					"recommend": "函数式宏参数使用时添加括号",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CTL.05 慎用 goto 语句【c】",
					"language": "c",
					"id": "51c6c6be0fef11ed890884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "goto语句会破坏程序的结构性，所以除非确实需要，最好不使用goto语句。使用时，也只允许跳转到本函数内 goto 语句之后的标签。\n\ngoto语句通常用来实现函数单点返回。\n\n同一个函数体内部存在大量相同的逻辑但又不方便封装成函数的情况下，例如反复执行文件操作，对文件操作失败以后的处理部分代码（例如关闭文件句柄，释放动态申请的内存等等），2会放在该函数体的最后部分，在需要的地方就goto到那里，这样代码反而变得清晰简洁。\n\n实际也可以将失败处理的代码封装成函数或者封装成宏，但是这么做会让代码变得没那么直接明了。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "// 符合: 使用 goto 实现单点返回\nint SomeInitFunc(void)\n{\n    void *p1 = NULL;\n    void *p2 = NULL;\n    void *p3 = NULL;\n\n    p1 = malloc(MEM_LEN);\n    if (p1 == NULL) {\n       goto EXIT;\n    }\n\n    p2 = malloc(MEM_LEN);\n    if (p2 == NULL) {\n        goto EXIT;\n    }\n\n    p3 = malloc(MEM_LEN);\n    if (p3 == NULL) {\n        goto EXIT;\n    }\n\n    DoSomething(p1, p2, p3);\n    return 0; // 符合\n\nEXIT:\n    if (p3 != NULL) {\n        free(p3);\n    }\n    if (p2 != NULL) {\n        free(p2);\n    }\n    if (p1 != NULL) {\n        free(p1);\n    }\n    return -1;\n}",
					"recommend": "避免使用goto语句",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FUD.05 函数要简短——函数参数个数【c】",
					"language": "c",
					"id": "51c6c6c00fef11ed8fe184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "函数要简短。复杂过长的函数不利于阅读理解，难以维护。 过长的函数往往意味着函数功能不单一，过于复杂，或过分呈现细节，未进行进一步拆分或分层。\n\n产品可从如下维度间接约束函数的尺寸和复杂度：\n\n函数行数建议不超过50行（非空非注释）。\n函数的参数个数。建议不超过5个。\n函数最大代码块嵌套深度。建议不超过4层。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "",
					"recommend": "拆分复杂函数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.ARR.07 声明一个带有外部链接的数组时，必须显式指定它的大小【c】",
					"language": "c",
					"id": "51c6c6c20fef11edba1784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "在声明具有外部链接的数组时，明确指定其大小会使代码更加安全。明确声明外部链接数组的大小可以方便在编写代码时，校验数组索引是否越界；而且还有利于静态分析工具做数组边界检查。\n\n此规则仍然允许通过初始化列表隐式指定大小的方式来定义一个数组，但在将其声明为一个带有外部链接的数组时，必须显式指定它的大小。\n\n在声明同时也要遵从规则：G.INC.07 禁止通过声明的方式引用外部函数接口、变量",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "如下是正确的代码示例，在头文件中声明全局数组g_array时，显式指定了数组的大小为MAX_LEN。\n\n// in foo.h\nextern int g_array[MAX_LEN];   // 符合：显式指定了数组大小\n\n\n当使用初始化列表隐式指定外部链接数组的大小时，可以定义独立的记录数组长度的常量来使用该数组。\n\n// foo.h\nconst size_t g_privLen;\nconst char g_priv[];\n\n// foo.c\nconst char g_priv[] = {'x', 'w', 'r'};\nconst size_t g_privLen = sizeof(priv) / sizeof(priv[0]);",
					"badExample": "// in foo.h\nextern int g_array[];     // 不符合：没有显式指定数组大小",
					"recommend": "明确指定数组大小",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CNS.01 禁止使用小写字母“l”作为数值型常量后缀【c】",
					"language": "c",
					"id": "51c6c6c40fef11ed83ab84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "C语言标准允许使用后缀来显式指定数值型常量的类型，例如：整数常量可以使用后缀字母 l 或 L 表示常量类型 long，使用字母 ll 或 LL 表示 long long。当使用小写字母 l 指定数值型常量类型时，在视觉上容易和数字 1 混淆。为了避免这种混淆带来的误解，应使用大写字母 L 或 LL 作为数值型常量的后缀。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "如下代码示例通过使用大写字母 L 而不是小写字母 l 来消除视觉上的错觉：\n#define CONSTANT_BARRETT_REDUCTION 0x1F7011641LL",
					"badExample": "如下代码示例中，宏 CONSTANT_BARRETT_REDUCTION 的值为 0x1F7011641，但是视觉上像是 0x1F701164111：\n#define CONSTANT_BARRETT_REDUCTION 0x1F7011641ll",
					"recommend": "小写\"l\"替换成大写\"L\"",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.TYP.01 不要重复定义基础类型【c】",
					"language": "c",
					"id": "51c6c6c60fef11ed964b84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "产品或项目应规划使用相同版本的类型定义，这是一种很好的实践。建议优先使用符合C99，C11标准定义的类型（如：在一个产品中统一使用stdint.h中定义的整数类型）。\n\n避免滥用 typedef/#define 对基础类型起别名，因为一个产品或项目中如果存在多种类型定义（如同时使用u32，v32，uint32，uint表示unsigned int类型）会使代码变得更加混乱，难以维护和难以编译。使用不同的类型系统，也违反了风格一致原则。\n\n所以除非有明确的必要性，否则不要用 typedef/#define 对基础类型进行重定义。\n\n下面的场景中重新定义了基础类型为uintptr，其屏蔽了不同平台（CPU/OS）下C语言基本数值类型的位宽差异，是具有必要性的。\n\n#include &lt;bits/wordsize.h&gt;\n\n// __WORDSIZE is defined in wordsize.h\n#if __WORDSIZE == 64\ntypedef unsigned long int uintptr;\n#else\ntypedef unsigned int uintptr;\n#endif\n注意：\n当整合其他独立模块代码（如开源代码、第三方代码）时，可增加适配层隔离定义冲突。\n\n在可预见的未来，需要提高精度\n\ntypedef uint8 DevId;\n...\n// 若干版本后扩展成 16-bit\ntypedef uint16 DevId;\n有特殊作用的类型\n\ntypedef void *Handle;\n注意：能用 typedef 的地方，尽量不用 #define 进行别名定义。\n\n下面例子是不同模块都使用各自的类型别名，因为历史原因，同名的类型，定义却不同。\n\n// 模块 A\n...\ntypedef unsigned long ULONG;\n...\n// 模块 B\n...\n#define ULONG UINT32\n...\n模块 B 因为是从 32 位平台移植过来，代码中把 ULONG 当作 32 位使用，所以移植时使用 UINT32 定义。\n当系统运行在 unsigned long 为 64 位的平台上时，如果两个模块有接口交互，则这两种类型定义将引起混乱，甚至可能出现1问题。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "如无必要，不要重新定义基础类型",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.12 避免连续3个或更多空行【c】",
					"language": "c",
					"id": "51c6c6c80fef11ed9ff284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "减少不必要的空行，可以显示更多的代码，方便代码阅读。下面有一些建议遵守的规则：\n\n根据上下内容的相关程度，合理安排空行；\n函数内部、类型定义内部、宏内部、初始化表达式内部，不使用连续空行\n不使用连续 3 个空行，或更多\n大括号内的代码块行首之前和行末之后不要加空行。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "ret = DoSomething();\n\nif (ret != OK) {   // 不符合： 返回值判断应该紧跟函数调用\n    return -1;\n}\nint Foo(void)\n{\n    ...\n}\n\n\n\nint Bar(void)      // 不符合：最多使用连续2个空行\n{\n    ...\n}\nint Foo(void)\n{\n\n    DoSomething(); // 不符合：大括号内部首尾，不需要空行\n    ...\n\n}",
					"recommend": "删除多余空行",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CMT.01 注释符与注释内容间要有1空格【c】",
					"language": "c",
					"id": "51c6edce0fef11edb9ca84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "注释符使用 /* */和 // 都是可以的。\n注释符与注释内容之间要有1空格。\n\n使用如下的单行、多行注释风格：\n\n// 单行注释\n/* 另外一种单行注释 */\n/*\n * 多行注释\n * 第二行\n */\n// 另外一种多行注释\n// 第二行\n【注意】\n\n若产品选用如 doxygen 来基于注释生成代码文档，则应由产品制定统一的各类广义的注释符及注释风格。\n“注释内容”有可能也包含空格，比如：\n/*\n * 这是一段注释内容也包含空格的例子。\n * XX参数解释如下：\n *     a - 参数 a 说明\n *     b - 参数 b 说明\n */",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "按要求使用注释符",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CMT.02 代码注释置于对应代码的上方或右边【c】",
					"language": "c",
					"id": "51c6edd00fef11edb73984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "针对代码的注释，应该置于对应代码的上方或右方。\n\n代码上方的注释，与代码行间无空行，保持与代码一样的缩进。\n例：\n\n// 这是 Foo() 的注释\nint Foo(void)\n{\n    // 这是变量 a 的注释\n    int a = INIT_A_VALUE;\n    ...\n}\n代码右边的注释，与代码之间，至少留1空格。\n例：\n\nint foo = 100;  // 这里是注释内容，与代码至少留1空格\n右置格式在适当的时候，上下对齐会更美观。\n例：\n\n#define A_CONST 100         // 此处两行注释属于同类\n#define ANOTHER_CONST 200   // 可保持左侧对齐\n通常右置注释内容不宜过多；当右置注释超过行宽时，请考虑将注释置于代码上方。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "按要求放置注释",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.02 表达式的比较，应当遵循左侧倾向于变化、右侧倾向于不变的原则【c】",
					"language": "c",
					"id": "51c6edd20fef11ed9a0c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "当变量与常量比较时，如果常量放左边，如 if (MAX == v) 不符合阅读习惯，而 if (MAX &gt; v) 更是难以理解。\n\n代码是给人看的，应当按人的正常阅读、表达习惯，将常量放右边。建议写成如下方式：\n\nif (v == MAX) ...\nif (v &lt; MAX) …\n\n【例外】\n用来描述数值区间时，可以写成 if (MIN &lt; v && v &lt; MAX)",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "if (ptr == NULL) { // 符合\n}",
					"badExample": "if (NULL == ptr) { // 不符合\n}",
					"recommend": "将变量放在比较表达式左侧",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.06 函数式宏要简短【c】",
					"language": "c",
					"id": "51c6edd40fef11edad6184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "函数式宏本身的一大问题是比函数更难以调试和定位，特别是宏过长，调试和定位的难度更大。\n\n而且宏扩展会导致目标代码膨胀。建议函数式宏不要超过10行（非空非注释）。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "减少函数式宏的复杂度或者改成函数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.03 包含多条语句的函数式宏的实现语句必须放在 do-while(0) 中【c】",
					"language": "c",
					"id": "51c6edd60fef11ed911884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "宏本身没有代码块的概念。当宏在调用点展开后，宏内定义的表达式和变量融合到调用代码中，可能会出现变量名冲突和宏内语句被分割等问题。\n通过 do-while(0) 显式为宏加上边界，让宏有独立的作用域，并且跟分号能更好的结合而形成单条语句，从而规避此类问题。\n\n【例外】\n\n包含 break, continue 语句的宏可以例外，使用此类宏务必特别小心（G.PRE.05 函数式宏定义中慎用 return、goto、continue、break 等改变程序流程的语句）。\n宏中包含不完整语句时，可以例外。比如用宏封装 for 循环的条件部分。\n非多条语句，或单个 if/for/while/switch 语句，可以例外。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "如下示例代码，会出现编译报错(else没有与之匹配的if语句)：\n\nif (condition)\n    FOO(MAX_MONTH);\nelse\n    FOO(MAX_YEAR);\n更好的写法是用 do-while(0) 把宏FOO执行体括起来，如下所示：\n\n// 符合\n#define FOO(x) do { \\\n    (void)printf(\"arg is %d\\n\", (x)); \\\n    DoSomething((x)); \\\n} while (0)",
					"badExample": "如下所示的宏是错误的用法（为了说明问题，示例代码稍不符规范）：\n\n// 不符合\n#define FOO(x) \\\n    (void)printf(\"arg is %d\\n\", (x)); \\\n    DoSomething((x));\n当像如下示例代码这样调用宏FOO，for 循环只执行了宏的第一条语句，宏的后一条语句只在循环结束后执行一次。\n\nfor (i = 1; i &lt; MAX_TIMES; i++)\n    FOO(i);\n用大括号将FOO定义的语句括起来可以解决上面的问题：",
					"recommend": "用do-while(0)封装代码块",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.INT.09 确保枚举常量映射到唯一值【c】",
					"language": "c",
					"id": "51c6edd80fef11ed908584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "C语言的枚举类型是具有一组有限值的集合，这些值的标识符被称为枚举常量。枚举常量是一个整数常量表达式，其值可表示为int。尽管C语言允许相同枚举类型中的多个枚举常量具有相同的值，但是人们普遍期望同一个枚举类型中的枚举常量具有不同的值。因此，将同一个枚举类型中的多个枚举常量定义为相同的值可能会导致一些不易被发现的错误。",
					"systemTag": "clangtidy",
					"goodExample": "为了防止出现错误代码示例中的问题，枚举类型声明可以采用以下形式之一：\n\n不提供显式的整数赋值，如下示例所示\ntypedef enum {\n    ERR_SYS_ARG_ERR,\n    ERR_SYS_SET_ERR,\n    ERR_SYS_OCCUPIED_ERR,\n    ERR_SYS_REQFREE_ERR,\n    ERR_SYS_NO_REC_ERR,\n    ERR_SYS_ACTIVED_ERR,\n    ERR_SYS_NO_FILE_ERR,\n    ERR_SYS_OPEN_ERR,\n    ERR_SYS_ASSIGN_ERR,\n    ERR_SYS_ALLOC_ERR,\n    ERR_SYS_GET_LIST_ERR,\n    ERR_SYS_IGNORE_ERR,\n    ERR_SYS_REG_ERR,\n    ERR_SYS_CALC_ERR,\n    ERR_SYS_SNED_ERR,\n    ERR_SYS_RECV_ERR,\n    ERR_SYS_MODIFY_ERR,\n    ERR_SYS_CHECK_ERR,\n\n    ERR_EMG_INVALID_ERR,\n    ERR_EMG_TYPE_ERR,\n    ...\n} SomeModuleErrCodes;\n只对第一个成员赋值，如下示例所示\ntypedef enum {\n    ERR_SYS_ARG_ERR      = 0x3a020000,\n    ERR_SYS_SET_ERR,\n    ERR_SYS_OCCUPIED_ERR,\n    ERR_SYS_REQFREE_ERR,\n    ERR_SYS_NO_REC_ERR,\n    ERR_SYS_ACTIVED_ERR,\n    ERR_SYS_NO_FILE_ERR,\n    ERR_SYS_OPEN_ERR,\n    ERR_SYS_ASSIGN_ERR,\n    ERR_SYS_ALLOC_ERR,\n    ERR_SYS_GET_LIST_ERR,\n    ERR_SYS_IGNORE_ERR,\n    ERR_SYS_REG_ERR,\n    ERR_SYS_CALC_ERR,\n    ERR_SYS_SNED_ERR,\n    ERR_SYS_RECV_ERR,\n    ERR_SYS_MODIFY_ERR,\n    ERR_SYS_CHECK_ERR,\n\n    ERR_EMG_INVALID_ERR,\n    ERR_EMG_TYPE_ERR,\n    ...\n} SomeModuleErrCodes;\n在上面的两个选项中，除非第一个枚举数必须具有非零值，否则第一种做法是最简单的方法，因此也是首选方法。",
					"badExample": "如下代码示例中，在枚举类型SomeModuleErrCodes中定义错误码的时候，为两个枚举常量分配了显式值，造成 ERR_SYS_MODIFY_ERR 和 ERR_EMG_INVALID_ERR 被隐式声明为相同的值（0x3a020010），对于程序员来说，可能并不明显。\n这种定义可能导致的错误是尝试将枚举常量用于 switch 语句的标签。由于 switch 语句中的所有标签都必须是唯一的，因此如下代码违反了此语义约束。\n\ntypedef enum {\n    ERR_SYS_ARG_ERR = 0x3a020000,\n    ERR_SYS_SET_ERR,\n    ERR_SYS_OCCUPIED_ERR,\n    ERR_SYS_REQFREE_ERR,\n    ERR_SYS_NO_REC_ERR,\n    ERR_SYS_ACTIVED_ERR,\n    ERR_SYS_NO_FILE_ERR,\n    ERR_SYS_OPEN_ERR,\n    ERR_SYS_ASSIGN_ERR,\n    ERR_SYS_ALLOC_ERR,\n    ERR_SYS_GET_LIST_ERR,\n    ERR_SYS_IGNORE_ERR,\n    ERR_SYS_REG_ERR,\n    ERR_SYS_CALC_ERR,\n    ERR_SYS_SNED_ERR,\n    ERR_SYS_RECV_ERR,\n    ERR_SYS_MODIFY_ERR,    // 不符合：值与ERR_EMG_INVALID_ERR相同\n    ERR_SYS_CHECK_ERR,     // 不符合：值与ERR_EMG_TYPE_ERR相同\n\n    ERR_EMG_INVALID_ERR = 0x3a020010,\n    ERR_EMG_TYPE_ERR,\n    ...\n} SomeModuleErrCodes;",
					"recommend": "（1）纠正编码错误，或者（2）显式指定枚举值",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.04 用括号明确表达式的操作顺序，避免过分依赖默认优先级【c】",
					"language": "c",
					"id": "51c6edda0fef11eda07f84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "可以使用括号强调表达式操作顺序，防止因默认的优先级与设计思想不符而导致程序出错。\n然而过多的括号会分散代码，并降低了可读性，应适度使用。\n\n当表达式包含不常用，优先级易混淆的操作符时，推荐使用括号，比如表达中同时包含位操作符和其他类型操作符。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "c = (a & 0xFF) + b; // 涉及位操作符，需要括号",
					"badExample": "",
					"recommend": "添加括号明确表达式顺序",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.INC.08 禁止在 extern \"C\" 中包含头文件【c】",
					"language": "c",
					"id": "51c6eddc0fef11edb99b84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "在 extern “C” 中包含头文件，有可能会导致 extern “C” 嵌套，部分编译器对extern “C” 嵌套层次有限制，嵌套层次太多会编译错误。\n\nextern “C” 通常出现在 C，C++ 混合编程的情况下，在 extern “C”中包含头文件，可能会导致被包含头文件的原有意图遭到破坏，比如链接规范被不正确地更改。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "#ifdef __cplusplus\n#include \"a.h\" // 符合，不会有extern c嵌套\nextern \"C\" {\n#endif\n\nvoid B(void);\n\n#ifdef __cplusplus\n}\n#endif",
					"badExample": "#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"a.h\" // 不符合，可能会出现嵌套\nvoid B(void);\n\n#ifdef __cplusplus\n}\n#endif",
					"recommend": "修改include位置，避免出现extern \"C\"嵌套",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CMT.03 文件头注释包含版权说明【c】",
					"language": "c",
					"id": "51c6edde0fef11edacd984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "文件头注释应首先包含版权说明。\n如果文件头注释需要增加其他内容，可以后面补充。\n比如：文件功能说明，作者、创建日期、注意事项等等。\n\n版权许可内容及格式必须如下，中文版：\n版权所有 (c) 华为技术有限公司 2012-2018\n英文版：\nCopyright (c) Huawei Technologies Co., Ltd. 2012-2018. All rights reserved.\n\n关于版本说明，应注意：\n\n2012-2018 根据实际需要可以修改。\n2012 是文件首次创建年份，而 2018 是最后文件修改年份。\n对文件有重大修改时，必须更新后面年份，如特性扩展，重大重构等。\n可以只写一个创建年份，后续文件修改则不用更新版权声明。\n如：版权所有 (c) 华为技术有限公司 2018\n版权说明可以使用华为子公司。\n如：版权所有 (c) 海思半导体 2012-2018\n或英文：Copyright (c) Hisilicon Technologies Co., Ltd. 2012-2018. All rights reserved.\n对于华为自研用于外部开源的产品与代码，英文中的 ‘All rights reserved.’ 可省略。\n文件头注释举例：\n\n/*\n * 版权所有 (c) 华为技术有限公司 2012-2018\n * XX 功能实现\n * 注意：\n *      - 注意点 1\n *      - 注意点 2\n */\n编写文件头注释应注意：\n\n文件头注释应该从文件顶头开始。\n如果包含“关键资产说明”类注释，则应紧随其后。\n保持统一格式。\n具体格式由项目或更大范围统一制定。格式可参考上面举例。\n保持版面工整，若内容过长，超出行宽要求，换行时应注意对齐。\n对齐可参考上述例子 ‘注意点’。\n首先包含“版权许可”，然后包含其他可先选内容。\n其他选项按需添加，并保持格式统一。\n不要空有格式，无内容。\n如上述例子，如果 ‘注意：’ 后面无内容，不应编写。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "正确包含版权声明",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": false
				},
				{
					"name": "G.INC.07 禁止通过声明的方式引用外部函数接口、变量【c】",
					"language": "c",
					"id": "51c6ede00fef11edb2c884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "只能通过包含头文件的方式使用其他模块或文件提供的接口。\n\n通过声明的方式使用外部函数接口、变量，容易在外部接口改变时导致声明和定义不一致。\n\n同时这种隐式依赖，容易导致架构腐化。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "#include \"b.h\"        // 符合：通过包含头文件的方式使用其他.c提供的接口\n\nint Func(void)\n{\n    int i = Foo();    // 这里使用了外部接口\n    ...\n    return g_bar;     // 这里使用了外部变量\n}",
					"badExample": "int Foo(void);        // 不符合：通过声明的方式引用外部函数\nextern int g_bar;     // 不符合：通过声明的方式引用外部全局变量\n\nint Func(void)\n{\n    int i = Foo();    // 这里使用了外部接口\n    ...\n    return g_bar;     // 这里使用了外部变量\n}",
					"recommend": "通过头文件包含来使用接口",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.06 换行时将操作符留在行末，新行缩进一层或进行同类对齐——函数声明参数换行【c】",
					"language": "c",
					"id": "51c6ede20fef11edbab984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "当语句过长，或者换行后有更好的可读性时，应根据层次或操作符优级先择合适的断行点进行换行，并将表示未结束的操作符或连接符号留在行末。\n操作符、连接符放在行末，表示“未结束，后续还有”。\n新行缩进一层，或者保持同类对齐。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "长表达式举例：\n\n// 假设下面第一行已经不满足行宽要求\nif (currentValue &gt; MIN &&  // 符合：换行后，布尔操作符放在行末\n    currentValue &lt; MAX) {  // 符合: 与(&&)操作符的两个操作数同类对齐\n    DoSomething();\n    ...\n}\n\nflashPara.flashEndAddr = flashPara.flashBaseAddr +  // 符合: 加号留在行末\n                         flashPara.flashSize;       // 符合: 加法两个操作数对齐\n函数参数列表举例：\n\n// 符合：函数参数放在一行\nReturnType result = FunctionName(paramName1, paramName2);\n\nReturnType result = FunctionName(paramName1,\n                                 paramName2,\n                                 paramName3); // 符合：保持与上方参数对齐\n\nReturnType result = FunctionName(paramName1, paramName2,\n    paramName3, paramName4, paramName5);     // 符合：参数换行，4 空格缩进\n\nReturnType result = VeryVeryVeryLongFunctionName( // 行宽不满足第1个参数，直接换行\n    paramName1, paramName2, paramName3);          // 换行后，4 空格缩进\n如果函数的参数存在内在关联性，按照可理解性优先于格式排版要求，对参数进行合理分组换行。\n\n// 符合：每行的参数代表一组相关性较强的数据结构，放在一行便于理解\nint result = DealWithStructLikeParams(left.x, left.y,    // 表示一组相关参数\n                                      right.x, right.y); // 表示另外一组相关参数\n初始化语句举例：\n\n// 符合: 满足行宽要求时不换行\nint arr[4] = { 1, 2, 3, 4 };\n// 符合: 行宽较长时，换行让可读性更好\nconst int rank[] = {\n    16, 16, 16, 16, 32, 32, 32, 32,\n    64, 64, 64, 64, 32, 32, 32, 32\n};\n对于复杂结构数据的初始化，尽量清晰、紧凑。\n参考如下格式：\n\nint a[][4] = {\n    { 1, 2, 3, 4 }, { 2, 2, 3, 4 }, // 符合\n    { 3, 2, 3, 4 }, { 4, 2, 3, 4 }\n};\n\nint b[][8] = {\n    { 1, 2, 3, 4, 5, 6, 7, 8 },     // 符合\n    { 2, 2, 3, 4, 5, 6, 7, 8 }\n};\nint c[][8] = {\n    {\n        1, 2, 3, 4, 5, 6, 7, 8      // 符合\n    }, {\n        2, 2, 3, 4, 5, 6, 7, 8\n    }\n};\n对于初始化语句中的大括号，遵循：\n\n左大括号放行末时，对应的右大括号需另起一行\n左大括号被内容跟随时，对应的右大括号也应跟随内容",
					"badExample": "ReturnType result = FunctionName(paramName1,\n paramName2); // 不符合，未按要求对齐\n\n\nflashPara.flashEndAddr = flashPara.flashBaseAddr \n      +  flashPara.flashSize;       // 不符合，操作符应该在上一行末",
					"recommend": "按要求进行对齐",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CMT.04 不写空有格式的函数头注释【c】",
					"language": "c",
					"id": "51c714d90fef11ed8eb084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "要像写代码注释一样按需去写函数头注释。\n\n并不是所有的函数都需要函数头注释；\n函数原型无法表达的，却又希望读者知道的信息，才需要加函数头注释辅助说明；\n\n函数头注释统一放在函数声明或定义上方。\n选择使用如下风格之一：\n使用’//‘写函数头\n\n// 单行函数头\nint Func1(void);\n\n// 多行函数头\n// 第二行\nint Func2(void);\n使用’/*‘ ‘*/‘ 写函数头\n\n/* 单行函数头 */\nint Func1(void);\n\n/*\n * 单行或多行函数头\n * 第二行\n */\nint Func2(void);\n函数尽量通过函数名自注释，按需写函数头注释。\n不要写无用、信息冗余的函数头；不要写空有格式的函数头。\n\n函数头注释内容可选，但不限于：功能说明、返回值、性能约束、用法、内存约定、算法实现、可重入的要求等等。\n模块对外头文件中的函数接口声明，其函数头注释，应当将重要、有用的信息表达清楚。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "/*\n * 返回实际写入的字节数，-1表示写入失败\n * 注意，len小于INT_MAX\n */\nint WriteData(const unsigned char *buf, size_t len);",
					"badExample": "/*\n * 函数名：WriteData\n * 功能：写入字符串\n * 参数：\n * 返回值：\n */\nint WriteData(const unsigned char *buf, size_t len);\n上面注释示例中的问题：\n\n参数、返回值，空有格式没内容\n注释中的函数名信息冗余",
					"recommend": "补充内容或者删除空有格式的注释",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FUD.05 函数要简短——函数嵌套层次【c】",
					"language": "c",
					"id": "51c714db0fef11edb15a84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "函数要简短。复杂过长的函数不利于阅读理解，难以维护。 过长的函数往往意味着函数功能不单一，过于复杂，或过分呈现细节，未进行进一步拆分或分层。\n\n产品可从如下维度间接约束函数的尺寸和复杂度：\n\n函数行数建议不超过50行（非空非注释）。\n函数的参数个数。建议不超过5个。\n函数最大代码块嵌套深度。建议不超过4层。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "拆分复杂函数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.06 换行时将操作符留在行末，新行缩进一层或进行同类对齐——函数调用参数换行【c】",
					"language": "c",
					"id": "51c714dd0fef11ed9c3a84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "当语句过长，或者换行后有更好的可读性时，应根据层次或操作符优级先择合适的断行点进行换行，并将表示未结束的操作符或连接符号留在行末。\n操作符、连接符放在行末，表示“未结束，后续还有”。\n新行缩进一层，或者保持同类对齐。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "长表达式举例：\n\n// 假设下面第一行已经不满足行宽要求\nif (currentValue &gt; MIN &&  // 符合：换行后，布尔操作符放在行末\n    currentValue &lt; MAX) {  // 符合: 与(&&)操作符的两个操作数同类对齐\n    DoSomething();\n    ...\n}\n\nflashPara.flashEndAddr = flashPara.flashBaseAddr +  // 符合: 加号留在行末\n                         flashPara.flashSize;       // 符合: 加法两个操作数对齐\n函数参数列表举例：\n\n// 符合：函数参数放在一行\nReturnType result = FunctionName(paramName1, paramName2);\n\nReturnType result = FunctionName(paramName1,\n                                 paramName2,\n                                 paramName3); // 符合：保持与上方参数对齐\n\nReturnType result = FunctionName(paramName1, paramName2,\n    paramName3, paramName4, paramName5);     // 符合：参数换行，4 空格缩进\n\nReturnType result = VeryVeryVeryLongFunctionName( // 行宽不满足第1个参数，直接换行\n    paramName1, paramName2, paramName3);          // 换行后，4 空格缩进\n如果函数的参数存在内在关联性，按照可理解性优先于格式排版要求，对参数进行合理分组换行。\n\n// 符合：每行的参数代表一组相关性较强的数据结构，放在一行便于理解\nint result = DealWithStructLikeParams(left.x, left.y,    // 表示一组相关参数\n                                      right.x, right.y); // 表示另外一组相关参数\n初始化语句举例：\n\n// 符合: 满足行宽要求时不换行\nint arr[4] = { 1, 2, 3, 4 };\n// 符合: 行宽较长时，换行让可读性更好\nconst int rank[] = {\n    16, 16, 16, 16, 32, 32, 32, 32,\n    64, 64, 64, 64, 32, 32, 32, 32\n};\n对于复杂结构数据的初始化，尽量清晰、紧凑。\n参考如下格式：\n\nint a[][4] = {\n    { 1, 2, 3, 4 }, { 2, 2, 3, 4 }, // 符合\n    { 3, 2, 3, 4 }, { 4, 2, 3, 4 }\n};\n\nint b[][8] = {\n    { 1, 2, 3, 4, 5, 6, 7, 8 },     // 符合\n    { 2, 2, 3, 4, 5, 6, 7, 8 }\n};\nint c[][8] = {\n    {\n        1, 2, 3, 4, 5, 6, 7, 8      // 符合\n    }, {\n        2, 2, 3, 4, 5, 6, 7, 8\n    }\n};\n对于初始化语句中的大括号，遵循：\n\n左大括号放行末时，对应的右大括号需另起一行\n左大括号被内容跟随时，对应的右大括号也应跟随内容",
					"badExample": "ReturnType result = FunctionName(paramName1,\n paramName2); // 不符合，未按要求对齐\n\n\nflashPara.flashEndAddr = flashPara.flashBaseAddr \n      +  flashPara.flashSize;       // 不符合，操作符应该在上一行末",
					"recommend": "按要求进行对齐",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FUD.05 函数要简短——函数大小【c】",
					"language": "c",
					"id": "51c714df0fef11eda6c184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "函数要简短。复杂过长的函数不利于阅读理解，难以维护。 过长的函数往往意味着函数功能不单一，过于复杂，或过分呈现细节，未进行进一步拆分或分层。\n\n产品可从如下维度间接约束函数的尺寸和复杂度：\n\n函数行数建议不超过50行（非空非注释）。\n函数的参数个数。建议不超过5个。\n函数最大代码块嵌套深度。建议不超过4层。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "拆分复杂函数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.07 函数的返回类型及修饰符与函数名同行【c】",
					"language": "c",
					"id": "51c714e10fef11ed927884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "声明定义函数时，函数的返回值类型以及其他修饰符，保持与函数名同一行。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "声明定义函数时，函数的返回值类型以及其他修饰符，保持与函数名同一行。\n\n例：\n\nstatic inline int ShortFunc(int a, int b);         // 符合",
					"badExample": "声明定义函数时，函数的返回值类型以及其他修饰符，保持与函数名同一行。\n\n例：\n\nstatic inline int\nShortFunc(int a, int b);         // 不符合",
					"recommend": "函数返回值及修饰符与函数名调整到同一行",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.INC.02 头文件的扩展名只使用.h，不使用非习惯用法的扩展名，如.inc【c】",
					"language": "c",
					"id": "51c714e30fef11edb56184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "有些产品中使用了 .inc 作为头文件扩展名，这不符合C语言的习惯用法。\n在使用 .inc 作为头文件扩展名的产品，习惯上用于标识此头文件为私有头文件。\n但是从产品的实际代码来看，这一条并没有被遵守，一个 .inc 文件被多个 .c 包含。\n本规范不提倡将私有定义单独放在头文件中，具体见条款 “G.INC.01 在头文件中声明需要对外公开的接口”。\n除此之外，使用 .inc 可能还导致某些IDE工具无法识别其为头文件，造成很多功能不可用，如“跳转到变量定义处”。虽然其中一些可以通过配置强迫IDE识别 .inc 为头文件，但还是有些无法通过配置识别。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "修改头文件扩展名",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.INC.04 禁止包含用不到的头文件【c】",
					"language": "c",
					"id": "51c714e50fef11ed96f284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "如果当前源文件没有直接引用头文件中的对外接口，则不应包含。\n\n包含不需要的头文件会引入不必要的依赖，增加了模块或单元之间的耦合度，增加了代码复杂性，可维护性差。\n\n很多系统中头文件包含关系复杂。程序员为了省事起见，直接包含一切想到的头文件，甚至发布了一个god.h，其中包含了所有头文件，然后发布给各个项目组使用。\n\n这种只图一时省事的做法，不仅导致整个系统的编译时间恶化，而且代码的维护成本非常高。",
					"systemTag": "clangtidy",
					"goodExample": "",
					"badExample": "",
					"recommend": "（1）删除头文件，或者（2）按需包含头文件",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.11 用空格突出关键字和重要信息——关键信息【c】",
					"language": "c",
					"id": "51c714e70fef11eda60084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "空格应该突出关键字和重要信息。总体要求如下：\n\n行末不应加空格\nif, switch, case, do, while, for 等关键字之后应加空格\n小括号内部的两侧，不应加空格\n二元操作符（= + ‐ &lt; &gt; * / % | & ^ &lt;= &gt;= == !=）两侧都应加空格\n一元操作符（& * + ‐ ~ !）之后不应加空格\n三元操作符（? :）符号两侧都应加空格\n结构体中表示位域的冒号，两侧都应加空格\n前置和后置的自增、自减（++ –）和变量之间不应加空格\n结构体成员操作符（. -&gt;）前后不应加空格\n大括号内部两侧有无空格，左右应保持一致\n逗号、分号、冒号（不含三元操作符和表示位域的冒号）紧跟前面内容无空格，其后需要空格\n函数参数列表的小括号与函数名之间不应加空格\n类型强制转换的小括号与被转换对象之间不应加空格\n数组的中括号与数组名之间不应加空格\n涉及到换行时，行末的空格可以省去\n对于大括号内部两侧的空格，建议如下：\n\n2的，大括号内部两侧建议加空格\n对于空的，或单个标识符，或单个字面常量，空格不是必须\n如：’{}’, ‘{0}’, ‘{NULL}’, ‘{“hi”}’ 等\n连续嵌套的多重括号之间，空格不是必须\n如：’{{0}}’, ‘{{ 1, 2 }}’ 等\n错误示例：’{ 0, {1}}’，不属于连续嵌套场景，而且最外侧大括号左右不一致\n注意：可在集成开发环境（IDE）和代码编辑器中设置保存文件时删除行末空格功能。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "变量定义\nint i = 0;               // 符合：变量初始化时，= 前后应该有空格，分号前面不要留空格\nint buf[BUF_SIZE] = {0}; // 符合：数组初始化时，大括号内空格可选\nint arr[] = { 10, 20 };  // 符合: 正常大括号内部两侧建议加空格\n指针和取地址\nx = *p;   // 符合：*操作符和指针p之间不加空格\np = &x;   // 符合：&操作符和变量x之间不加空格\nx = r.y;  // 符合：通过.访问成员变量时不加空格\nx = r-&gt;y; // 符合：通过-&gt;访问成员变量时不加空格\n操作符\nx = 0;    // 符合：赋值操作的=前后都要加空格\nx = -5;   // 符合：负数的符号之前要加空格\n++x;      // 符合：前置和后置的++/--和变量之间不要加空格\nx--;\n\nif (x && !y)       // 符合：布尔操作符前后要加上空格，！操作和变量之间不要空格\nv = w * x + y / z; // 符合：二元操作符前后要加空格\nv = w * (x + z);   // 符合：括号内的表达式前后不需要加空格\n循环和条件语句\nif (condition) { // 符合：if关键字和括号之间加空格，括号内条件语句前后不加空格\n    ...\n} else {         // 符合：else关键字和大括号之间加空格\n    ...\n}\n\n// 符合：while关键字和括号之间加空格，括号内条件语句前后不加空格\nwhile (condition) {}\n\n// 符合：for关键字和括号之间加空格，分号之后加空格\nfor (int i = 0; i &lt; someRange; i++) {\n    ...\n}\n\nswitch (var) { // 符合: switch 关键字后面有1空格\n    case 0:    // 符合：case语句条件和冒号之间不加空格\n        ...\n        break;\n    ...\n    default:\n        ...\n        break;\n}",
					"badExample": "函数定义和函数调用的情况\n\nint result = Foo(arg1,arg2);\n                      ^         // 不符合： 逗号后面应该有空格\n\nint result = Foo( arg1, arg2 );\n                 ^          ^   // 不符合： 小括号内部两侧不应有空格",
					"recommend": "按要求增加/减少空格",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.02 使用空格进行缩进，每次缩进4个空格【c】",
					"language": "c",
					"id": "51c714e90fef11ed828f84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "使用空格而不是制表符(‘\\t’)进行缩进，每次缩进为 4 个空格。\n当前几乎所有的集成开发环境（IDE）和代码编辑器都支持配置将Tab键自动扩展为4空格输入，请配置你的代码编辑器支持使用空格进行缩进。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "按要求进行缩进",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.06 换行时将操作符留在行末，新行缩进一层或进行同类对齐——数据初始化换行【c】",
					"language": "c",
					"id": "51c714eb0fef11ed93f384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "当语句过长，或者换行后有更好的可读性时，应根据层次或操作符优级先择合适的断行点进行换行，并将表示未结束的操作符或连接符号留在行末。\n操作符、连接符放在行末，表示“未结束，后续还有”。\n新行缩进一层，或者保持同类对齐。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "长表达式举例：\n\n// 假设下面第一行已经不满足行宽要求\nif (currentValue &gt; MIN &&  // 符合：换行后，布尔操作符放在行末\n    currentValue &lt; MAX) {  // 符合: 与(&&)操作符的两个操作数同类对齐\n    DoSomething();\n    ...\n}\n\nflashPara.flashEndAddr = flashPara.flashBaseAddr +  // 符合: 加号留在行末\n                         flashPara.flashSize;       // 符合: 加法两个操作数对齐\n函数参数列表举例：\n\n// 符合：函数参数放在一行\nReturnType result = FunctionName(paramName1, paramName2);\n\nReturnType result = FunctionName(paramName1,\n                                 paramName2,\n                                 paramName3); // 符合：保持与上方参数对齐\n\nReturnType result = FunctionName(paramName1, paramName2,\n    paramName3, paramName4, paramName5);     // 符合：参数换行，4 空格缩进\n\nReturnType result = VeryVeryVeryLongFunctionName( // 行宽不满足第1个参数，直接换行\n    paramName1, paramName2, paramName3);          // 换行后，4 空格缩进\n如果函数的参数存在内在关联性，按照可理解性优先于格式排版要求，对参数进行合理分组换行。\n\n// 符合：每行的参数代表一组相关性较强的数据结构，放在一行便于理解\nint result = DealWithStructLikeParams(left.x, left.y,    // 表示一组相关参数\n                                      right.x, right.y); // 表示另外一组相关参数\n初始化语句举例：\n\n// 符合: 满足行宽要求时不换行\nint arr[4] = { 1, 2, 3, 4 };\n// 符合: 行宽较长时，换行让可读性更好\nconst int rank[] = {\n    16, 16, 16, 16, 32, 32, 32, 32,\n    64, 64, 64, 64, 32, 32, 32, 32\n};\n对于复杂结构数据的初始化，尽量清晰、紧凑。\n参考如下格式：\n\nint a[][4] = {\n    { 1, 2, 3, 4 }, { 2, 2, 3, 4 }, // 符合\n    { 3, 2, 3, 4 }, { 4, 2, 3, 4 }\n};\n\nint b[][8] = {\n    { 1, 2, 3, 4, 5, 6, 7, 8 },     // 符合\n    { 2, 2, 3, 4, 5, 6, 7, 8 }\n};\nint c[][8] = {\n    {\n        1, 2, 3, 4, 5, 6, 7, 8      // 符合\n    }, {\n        2, 2, 3, 4, 5, 6, 7, 8\n    }\n};\n对于初始化语句中的大括号，遵循：\n\n左大括号放行末时，对应的右大括号需另起一行\n左大括号被内容跟随时，对应的右大括号也应跟随内容",
					"badExample": "ReturnType result = FunctionName(paramName1,\n paramName2); // 不符合，未按要求对齐\n\n\nflashPara.flashEndAddr = flashPara.flashBaseAddr \n      +  flashPara.flashSize;       // 不符合，操作符应该在上一行末",
					"recommend": "按要求进行对齐",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FUD.06 内联函数要尽可能短，避免超过10行【c】",
					"language": "c",
					"id": "51c73d230fef11edad8b84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "将函数定义成内联2希望提升性能，但是实际并不一定能提升性能。\n\n如果函数体短小，则函数内联可以有效的缩减目标代码的大小，并提升函数执行效率。\n\n反之，函数体比较大，内联展开会导致目标代码的膨胀，特别是当调用点很多时，膨胀得更厉害，反而会降低执行效率。\n\n内联函数规模建议控制在 10 行（非空非注释）以内。\n\n不要为了提高性能而滥用内联函数。不要过早优化。2情况，当有实际测试数据证明内联性能更高时，再将函数定义为内联。\n对于类似 setter/getter 短小而且调用频繁的函数，可以定义为内联。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "拆分内联函数或者改为非内联函数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.05 函数式宏定义中慎用 return、goto、continue、break 等改变程序流程的语句【c】",
					"language": "c",
					"id": "51c73d250fef11ed8c7c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "宏中使用 return、goto、continue、break等改变流程的语句，虽然能简化代码，但同时也隐藏了真实流程，不易于理解，存在过度封装，容易导致资源泄漏等问题。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "【例外】\n用于返回值判断等异常处理场景的宏可以包含改变程序流程的语句。\n\n注意：包含 return、goto、continue、break等改变流程语句的宏命名，务必要体现对应关键字。\n比如：\n\n#define RETURN_IF(condition, retValue) \\\n    if (condition) { \\\n        RecordFailInfo(__FILE__, __LINE__); \\\n        return retValue; \\\n    }",
					"badExample": "如下是宏封装 return 容易导致过度封装和使用的场景：\n\n如下代码，status的判断是主干流程的一部分，用宏封装起来后，变得不直观了，阅读时习惯性把RETURN_IF宏忽略掉了，从而导致对主干流程的理解有偏差。\n\n#define LOG_AND_RETURN_IF_FAIL(ret, fmt, ...) do { \\\n    if ((ret) != OK) { \\\n        (void)ErrLog(fmt, ##__VA_ARGS__); \\\n        return (ret); \\\n    } \\\n} while (0)\n\n#define RETURN_IF(cond, ret) do { \\\n    if (cond) { \\\n        return (ret); \\\n    } \\\n} while (0)\n\nret = InitModuleA(a, b, &status);\nLOG_AND_RETURN_IF_FAIL(ret, \"Init module A failed!\"); // 符合\n\nRETURN_IF(status != READY, ERR_NOT_READY); // 不符合： 重要逻辑不明显\n\nret = InitModuleB(c);\nLOG_AND_RETURN_IF_FAIL(ret, \"Init module B failed!\"); // 符合\n如下是宏封装 return 也容易引发内存泄漏的场景：\n\n#define CHECK_PTR(ptr, ret) do { \\\n    if ((ptr) == NULL) { \\\n        return (ret); \\\n    } \\\n} while (0)\n\n...\n\nmem1 = MemAlloc(STR_SIZE_MAX);\nCHECK_PTR(mem1, ERR_CODE_XXX);\n\nmem2 = MemAlloc(STR_SIZE_MAX);\nCHECK_PTR(mem2, ERR_CODE_XXX); // 内存泄漏问题\n如果 mem2 申请内存失败了，CHECK_PTR 会直接返回，而没有释放 mem1。\n\n除此之外，CHECK_PTR 宏命名也不好，宏名只反映了检查动作，没有指明结果。只有看了宏实现才知道指针为空时返回失败。\n\n综上所述：\n\n不推荐宏定义中封装 return、goto、continue、break 等改变程序流程的语句；",
					"recommend": "重构代码逻辑，避免安全隐患",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.03 使用统一的大括号换行风格【c】",
					"language": "c",
					"id": "51c73d270fef11edb0a084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "K&R风格\n换行时，函数左大括号另起一行放行首，并独占一行；其他左大括号跟随语句放行末。\n右大括号独占一行，除非后面跟着同一语句的剩余部分，如 do 语句中的 while，或者 if 语句的 else/else if，或者逗号、分号。\n\n如：\n\nstruct MyType { // 跟随语句放行末，前置1空格\n    ...\n};              // 右大括号后面紧跟分号\n\nint Foo(int a)\n{               // 函数左大括号独占一行，放行首\n    if (a &gt; 0) {\n        ...\n    } else {    // 右大括号、\"else\"、以及后续的左大括号均在同一行\n        ...\n    }           // 右大括号独占一行\n    ...\n}\nAllman风格\n换行时，左大括另起并独占一行，保持与上一行相同缩进；\n右大括号独占一行，除非后面跟着 do 语句中的 while，或者逗号、分号。\n如：\n\nstruct MyType\n{               // 另起并独占一行\n    ...\n};              // 右大括号后面紧跟分号\n\nint Foo(int a)\n{\n    if (a &gt; 0)\n    {\n        ...\n    }\n    else        // 前后的左右大括号均独占一行，所以 'else' 也只能独占一行\n    {\n        ...\n    }\n    ...\n}",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "按照所选风格进行编码",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.05 行宽不超过 120 个字符【c】",
					"language": "c",
					"id": "51c73d290fef11edb49f84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "代码行宽不宜过长，否则不利于阅读。\n控制行宽长度可以间接的引导开发去缩短函数、变量的命名，减少嵌套的层数，提升代码可读性。\n强烈建议和要求每行字符数不要超过 120 个；除非超过 120 能显著增加可读性，并且不会隐藏信息。\n虽然现代显示器分辨率已经很高，但是行宽过长，反而提高了阅读理解的难度；不符合本规范提倡的“清晰”、“简洁”原则。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "在合适的位置换行",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.09 宏定义不以分号结尾【c】",
					"language": "c",
					"id": "51c73d2b0fef11edb06684a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "当宏定义的结尾有分号时，从代码中难以直观发现语句的结束，降低了程序语句的可读性，并增加了程序员在使用宏时额外增加分号的可能(不小心额外增加的分号可能导致程序流程错误)。因此，宏末尾的分号应由使用者提供，宏定义不应以分号结尾。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "在宏定义的末尾不使用分号，而将是否使用分号的决定权交给宏的使用者：\n\n#define LOOP(count)  for (int i = 0; i &lt; (count); i++)\n\nint count = ...;\nLOOP(5) {\n    puts(\"In a loop\\n\");\n}",
					"badExample": "示例用宏定义for语句中的循环头。此宏使用了一个表示循环次数的整数参数，程序员错误地在宏定义的结尾加了分号。\n\n#define LOOP(count)  for (int i = 0; i &lt; (count); i++);\n\nint count = ...;\nLOOP(5) {\n    puts(\"In a loop\\n\");\n}\n程序员希望从代码中获得以下输出：\n\nIn a loop\nIn a loop\nIn a loop\nIn a loop\nIn a loop",
					"recommend": "删除多余的分号",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.07 宏的名称不应与关键字相同【c】",
					"language": "c",
					"id": "51c73d2d0fef11ed9a2784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "使用宏来改变语言关键字（包括用于实现语言扩展的关键字）的含义会导致代码难以理解。如果定义这种宏的同时又包含了标准头文件，则程序会产生未定义行为。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "// 不符合：改变了int的行为，导致后面包含标准头文件时，程序出现未定义的行为\n#define int OTHER_TYPE\n#include &lt;stdlib.h&gt;\n\n// 不符合：重定义关键字\n#define while(x) for (; (x);)",
					"recommend": "修改宏的名称",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CNS.02 不要使用难以理解的常量【c】",
					"language": "c",
					"id": "51c73d2f0fef11eda8ff84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "难以理解的常量，即看不懂，通过上下文也难以明确含义的数字常量、字符串常量。\n难以理解的常量并非一个非黑即白的概念，看不懂也有程度，需要结合代码上下文和业务相关知识来判断。\n\n例如数字 12，在不同的上下文中情况是不一样的：\ntype = 12; 就看不懂，不能明确12代表什么类型；\n但 year = month * 12; 就能看懂，这里12很明显是指1年有12个月。\n\n数字 0 有时候也是难以理解的常量，比如 status = 0;，0 无法明确是什么状态。\n\n解决途径：\n\n对于单点使用的难以理解的常量，按需增加注释说明。\n对于多处使用的难以理解的常量，应该定义宏或 const 变量，并通过符号命名自注释。\n禁止出现下列情况：\n\n没有通过符号命名来解释数字含义，如 #define ZERO 0\n符号命名限制了其取值，如 #define XX_TIMER_INTERVAL_300MS 300",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "如下代码示例中，使用能表达含义的宏或常量：\n#define SERV_TYPE_SET 1\n#define SERV_TYPE_QUERY 4\n#define ADULT_AGE 18\n\nint currentType = psInParam-&gt;GetValue(\"servType\");\n\nif (currentType == SERV_TYPE_SET) {\n    ...\n} else if (currentType == SERV_TYPE_QUERY) {\n    ...\n} else {\n    ...\n}\n\nif (age &gt;= ADULT_AGE) {\n    ... // 执行某些操作\n} else {\n    ... // 执行另外的某些操作\n}\n\n如下代码的修改有两个好处：\n1.不会出错；\n2.如果版本号要修改，修改一次即可：\n// 为字符串常量（表示版本号）重定义符号常量\n#define    VERSION    \"V100R011C10\"\nbCond = (strncmp(gSrcDataVer, VERSION, strlen(VERSION)) == 0);",
					"badExample": "如下示例代码中，使用了难以理解的常量：\nint currentType = psInParam-&gt;GetValue(\"servType\");\n// 下面使用的数字，不容易理解其具体含义\nif (currentType == 1) {\n    ...\n} else if (currentType == 4) {\n    ...\n} else {\n    ...\n}\n\nif (age &gt;= 18) {\n    ... // 执行某些操作\n} else {\n    ... // 执行另外的某些操作\n}\n\n如下示例代码中的问题在于计算长度时strlen(\"V100R01C10\")中，字符串遗漏了一个’1’：\nbCond = (strncmp(gSrcDataVer, \"V100R011C10\", strlen(\"V100R01C10\")) == 0);",
					"recommend": "对于单点使用的难以理解的常量，按需增加注释说明。对于\n多处使用的难以理解的常量，应该定义宏或 const 变量，并通过符号命名自注释 。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": false
				},
				{
					"name": "G.FMT.04 一行只有一条语句【c】",
					"language": "c",
					"id": "51c73d310fef11ed9cc184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "一行只写一条语句。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "一行只写一条语句。\n例：\n\nint Foo(void)\n{\n    int a = 10; // 符合\n\n    for (int i = 0; i &lt; CNT; i++) { // 符合: 这里有分号，但并不是语句\n        Bar();  // 符合\n    }\n}",
					"badExample": "一行只写一条语句。\n例：\n\nint Foo(void)\n{\n    if (cond) { Func1(); } else { Func2(); } // 不符合： 一行包含两个复合语句\n\n    ...\n}",
					"recommend": "将语句拆分到多行",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.10 指针类型\"*\"跟随变量或者函数名【c】",
					"language": "c",
					"id": "51c73d330fef11edbd9284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "声明或定义指针变量或者返回指针类型函数时，”*“ 应该靠右跟随。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "int *p1;  // 符合\n\nstruct Foo *CreateFoo(void); // 符合: \"*\"跟随函数名\n\n下列情况需要特别注意：\n\n当”*“与变量或函数名之间有其他修饰符，无法跟随时，此时也不要跟随修饰符\nchar * const VERSION = \"V100\";    // 符合: 当有 const 修饰符时，\"*\"两边都有空格\nint Foo(const char * restrict p); // 符合: 当有 restrict 修饰符时，\"*\"两边都有空格\n任何时候 “*“ 不要紧跟 const 或 restrict 关键字。\n当右侧没有变量或函数名时，”*“ 可以跟随类型\nsz = sizeof(int*); // 符合：右侧没有变量，\"*\"跟随类型",
					"badExample": "int* p2;  // 不符合\nint*p3;   // 不符合：两边都没空格\nint * p4; // 不符合：两边都有空格",
					"recommend": "指针类型\"*\"按要求跟随名称或类型",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.13 所有#else、#elif、#endif和与之对应的#if、#ifdef、#ifndef预处理指令应出现在同一文件中【c】",
					"language": "c",
					"id": "51c73d350fef11edb7ef84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "当使用多个文件来构成这些预处理块时，难以直观发现代码块的关联，增加了阅读和维护的复杂度，从而更容易产生错误。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "如下代码示例中，在相同文件中闭合预处理块：\n\n// sample.h 开始\n#if defined(__VXWORKS__)    // 在相同文件中闭合该预处理块\n#include \"vx_config.h\"\n#endif\n// sample.h 结束",
					"badExample": "如下代码示例中，未在相同文件中闭合预处理块：\n\n// sample.h 开始\n#if defined(__VXWORKS__)  // 未在相同文件中闭合该预处理块\n#include \"vx_config.h\"\n\n\n// 这里结束前，本应当有 #endif 与前面的 #if defined 形成闭合\n// sample.h 结束",
					"recommend": "预处理指令在同一个文件中闭合",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FUD.02 设计函数时，优先使用返回值而不是输出参数【c】",
					"language": "c",
					"id": "51c764370fef11ed9e2984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "使用返回值而不是输出参数，可以提高可读性，并且通常能够提供相同或更优的性能。\n\n如：函数名为 GetXxx、FindXxx 或直接用名词作函数名的函数，直接返回对应对象，可读性更好。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "int GetValue()\n{\n    return 1;\n}",
					"badExample": "void GetValue(int *x) // 不符合\n{\n    *x = 1;\n}",
					"recommend": "使用返回值",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FUU.01 处理函数的返回值【c】",
					"language": "c",
					"id": "51c764390fef11edadf784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "函数通常通过返回值返回数据或执行结果，调用者应该在函数调用之后，对返回数据、执行结果进行有效、正确的合法性检查和处理。\n\n如果调用者有意不处理返回值，在经过充分考虑之后，可用(void)显式忽略掉。\n\n注意，当函数返回值被大量的显式(void)忽略掉时，应当考虑函数返回值的设计是否合理。\n如果所有调用者都不关注函数返回值时，请将函数设计成void类型。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "char *p = (char *)malloc(SOME_SIZE);\nif (p == NULL) {    // 符合: 对返回数据进行合法性检查\n    ...\n    return ...;\n}\n// 符合: 此处符合可省略memset_s返回值检查的例外场景，可以显式忽略掉返回值的检查\n(void)memset_s(p, SOME_SIZE, 0, SOME_SIZE);",
					"badExample": "char *p = (char *)malloc(SOME_SIZE);    // 不符合: 未检查返回值 p 的合法性\nmemset_s(p, SOME_SIZE, 0, SOME_SIZE);   // 不符合: memset_s 返回值未处理",
					"recommend": "对返回值进行处理，或者使用(void)强转明确忽略返回值",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CTL.07 switch语句要有default分支——没有default分支【c】",
					"language": "c",
					"id": "51c7643b0fef11edb6d784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "大部分情况下，switch语句中要有default分支，保证在遗漏case标签处理时能够有一个缺省的处理行为。本规范要求统一将default分支放到语句块的最后位置。",
					"systemTag": "clangtidy",
					"goodExample": "【例外】\n\n如果switch条件变量是枚举类型，并且 case分支覆盖了所有取值，则可以不要求有default分支。\n\ntypedef enum {\n    RED,\n    GREEN,\n    BLUE\n} Color;\n\nColor color;\n...\n// 因为switch条件变量是枚举值，这里可以不用加default处理分支\nswitch (color) {\n    case RED:\n        DoRedThing();\n        break;\n    case GREEN:\n        DoGreenThing();\n        break;\n    case BLUE:\n        DoBlueThing();\n        ...\n        break;\n}\n现代编译器都具备检查是否在switch语句中遗漏了某些枚举值的case分支的能力，会有相应的warning3。",
					"badExample": "switch (x) { // 不符合\n    case 1:\n      break;\n    case 2:\n      break;\n  }\n\n\n    switch (x) {\n        case 1:\n            break;\n        default: // 不符合\n            break;\n        case 2:\n            break;\n    }",
					"recommend": "添加default分支，或者将default分支移到最后",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.09 case/default 语句相对 switch 缩进一层【c】",
					"language": "c",
					"id": "51c7643d0fef11edaffd84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "合理的缩进使代码块具有层次感，提升可读性。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "switch (var) {\n    case 0:             // 符合: 缩进\n        DoSomething1(); // 符合: 缩进\n        break;\n    case 1: {           // 符合: 带大括号格式\n        DoSomething2();\n        break;\n    }\n    default:\n        break;\n}",
					"badExample": "switch (var) {\ncase 0:             // 不符合：case 未缩进\n    DoSomething();\n    break;\n...\ndefault:            // 不符合：default 未缩进\n    break;\n}",
					"recommend": "按要求进行缩进",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRE.01 使用函数代替函数式宏【c】",
					"language": "c",
					"id": "51c7643f0fef11eda73c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "定义函数式宏前，应考虑能否用函数替代。对于可替代场景，建议用函数替代宏。\n\n函数式宏的缺点如下：\n\n函数式宏缺乏类型检查，不如函数调用检查严格。参见示例代码。\n宏展开时宏参数不求值，可能会产生非预期结果。参见规则G.PRE.02 定义宏时，要使用完备的括号和规则G.PRE.04 禁止把带副作用的表达式作为参数传递给函数式宏。\n宏没有独立的作用域，跟控制流语句配合时，可能会产生如规则G.PRE.03 包含多条语句的函数式宏的实现语句必须放在 do-while(0) 中描述的非预期结果。\n宏的技巧性太强，例如#的用法和无处不在的括号，影响可读性。\n在特定场景下必须用特定编译器对宏的扩展，如 gcc 的 statement expression，可移植性也不好。\n宏在预编译阶段展开后，在其后编译、链接和调试时都不可见；而且包含多行的宏会展开为一行。函数式宏难以调试、难以打断点，不利于定位问题。\n对于包含大量语句的宏，在每个调用点都要展开。如果调用点很多，会造成代码空间的膨胀。\n函数式宏缺乏类型检查的示例代码：\n\n#define MAX(a, b) (((a) &lt; (b)) ? (b) : (a))\n\nint Max(int a, int b)\n{\n    return (a &lt; b) ? b : a;\n}\n\nvoid TestMacro(void)\n{\n    unsigned int a = 1;\n    int b = -1;\n\n    (void)printf(\"MACRO: max of a(%u) and b(%d) is %d\\n\", a, b, MAX(a, b));\n    (void)printf(\"FUNC : max of a(%u) and b(%d) is %d\\n\", a, b, Max(a, b));\n}\n上面的示例代码由于宏缺乏类型检查，MAX中的a和b的比较提升为无符号数的比较，结果是a &lt; b。输出结果是：\n\nMACRO: max of a(1) and b(-1) is -1\nFUNC : max of a(1) and b(-1) is 1\n函数没有宏的上述缺点。但是，函数相比宏，最大的劣势是执行效率不高（增加函数调用的开销和编译器优化的难度）。\n\n为此，C99标准引入了内联函数（gcc在标准之前就引入了内联函数）。\n\n内联函数跟宏类似，也是在调用点展开。不同之处在于内联函数是在编译时展开。\n\n内联函数兼具函数和宏的优点：\n\n内联函数/函数执行严格的类型检查。\n内联函数/函数的参数求值只会进行一次。\n内联函数就地展开，没有函数调用的开销。\n内联函数比函数优化得更好。\n对于性能要求高的产品代码，可以考虑用内联函数代替函数式宏。\n\n函数和内联函数不能完全替代函数式宏，函数式宏在某些场景更适合。比如，在日志记录场景下，使用带可变参和默认参数的函数式宏更方便：\n\nint ErrLog(const char *file, unsigned long line, const char *fmt, ...);\n#define ERR_LOG(fmt, ...) ErrLog(__FILE__, __LINE__, fmt, ##__VA_ARGS__)",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "int Max(int a, int b)\n{\n    return (a &lt; b) ? b : a;\n}",
					"badExample": "#define MAX(a, b) (((a) &lt; (b)) ? (b) : (a))",
					"recommend": "将函数式宏修改为函数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": false
				},
				{
					"name": "G.FMT.01 非纯ASCII码源文件使用 UTF-8 编码【c】",
					"language": "c",
					"id": "51c764410fef11eda01484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "对于非纯 ASCII 源文件，使用 UTF-8 格式。\n请正确配置你的编辑器。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "",
					"recommend": "使用UTF-8编码格式",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": false
				},
				{
					"name": "G.EXP.03 含有变量自增或自减运算的表达式中禁止再次引用该变量【c】",
					"language": "c",
					"id": "51c764430fef11edad6a84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "含有变量自增或自减运算的表达式中，如果再引用该变量，其结果在C语言标准中未明确定义。不同编译器或者同一个编译器不同版本实现可能会不一致。\n\n为了更好的可移植性，不应对标准未定义的运算次序做任何假设。\n\n注意，运算次序的问题不能使用括号来解决，因为这不是优先级的问题。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "x = b[i] + i;\ni++; // 符合: 单独一行\n函数参数：\n\ni++; // 符合: 单独一行\nx = Func(i, i);",
					"badExample": "x = b[i] + i++; // 不符合： b[i]运算跟 i++，先后顺序并不明确\n正确的写法是将自增或自减运算单独放一行：\n\nFunc(i++, i); // 不符合： 传递第2个参数时，不确定自增运算有没有发生\n正确的写法：",
					"recommend": "自增或自减运算提到表达式之外",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.DCL.01 不要声明或定义保留的标识符【c】",
					"language": "c",
					"id": "51c764450fef11edae2d84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "如果声明或者定义了一个保留的标识符，那么程序的行为是未定义的。\n\nC11标准7.1.3说明：\n1、双下划线开头，或下划线加一个大写字母开头的所有标识符始终保留使用；\n2、除label名字和结构体、联合的成员外，其他以下划线开头的标识符都在文件范围内有效；\n3、C标准库中已经定义的标识符均保留其用途；\n4、errno和其他C标准库的外部链接标识符始终作为外部链接；\n5、C标准库中具有文件范围的标识符都保留用作宏的名字。\n\n此外，在C11标准7.31中预留了一些将来使用的标识符。\n\n作为编译器供应商或标准库程序员，可以使用为编译器保留的标识符。保留的标识符可以由编译器在标准库标头，或标准库标头包含的标头中定义，如在以下示例中来自glibc库实现的声明：\n\n/*\n * The following declarations of reserved identifiers exist in the glibc\n * implementation of &lt;stdio.h&gt;. The original source code may be found at:\n * https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=include/stdio.h\n */\n\n#define __need_size_t\n#include &lt;stddef.h&gt;\n// Generate a unique file name (and possibly open it).\nextern int __path_search (char *__tmpl, size_t __tmpl_len,\n              const char *__dir, const char *__pfx,\n              int __try_tempdir);",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "",
					"badExample": "#undef __LINE__               // 不符合：下划线开头\n#define _MODULE_INCLUDE_      // 不符合：下划线开头\nint errno;                    // 不符合：errno是标准库中的保留标识符\nvoid *malloc(size_t nbytes);  // 不符合：malloc是标准库中的保留标识符\n#define SIZE_MAX 80           // 不符合：SIZE_MAX是标准库中的保留宏定义",
					"recommend": "修改标识符名称",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.VAR.02 不要在子作用域中重用变量名【c】",
					"language": "c",
					"id": "51c764470fef11edabb784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "一个作用域包含另一个作用域时，不要在这两个作用域中使用相同的变量名，例如：\n\n如果某变量位于全局变量的子作用域内，则这个变量不应与全局变量重名。\n语句块中定义的变量不能与包含该语句块的任何块中定义的变量重名。\n重用变量名会使程序员对正在修改哪个变量感到困惑。此外，如果变量名被重用，则说明该变量名可能太通用，应使用更具有描述性的变量名。",
					"systemTag": "clangtidy",
					"goodExample": "如下代码示例中，使用了不同的变量名：\n\n#define MAX_MESSAGE_LEN 100\n#define CUSTOMIZED_SIZE 80\n\nvoid Func(const char *str)\n{\n    char message[MAX_MESSAGE_LEN];\n    ...\n    if (str != NULL) {\n        char msg[CUSTOMIZED_SIZE];\n        ...\n        int ret = sprintf_s(msg, sizeof(msg), \"Error: %s\\n\", str);\n        ...\n    }\n    ...\n}\n\nint main(void)\n{\n    ...\n    Fun(\"some error\");\n\n    return 0;\n}",
					"badExample": "如下代码示例中，在Func()内声明了数组变量message，并且在if语句块中定义了一个与之重名的message变量，程序员可能是无意间复制了变量名到if代码块中，错误使用了MAX_MESSAGE_LEN，超出了内层局部变量message大小，存在缓冲区溢出风险。\n\n#define MAX_MESSAGE_LEN 100\n#define CUSTOMIZED_SIZE 80\n\nvoid Func(const char *str)\n{\n    char message[MAX_MESSAGE_LEN];\n    ...\n    if (str != NULL) {\n        char message[CUSTOMIZED_SIZE];   //  使用了与外层相同的变量名\n        ...\n        // MAX_MESSAGE_LEN 使用错误\n        int ret = sprintf_s(message, MAX_MESSAGE_LEN, \"Error: %s\\n\", str);\n        ...\n    }\n    ...\n}\n\nint main(void)\n{\n    ...\n    Fun(\"some error\");\n\n    return 0;\n}",
					"recommend": "重命名变量",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CTL.08 每个switch语句中至少有两个条件分支【c】",
					"language": "c",
					"id": "51c764490fef11ed914f84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "单个路径的选择语句更适合用if语句进行判断；且如果条件分支是布尔值，那么也不合适使用switch语句，使用if语句更合适。",
					"systemTag": "fixbotengine-cxx",
					"goodExample": "如下的代码示例写法是正确的。\n\nvoid Foo(void)\n{\n    ...\n\n    switch (lightColor) {\n        case RED:\n            lastSeconds = 30;    //  红灯保持时间\n            break;\n        case GREEN:\n            lastSeconds = 45;    // 绿灯保持时间\n            break;\n        default: // 符合: 存在两个分支\n            lastSeconds = 3;    // 除了红灯和绿灯，其他（包括黄灯）保持3秒\n            break;\n    }\n}",
					"badExample": "如下的代码示例写法都是错误的。\n\nvoid Foo(void)\n{\n    ...\n    switch (color) {\n        default: // 不符合: switch是多余的\n            x = 0;\n            break;\n    }\n}\n\nvoid Foo(void)\n{\n    ...\n    switch (color) {\n        case RED:\n        default: // 不符合: switch是多余的\n            x = 0;\n            break;\n    }\n}",
					"recommend": "switch至少要有两个分支，单分支的情况可以改为if语句",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FUU.17 禁止外部可控数据作为dlopen/LoadLibrary等模块加载函数的参数【C】",
					"language": "c",
					"id": "51c7644b0fef11eda21c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "命令注入。\n排查system/popen类函数可能存在命令注入的问题（参数为变量，且未被常量赋值）",
					"systemTag": "codemars",
					"goodExample": "正确示例1： popen的参数是常量字符串\nvoid suspectedCmdInjection_good_01(char *input)\n{\n    char *data = \"hdn.bat\";\n    popen(data);\n}\n正确示例2： 如果确实需要调用单个命令，应使用exec*函数来实现参数化调用，并对调用的命令实施白名单管理。同时应避免使用execlp、execvp、execvpe函数，因为这几个函数依赖外部的PATH环境变量。 此时，外部输入的fileName仅作为some_tool命令的参数，没有命令注入的风险。\nvoid suspectedCmdInjection_good_02()\n{\n    pid_t pid;\n    char* const envp[] = {nullptr};\n    ...\n    std::string fileName = GetDirNameFromRemote();\n    ...\n    pid = fork();\n    if (pid &lt; 0) {\n      ... // 错误处理\n    } else if (pid == 0) {\n      // 使用some_tool对指定文件进行加工\n      execle(\"/bin/some_tool\", \"some_tool\", fileName.c_str(), nullptr, envp);\n      _Exit(-1);\n    }\n}",
					"badExample": "错误示例1： 将外部变量直接传给popen\nvoid suspectedCmdInjection_bad_01(char *input)\n{\n    // POTENTIAL FLAW: Suspected command injection\n    popen(input);\n}\n错误示例2： 禁止在函数execl中使用命令解析器/bin/sh\nvoid suspectedCmdInjection_bad_02()\n{\n    std::string cmd = GetDirNameFromRemote();\n    // POTENTIAL FLAW: Suspected command injection\n    execl(\"/bin/sh\", \"sh\", \"-c\", cmd.c_str(), nullptr);\n}",
					"recommend": "外部变量作为system、popen、VOS_System前，需经硬编码或者白名单校验；\n使用exec系列函数来避免命令注入时，注意exec系列函数中的path、file参数禁止使用命令解析(如/bin/sh)\n",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.03 调用格式化输入/输出函数时，使用有效的格式字符串【C】",
					"language": "c",
					"id": "51c78b440fef11ed8fb084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "格式化字符个数与变参个数不一致。\n调用格式化函数时，Format中参数的个数必须与实际参数个数一致。",
					"systemTag": "codemars",
					"goodExample": "正确示例： 格式化字符个数与变参个数一致\nvoid formatString_good_1()\n{\n    char strDest[32] = {0};\n    unsigned long long total = 52;\n    int ret = sprintf_s(strDest, sizeof(strDest), \"Total %llu\", total);\n}",
					"badExample": "错误示例： 格式化字符个数为4个，变参个数为1，不一致\nvoid formatString_bad_2()\n{\n    char strDest[32] = {0};\n    unsigned long long total = 52;\n    // 格式化字符个数与变参个数不一致\n    int ret = sprintf_s(strDest, sizeof(strDest), \"Total %llu %s %s %s\", total);\n}  ",
					"recommend": "确保format函数参数个数和实际参数个数一致",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.03 调用格式化输入/输出函数时，使用有效的格式字符串——格式化类型不匹配【c】",
					"language": "c",
					"id": "51c78b460fef11ed924c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "格式化输入/输出函数（如fscanf()/fprintf()及相关函数）在format字符串控制下进行转换、格式化、打印其实参。\n\n在创建格式化字符串时的常见错误包括：\n\n1. format中参数个数与实参个数不一致；\n2. 使用无效的转换指示符；\n3. 使用与转换指示符不兼容的标志字符；\n4. 使用与转换指示符不兼容的长度修饰符；\n5. format中转换指示符与实参类型不匹配；\n6. 使用实参指定宽度或者精度时，实参的类型不是int类型；\n\n不要为格式化输入/输出函数提供未知的或者无效的转换规格，以及标志字符、精度、长度修饰符、转换指示符的无效组合。同样，不要提供与格式化字符串中的转换指示符类型不匹配的实参。这可能会使程序产生未定义行为。",
					"systemTag": "codemars",
					"goodExample": "正确的做法是确保printf()函数的实参匹配format的转换指示符。\n\nvoid Foo(void)\n{\n    const char *infoMsg = \"Information seed to user.\";\n    int infoLevel = 4;\n\n    ...\n\n    printf(\"infoLevel: %d, infoMsg: %s\\n\", infoLevel, infoMsg);\n\n    ...\n}",
					"badExample": "如下代码示例中，printf()的实参infoLevel类型与对应的转换指示符’s’不匹配，正确的转换指示符要使用’d’。同样，实参infoMsg类型与对应的转换指示符’d’不匹配，正确的转换指示符要使用’s’。\n这些用法会使程序产生未定义行为，比如：printf()将把infoLevel实参解释为指针，试图从infoLevel包含的地址中读取一个字符串，从而发生非法访问。\n\nvoid Foo(void)\n{\n    const char *infoMsg = \"Information seed to user.\";\n    int infoLevel = 4;\n\n    ...\n\n    printf(\"infoLevel: %s, infoMsg: %d\\n\", infoLevel, infoMsg);\n\n    ...\n}",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.12 正确设置安全函数中的destMax参数——检查destMax参数是否设置正确【C】",
					"language": "c",
					"id": "51c78b480fef11ed9b5584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "安全函数的destMax设置错误。\n排查安全函数中的destMax参数是否被正确设置。",
					"systemTag": "codemars",
					"goodExample": "正确示例： destMax的长度等于destBuff的实际长度BUFF_SIZE\nvoid test(BYTE *input, size_t inputsize)\n{\n    BYTE *destBuff = new BYTE[BUFF_SIZE] ;    \n    BYTE *src =input;\n    errno_t ret = 0;\n    size_t srcLen = strlen(src);\n    ret = memcpy_s(destBuff, BUFF_SIZE, src, srcLen);  // ok\n}",
					"badExample": "错误示例： destMax不允许使用立即数；destMax的长度不是destBuff的实际长度BUFF_SIZE\nvoid test(BYTE *input, size_t inputsize)\n{\n    BYTE *destBuff = new BYTE[BUFF_SIZE] ;    \n    BYTE *src = input;\n    errno_t ret = 0;\n    size_t srcLen = strlen(src);\n    /* POTENTIAL FLAW:destMax does not allow the number */\n    ret = memcpy_s(destBuff, 100, src, srcLen);  // error\n    /* POTENTIAL FLAW:destMax is not the length of the dynamic application of destBuff */\n    ret = memcpy_s(destBuff, srcLen, src, srcLen);  // error\n    ret = memcpy_s(destBuff, BUFF_SIZE, src, srcLen);  // ok\n}",
					"recommend": "安全函数的destMax参数设置应当准确、有效。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.VAR.05 指向资源句柄或描述符的变量，在资源释放后立即赋予新值【C】",
					"language": "c",
					"id": "51c78b4a0fef11eda39884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "指向资源句柄或描述符的变量，在资源释放后立即赋予新值。\n指向资源句柄或描述符的变量包括指针、文件描述符、socket描述符以及其它指向资源的变量。以指针为例，当指针成功申请了一段内存之后，在这段内存释放以后，如果其指针未立即设置为NULL，也未分配一个新的对象，那这个指针就是一个悬空指针。如果再对悬空指针操作，可能会发生重复释放或访问已释放内存的问题，造成安全漏洞。消减该漏洞的有效方法是将释放后的指针立即设置为一个确定的新值，例如设置为NULL。对于全局性的资源句柄或描述符，在资源释放后，应该马上设置新值，以避免使用其已释放的无效值；对于只在单个函数内使用的资源句柄或描述符，应确保资源释放后其无效值不被再次使用。",
					"systemTag": "codemars",
					"goodExample": "正确示例1：\nvoid test_good1(int a)\n{\n    int num = 0;\n    char* msg = NULL;\n    msg = (char*)malloc(10);\n    if (msg = NULL) {\n        return;\n    }\n    if (a &lt; 0) {\n        free(msg);\n        msg = NULL; // free后立即重新赋值\n        return; // 分支结束\n    }\n    num = 10;\n}\n正确示例2： 全局指针MSG在free之后重新赋值\n// 全局变量释放后必须赋予新值\nchar* MSG = (char*)malloc(1000);\nvoid test_bad3(int a)\n{\n   int num = 0;\n   if (a &lt; 0) {\n       free(MSG);\n       MSG = NULL;\n       return;\n   }\n   num = 10;\n   /* POTENTIAL FLAW:msg is not set NULL after free */\n}",
					"badExample": "错误示例1： 指针msg被free之后未被重新赋值便被使用\n//free 指针之后使用\nvoid test_bad1(int a)\n{\n    int num = 0;\n    char* msg = NULL;\n    msg = (char*)malloc(10);\n    if (msg = NULL) {\n        return;\n    }\n    if (a &lt; 0) {\n        free(msg);\n        /* POTENTIAL FLAW: msg is not set NULL after free */\n        func(msg);\n        return; // 分支结束\n    }\n    num = 10;\n}\n错误示例2： 全局指针MSG在free之后没有重新赋值\n// 全局变量释放后必须赋予新值\nchar* MSG = (char*)malloc(1000);\nvoid test_bad3(int a)\n{\n   int num = 0;\n   if (a &lt; 0) {\n       free(MSG);\n       return;\n   }\n   num = 10;\n   /* POTENTIAL FLAW:msg is not set NULL after free */\n}",
					"recommend": "对于局部变量，调用closesocket、free、close、delete等函数释放资源后，需要重新赋值后再继续使用；对于全局变量，释放后在函数结束前需要被重新赋值",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.AST.04 禁止在断言内改变运行环境【C】",
					"language": "c",
					"id": "51c78b4c0fef11edbcb384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "在断言内改变运行环境。\n具有其他作用的表达式被用作断言的条件表达式的一些情况。此类情况很危险，因为断言经常在生产版本中进行编译，这意味着程序在调试模式（存在断言）和生产模式下的行为不同。包括：赋值（例如 =、+=、-= 或 &lt;&lt;=）；递增和递减（例如 ++ 或 —）；修改堆（例如 Assert(new xxx)）",
					"systemTag": "codemars",
					"goodExample": "",
					"badExample": "错误示例： 禁止在断言中进行赋值操作\nvoid Case01Bad()\n{\n    int i = 0；\n    int j = 1;\n    /* POTENTIAL FLAW: 在断言中赋值 */\n    ASSERT(i = j);\n}",
					"recommend": "调用ASSERT，入参中不能使用赋值（例如 =、+=、-= 或&lt;&lt;=）、递增和递减（例如++或—）、修改堆（例如 ASSERT(new xxx)）",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.ARR.03 禁止通过对指针变量进行sizeof操作来获取数组大小【C】",
					"language": "c",
					"id": "51c78b4e0fef11ed934384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "",
					"systemTag": "codemars",
					"goodExample": "正确示例： 如下代码示例中，将 sizeof(buffer) 修改为申请的缓冲区大小\nvoid sizeof_good()\n{\n    char path[MAX_PATH];\n    char *buffer = (char *)malloc(SIZE);\n    memset(path, 0, sizeof(path));\n    memset(buffer, 1, SIZE); // 使用申请的缓冲区大小\n}",
					"badExample": "错误示例： 如下代码示例中，buffer和path分别是指针和数组，程序员想对这2个内存进行清0操作，但由于程序员的疏忽，将内存大小误写成了 sizeof(buffer) ，与预期不符。\nvoid sizeof_bad()\n{\n    char path[MAX_PATH];\n    char *buffer = (char *)malloc(SIZE);\n\n    memset(path, 0, sizeof(path));\n    // sizeof与预期不符，其结果为指针本身的大小而不是缓冲区大小\n    memset(buffer, 1, sizeof(buffer));\n}",
					"recommend": "不要对指针变量进行sizeof操作",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.STR.01 确保字符串存储有足够的空间容纳字符数据和null结束符【C】",
					"language": "c",
					"id": "51c78b500fef11edb3ef84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "字符串操作造成的缓冲区溢出。\n检查itoa/ltoa/realpath长度设置不正确的场景。",
					"systemTag": "codemars",
					"goodExample": "正确示例1： 目标存储空间预留足够长度，或使用安全函数实现整数转换为10进制形式的字符串\nvoid stringOverflow_good01()\n{\n    int num = 12;\n    char str[16] = {0}; // 有时会考虑字节对齐定义冗余的长度，这里选择了16\n    itoa(num, str, 10); \n}\n\nvoid stringOverflow_good02()\n{\n  int num = 12;\n  char str[16] = {0}; // 有时会考虑字节对齐定义冗余的长度，这里选择了16\n  int ret = sprintf_s(str, sizeof(str), \"%d\", num);\n}\n正确示例2： realpath第二个参数的缓冲区大小为系统提供的PATH_MAX或_PC_PATH_MAX\nvoid stringOverflow_good(char* path)\n{\n    char* resolvedPath = new char(PATH_MAX);\n    realpath(path, resolvedPath); // realpath函数的存储缓冲区长度是PATH_MAX\n}",
					"badExample": "错误示例1： 如下代码示例中，试图将数字转为字符串，但是目标存储空间的预留长度不足\nvoid stringOverflow_bad01()\n{\n    int num = 12;\n    char str[8] = {0};\n    itoa(num, str, 10); // 10进制整数的最大存储长度是12个字节\n}\n错误示例2： realpath第二个参数的缓冲区大小必须为系统提供的PATH_MAX或_PC_PATH_MAX，不能使用自定义的宏\nvoid stringOverflow_bad01(char* path)\n{ \n    char* resolvedPath = new char(100);\n    /* POTENTIAL FLAW:The memory space allocated by resolvedPath is not defined by the PATH_MAX constant, or is configured by the _PC_PATH_MAX system value, and may overflow. */\n    realpath(path, resolvedPath); // realpath函数的存储缓冲区长度是PATH_MAX\n}",
					"recommend": "1.使用itoa/ltoa函数需确保目的缓冲区有足够的长度存储转换后的字符串，防止溢出；\n2.使用realpath函数的第二个参数应为系统提供的PATH_MAX或_PC_PATH_MAX，不能使用自定义的宏。 linux环境：PATH_MAX的定义在/usr/include/linux/limits.h；windows环境：MAX_PATH的定义在minwindef.h (visual studio 2017)",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.11 必须检查安全函数返回值，并进行正确的处理【C】",
					"language": "c",
					"id": "51c78b520fef11ed9f0284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "安全函数未检查返回值。\n原则上，如果使用了安全函数，需要进行返回值检查。如果返回值表示错误，那么本函数一般情况下应该立即返回，不能继续执行。",
					"systemTag": "codemars",
					"goodExample": "正确示例： 检查了安全函数memcpy_s返回值\nBOOL ParseBuff(BYTE* destBuff, size_t destMax, BYTE* src, size_t srcLen)\n{\n    errno_t err = EOK;\n    if (destBuff == NULL || destMax == 0) {\n        return FALSE; // 返回失败\n    }\n    err = memcpy_s(destBuff, destMax, src, srcLen);\n    if (err != EOK) {\n        Log(\"memcpy_s failed, err = %d\\n\", err);\n        return FALSE; // 返回失败\n    }\n    return TRUE;\n}",
					"badExample": "错误示例： 安全函数memcpy_s可能拷贝失败，未检查返回值\nBOOL ParseBuff(BYTE* destBuff, size_t destMax, BYTE* src, size_t srcLen)\n{\n    errno_t err = EOK;\n    if (destBuff == NULL || destMax == 0) {\n        return FALSE; // 返回失败\n    }\n    memcpy_s(destBuff, destMax, src, srcLen); // 未检查返回值\n    return TRUE;\n}",
					"recommend": "需要对安全函数的返回值进行检查，并在返回错误状态时，做出相应的错误处理。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.MEM.04 内存中的敏感信息使用完毕后立即清0【C】",
					"language": "c",
					"id": "51c78b540fef11ed950884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "内存中的敏感信息使用完毕后未清零。\n内存中的敏感信息使用完毕后立即清零，关键字包括password、psw、pwd、passwd",
					"systemTag": "codemars",
					"goodExample": "正确示例： 内存中的敏感信息psw使用完毕后进行了清零\nvoid test_good1()\n{\n    char psw[10] = getPassword();\n    func1(psw);\n    memset_s(psw, 10, 0, 10);\n}",
					"badExample": "错误示例： 内存中的敏感信息psw使用完毕后没有立即清零，可能会被泄露\nvoid tes_bad1()\n{\n    char psw[10] = getPassword();\n    func1(psw);\n    /* POTENTIAL FLAW: the local variable 'psw' is sensitive information, it should be cleard by memset_s or VOS_memset_s\n    before function end. */\n}",
					"recommend": "内存中的敏感信息使用完毕后立即清零，关键字包括password、psw、pwd、passwd",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.MEM.01 内存申请前，必须对申请内存大小进行合法性校验【C】",
					"language": "c",
					"id": "51c78b560fef11eda14484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "未对申请内存大小进行合法性校验。\n申请内存的大小没有经过合法性校验。",
					"systemTag": "codemars",
					"goodExample": "正确示例： 内存大小size在使用前进行了校验\nint good_1(int size)    \n{    \n    if(size &lt;= 0)    \n    {    \n       // error\n       return;      \n    }    \n    char *msg = (char *)malloc(size);      \n}  ",
					"badExample": "错误示例： 来自函数入参的内存大小size在使用前没有进行校验\n//申请大小为函数入参\nint bad_1(int size)    \n{      \n    // POTENTIAL FLAW:Does not verify the memory size of the application.\n    char *msg = (char *)malloc(size);      \n}  ",
					"recommend": "申请内存大小之前，对申请大小的变量做校验",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.21 禁止使用内存操作类不安全函数【C】",
					"language": "c",
					"id": "51c7b2510fef11edb5a084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "使用内存操作类危险函数。\nC语言标准的许多函数，要求程序员提供足够大的数组（内存空间）以容纳函数产生的结果。但是根据历史漏洞分析，程序员在使用一些内存操作类函数时，容易因使用不当而造成缓冲区溢出等安全漏洞。因此本规范中禁止使用内存操作类不安全函数。为避免遗漏对不安全函数的检查，同时禁止封装这些不安全函数。\n基于缓冲区溢出漏洞触发的历史情况分析并统计，发现有很大一部分缓冲区溢出漏洞是因为调用了这些内存操作类函数但未考虑目标缓冲区大小而导致的。\n以下列出了部分内存操作类不安全函数：\n- 内存拷贝函数：memcpy(), wmemcpy(), memmove(), wmemmove()\n- 内存初始化函数：memset()\n- 字符串拷贝函数：strcpy(), wcscpy(), strncpy(), wcsncpy()\n- 字符串拼接函数：strcat(), wcscat(), strncat(), wcsncat()\n- 字符串格式化输出函数：sprintf(), swprintf(), vsprintf(), vswprintf(), snprintf(), vsnprintf()\n- 字符串格式化输入函数：scanf(), wscanf(), vscanf(), vwscanf(), fscanf(), fwscanf(), vfscanf(),vfwscanf(), sscanf(), swscanf(), vsscanf(), vswscanf()\n- stdin流输入函数：gets()",
					"systemTag": "codemars",
					"goodExample": "正确示例： 调用安全函数memcpy_s\nvoid riskyFunc_good(char* src)\n{\n    char dest[16] = {0};\n    // 推荐使用安全函数，增加destMax参数，对目的缓冲区做保护\n    memcpy_s(dest, sizeof(dest), p, strlen(src));\n}",
					"badExample": "错误示例： 调用危险函数memcpy\nvoid riskyFunc_bad(char* src)\n{\n    char dest[16] = {0};\n    // 使用危险函数，目的缓冲区未做保护，若src的长度大于16，则会造成dest拷贝越界\n    memcpy(dest, p, strlen(src));\n}",
					"recommend": "使用安全函数替代危险函数。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.12 正确设置安全函数中的destMax参数——检查destMax和count参数【C】",
					"language": "c",
					"id": "51c7b2530fef11ed873e84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "安全函数的缓冲区溢出问题。\n检查memcpy_s/strcpy_s等安全函数因destMax或count大小不正确而引起的目的缓冲区写越界或源缓冲区读越界问题。",
					"systemTag": "codemars",
					"goodExample": "正确示例： destMax的长度等于count的长度\n#define COPY_SIZE 16\nvoid Warning_MemCpy_Safe2_good()\n{\n    char dest[16] = { 0 };\n    char src[24] = { 0 };\n    int ret = memcpy_s(dest, sizeof(dest), src, COPY_SIZE); \n}",
					"badExample": "错误示例： destMax的长度为16，count的长度为20，dest、destMax和src合法且count大于destMax，后果是根据destMax长度dest指向的内存区域被清0\n#define COPY_SIZE 20\nvoid Warning_MemCpy_Safe2_Bad()\n{\n    char dest[16] = { 0 };\n    char src[24] = { 0 };\n    /*POTENTIAL FLAW: count &gt; destMax */\n    int ret = memcpy_s(dest, sizeof(dest), src, COPY_SIZE);  // error\n}",
					"recommend": "正确设置memcpy_s、strcpy_s等函数的destMax和count参数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.INT.03 确保除法和余数运算不会导致除零错误(被零除)【C】",
					"language": "c",
					"id": "51c7b2550fef11eda97384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "除零错误。\n整数的除法运算或取余运算的除数为0会导致程序产生未定义的行为。如果涉及到除法或者取余运算，必须确保除数不为0。",
					"systemTag": "codemars",
					"goodExample": "正确示例： 除数num来自入参可能为0，在作为除数前进行了校验\n\nvoid Good(int num)\n{\n    if (num == 0) {\n        return;\n    }\n    size_t b = 1000 / num; \n    size_t c = 1000 % num; \n}",
					"badExample": "错误示例： 除数num来自入参，可能为0，需要在作为除数前校验\n\nvoid Bad(int num)\n{\n    // POTENTIAL FLAW: 错误\n    size_t b = 1000 / num; //a可能是0\n    size_t c = 1000 % num; //a可能是0\n}",
					"recommend": "如果除数为外部变量，则需要在使用前进行非零校验",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.INT.04 整型表达式比较或赋值为一种更大类型之前必须用这种更大类型对它进行求值【C】",
					"language": "c",
					"id": "51c7b2570fef11ed885084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "类型转换时导致的整形溢出。\n由于整数在运算过程中可能出现有符号整数溢出、无符号整数回绕等问题，当运算结果赋值给比它更大的类型，或者与比它更大的类型进行比较时，可能会导致实际结果与预期结果不符。\n如果将涉及某个操作的整数表达式与较大的整数大小进行比较或分配给较大的整数，则该整数表达式应该通过显式转换其中一个操作数来以较大类型的大小进行计算。",
					"systemTag": "codemars",
					"goodExample": "正确示例： 当组合表达式的运算结果赋值给比它更大类型，或者与比它更大类型进行运算时，应显式转换其中一个操作数为较大的类型\nint main(int argc, char *argv[])\n{\n    unsigned int a = 0x10000000;\n    unsigned long long b = (unsigned long long )a * 0xab; // 输出为b = AB0000000\n    printf(\"b = %llX\\n\", b);\n    return 0;\n}",
					"badExample": "错误示例： 当运算结果赋值给比它更大的类型，或者与比它更大的类型进行比较时，可能会导致实际结果与预期结果不符\nint main(int argc, char *argv[])\n{\n    unsigned int a = 0x10000000;\n    unsigned long long b = a * 0xab;\n    printf(\"b = %llX\\n\", b); // 输出为b = B0000000，与预期不符\n    return 0;\n}",
					"recommend": "当组合表达式的运算结果赋值给比它更大类型，或者与比它更大类型进行运算时，应显式转换其中一个操作数为较大的类型",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.OTH.03 禁用rand函数产生用于安全用途的伪随机数【C】",
					"language": "c",
					"id": "51c7b2590fef11ed81ca84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "rand函数产生用于安全用途的伪随机数。\n不安全随机数算法检查。检查到rand/random/CRYPT_random函数即告警。",
					"systemTag": "codemars",
					"goodExample": "正确示例： 在类Unix平台上，可以使用/dev/random文件得到随机数。需要注意的是，设备刚启动时，由于硬件输入的熵可能不足，读取该接口可能产生阻塞问题。",
					"badExample": "错误示例： 使用了不安全随机数算法rand\nvoid unsafeRand_bad_01()\n{\n    // POTENTIAL FLAW:Use unsafe rand.\n    int a = rand();\n}",
					"recommend": "1、加解密场景必须使用安全随机数（非加解密场景可按误报处理）； 2、IPSI组件的CRYPT_random，须确保开启了NIST SP 800-90A标准的DRBG后才可使用。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "Weak_Encryption【C】",
					"language": "c",
					"id": "51c7b25b0fef11edbf7784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "弱加密算法检查。",
					"systemTag": "codemars",
					"goodExample": "",
					"badExample": "错误示例： 使用了不安全的随机算法MD5、EVP_sha、xx_ecb、RSA_padding_add_XXX\nvoid weakEncryption_bad_01()\n{\n    char* ptr = xy_DES_C;\n    // POTENTIAL FLAW:Insecure algorithm 'MD5' is called. It is recommended to use strong encryption algorithm.\n    MD5(A, B, C);\n    // POTENTIAL FLAW:Insecure algorithm 'EVP_sha' is called. It is recommended to use strong encryption algorithm.\n    EVP_sha(xy_DES_C, y, z);\n    // POTENTIAL FLAW:Insecure algorithm 'xx_ecb' is called. It is recommended to use strong encryption algorithm.\n    xx_ecb(a, b, c);\n    // POTENTIAL FLAW:Insecure algorithm 'RSA_padding_add_XXX' is called. It is recommended to use strong encryption\n    // algorithm.\n    RSA_padding_add_XXX(ptr, ptr);\n}",
					"recommend": "使用安全的加密函数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.CTL.07 switch语句要有default分支——default不是最后一个分支【c】",
					"language": "c",
					"id": "51c7b25d0fef11ed857e84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": " 大部分情况下，switch语句中要有default分支，保证在遗漏case标签处理时能够有一个缺省的处理行为。本规范要求统一将default分支放到语句块的最后位置。 ",
					"systemTag": "clangtidy",
					"goodExample": " 【例外】\n\n如果switch条件变量是枚举类型，并且 case分支覆盖了所有取值，则可以不要求有default分支。\n\ntypedef enum {\n    RED,\n    GREEN,\n    BLUE\n} Color;\n\nColor color;\n...\n// 因为switch条件变量是枚举值，这里可以不用加default处理分支\nswitch (color) {\n    case RED:\n        DoRedThing();\n        break;\n    case GREEN:\n        DoGreenThing();\n        break;\n    case BLUE:\n        DoBlueThing();\n        ...\n        break;\n}\n现代编译器都具备检查是否在switch语句中遗漏了某些枚举值的case分支的能力，会有相应的warning3。 ",
					"badExample": " switch (x) { // 不符合\n    case 1:\n      break;\n    case 2:\n      break;\n  }\n\n\n    switch (x) {\n        case 1:\n            break;\n        default: // 不符合\n            break;\n        case 2:\n            break;\n    } ",
					"recommend": " 添加default分支，或者将default分支移到最后 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.11 用空格突出关键字和重要信息——二元表达式【c】",
					"language": "c",
					"id": "51c7b25f0fef11edbbff84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 空格应该突出关键字和重要信息。总体要求如下：\n\n行末不应加空格\nif, switch, case, do, while, for 等关键字之后应加空格\n小括号内部的两侧，不应加空格\n二元操作符（= + ‐ < > * / % | & ^ <= >= == !=）两侧都应加空格\n一元操作符（& * + ‐ ~ !）之后不应加空格\n三元操作符（? :）符号两侧都应加空格\n结构体中表示位域的冒号，两侧都应加空格\n前置和后置的自增、自减（++ –）和变量之间不应加空格\n结构体成员操作符（. ->）前后不应加空格\n大括号内部两侧有无空格，左右应保持一致\n逗号、分号、冒号（不含三元操作符和表示位域的冒号）紧跟前面内容无空格，其后需要空格\n函数参数列表的小括号与函数名之间不应加空格\n类型强制转换的小括号与被转换对象之间不应加空格\n数组的中括号与数组名之间不应加空格\n涉及到换行时，行末的空格可以省去\n对于大括号内部两侧的空格，建议如下：\n\n2的，大括号内部两侧建议加空格\n对于空的，或单个标识符，或单个字面常量，空格不是必须\n如：’{}’, ‘{0}’, ‘{NULL}’, ‘{“hi”}’ 等\n连续嵌套的多重括号之间，空格不是必须\n如：’{{0}}’, ‘{{ 1, 2 }}’ 等\n错误示例：’{ 0, {1}}’，不属于连续嵌套场景，而且最外侧大括号左右不一致\n注意：可在集成开发环境（IDE）和代码编辑器中设置保存文件时删除行末空格功能。 ",
					"systemTag": "clangtidy",
					"goodExample": " 变量定义\nint i = 0;               // 符合：变量初始化时，= 前后应该有空格，分号前面不要留空格\nint buf[BUF_SIZE] = {0}; // 符合：数组初始化时，大括号内空格可选\nint arr[] = { 10, 20 };  // 符合: 正常大括号内部两侧建议加空格\n指针和取地址\nx = *p;   // 符合：*操作符和指针p之间不加空格\np = &x;   // 符合：&操作符和变量x之间不加空格\nx = r.y;  // 符合：通过.访问成员变量时不加空格\nx = r->y; // 符合：通过->访问成员变量时不加空格\n操作符\nx = 0;    // 符合：赋值操作的=前后都要加空格\nx = -5;   // 符合：负数的符号之前要加空格\n++x;      // 符合：前置和后置的++/--和变量之间不要加空格\nx--;\n\nif (x && !y)       // 符合：布尔操作符前后要加上空格，！操作和变量之间不要空格\nv = w * x + y / z; // 符合：二元操作符前后要加空格\nv = w * (x + z);   // 符合：括号内的表达式前后不需要加空格\n循环和条件语句\nif (condition) { // 符合：if关键字和括号之间加空格，括号内条件语句前后不加空格\n    ...\n} else {         // 符合：else关键字和大括号之间加空格\n    ...\n}\n\n// 符合：while关键字和括号之间加空格，括号内条件语句前后不加空格\nwhile (condition) {}\n\n// 符合：for关键字和括号之间加空格，分号之后加空格\nfor (int i = 0; i < someRange; i++) {\n    ...\n}\n\nswitch (var) { // 符合: switch 关键字后面有1空格\n    case 0:    // 符合：case语句条件和冒号之间不加空格\n        ...\n        break;\n    ...\n    default:\n        ...\n        break;\n} ",
					"badExample": " 函数定义和函数调用的情况\n\nint result = Foo(arg1,arg2);\n                      ^         // 不符合： 逗号后面应该有空格\n\nint result = Foo( arg1, arg2 );\n                 ^          ^   // 不符合： 小括号内部两侧不应有空格 ",
					"recommend": " 按要求增加/减少空格 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.11 用空格突出关键字和重要信息——三元条件表达式【c】",
					"language": "c",
					"id": "51c7b2610fef11ed993d84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 空格应该突出关键字和重要信息。总体要求如下：\n\n行末不应加空格\nif, switch, case, do, while, for 等关键字之后应加空格\n小括号内部的两侧，不应加空格\n二元操作符（= + ‐ < > * / % | & ^ <= >= == !=）两侧都应加空格\n一元操作符（& * + ‐ ~ !）之后不应加空格\n三元操作符（? :）符号两侧都应加空格\n结构体中表示位域的冒号，两侧都应加空格\n前置和后置的自增、自减（++ –）和变量之间不应加空格\n结构体成员操作符（. ->）前后不应加空格\n大括号内部两侧有无空格，左右应保持一致\n逗号、分号、冒号（不含三元操作符和表示位域的冒号）紧跟前面内容无空格，其后需要空格\n函数参数列表的小括号与函数名之间不应加空格\n类型强制转换的小括号与被转换对象之间不应加空格\n数组的中括号与数组名之间不应加空格\n涉及到换行时，行末的空格可以省去\n对于大括号内部两侧的空格，建议如下：\n\n2的，大括号内部两侧建议加空格\n对于空的，或单个标识符，或单个字面常量，空格不是必须\n如：’{}’, ‘{0}’, ‘{NULL}’, ‘{“hi”}’ 等\n连续嵌套的多重括号之间，空格不是必须\n如：’{{0}}’, ‘{{ 1, 2 }}’ 等\n错误示例：’{ 0, {1}}’，不属于连续嵌套场景，而且最外侧大括号左右不一致\n注意：可在集成开发环境（IDE）和代码编辑器中设置保存文件时删除行末空格功能。 ",
					"systemTag": "clangtidy",
					"goodExample": " 变量定义\nint i = 0;               // 符合：变量初始化时，= 前后应该有空格，分号前面不要留空格\nint buf[BUF_SIZE] = {0}; // 符合：数组初始化时，大括号内空格可选\nint arr[] = { 10, 20 };  // 符合: 正常大括号内部两侧建议加空格\n指针和取地址\nx = *p;   // 符合：*操作符和指针p之间不加空格\np = &x;   // 符合：&操作符和变量x之间不加空格\nx = r.y;  // 符合：通过.访问成员变量时不加空格\nx = r->y; // 符合：通过->访问成员变量时不加空格\n操作符\nx = 0;    // 符合：赋值操作的=前后都要加空格\nx = -5;   // 符合：负数的符号之前要加空格\n++x;      // 符合：前置和后置的++/--和变量之间不要加空格\nx--;\n\nif (x && !y)       // 符合：布尔操作符前后要加上空格，！操作和变量之间不要空格\nv = w * x + y / z; // 符合：二元操作符前后要加空格\nv = w * (x + z);   // 符合：括号内的表达式前后不需要加空格\n循环和条件语句\nif (condition) { // 符合：if关键字和括号之间加空格，括号内条件语句前后不加空格\n    ...\n} else {         // 符合：else关键字和大括号之间加空格\n    ...\n}\n\n// 符合：while关键字和括号之间加空格，括号内条件语句前后不加空格\nwhile (condition) {}\n\n// 符合：for关键字和括号之间加空格，分号之后加空格\nfor (int i = 0; i < someRange; i++) {\n    ...\n}\n\nswitch (var) { // 符合: switch 关键字后面有1空格\n    case 0:    // 符合：case语句条件和冒号之间不加空格\n        ...\n        break;\n    ...\n    default:\n        ...\n        break;\n} ",
					"badExample": " 函数定义和函数调用的情况\n\nint result = Foo(arg1,arg2);\n                      ^         // 不符合： 逗号后面应该有空格\n\nint result = Foo( arg1, arg2 );\n                 ^          ^   // 不符合： 小括号内部两侧不应有空格 ",
					"recommend": " 按要求增加/减少空格 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.11 用空格突出关键字和重要信息——函数名【c】",
					"language": "c",
					"id": "51c7b2630fef11ed95a984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 空格应该突出关键字和重要信息。总体要求如下：\n\n行末不应加空格\nif, switch, case, do, while, for 等关键字之后应加空格\n小括号内部的两侧，不应加空格\n二元操作符（= + ‐ < > * / % | & ^ <= >= == !=）两侧都应加空格\n一元操作符（& * + ‐ ~ !）之后不应加空格\n三元操作符（? :）符号两侧都应加空格\n结构体中表示位域的冒号，两侧都应加空格\n前置和后置的自增、自减（++ –）和变量之间不应加空格\n结构体成员操作符（. ->）前后不应加空格\n大括号内部两侧有无空格，左右应保持一致\n逗号、分号、冒号（不含三元操作符和表示位域的冒号）紧跟前面内容无空格，其后需要空格\n函数参数列表的小括号与函数名之间不应加空格\n类型强制转换的小括号与被转换对象之间不应加空格\n数组的中括号与数组名之间不应加空格\n涉及到换行时，行末的空格可以省去\n对于大括号内部两侧的空格，建议如下：\n\n2的，大括号内部两侧建议加空格\n对于空的，或单个标识符，或单个字面常量，空格不是必须\n如：’{}’, ‘{0}’, ‘{NULL}’, ‘{“hi”}’ 等\n连续嵌套的多重括号之间，空格不是必须\n如：’{{0}}’, ‘{{ 1, 2 }}’ 等\n错误示例：’{ 0, {1}}’，不属于连续嵌套场景，而且最外侧大括号左右不一致\n注意：可在集成开发环境（IDE）和代码编辑器中设置保存文件时删除行末空格功能。 ",
					"systemTag": "clangtidy",
					"goodExample": " 变量定义\nint i = 0;               // 符合：变量初始化时，= 前后应该有空格，分号前面不要留空格\nint buf[BUF_SIZE] = {0}; // 符合：数组初始化时，大括号内空格可选\nint arr[] = { 10, 20 };  // 符合: 正常大括号内部两侧建议加空格\n指针和取地址\nx = *p;   // 符合：*操作符和指针p之间不加空格\np = &x;   // 符合：&操作符和变量x之间不加空格\nx = r.y;  // 符合：通过.访问成员变量时不加空格\nx = r->y; // 符合：通过->访问成员变量时不加空格\n操作符\nx = 0;    // 符合：赋值操作的=前后都要加空格\nx = -5;   // 符合：负数的符号之前要加空格\n++x;      // 符合：前置和后置的++/--和变量之间不要加空格\nx--;\n\nif (x && !y)       // 符合：布尔操作符前后要加上空格，！操作和变量之间不要空格\nv = w * x + y / z; // 符合：二元操作符前后要加空格\nv = w * (x + z);   // 符合：括号内的表达式前后不需要加空格\n循环和条件语句\nif (condition) { // 符合：if关键字和括号之间加空格，括号内条件语句前后不加空格\n    ...\n} else {         // 符合：else关键字和大括号之间加空格\n    ...\n}\n\n// 符合：while关键字和括号之间加空格，括号内条件语句前后不加空格\nwhile (condition) {}\n\n// 符合：for关键字和括号之间加空格，分号之后加空格\nfor (int i = 0; i < someRange; i++) {\n    ...\n}\n\nswitch (var) { // 符合: switch 关键字后面有1空格\n    case 0:    // 符合：case语句条件和冒号之间不加空格\n        ...\n        break;\n    ...\n    default:\n        ...\n        break;\n} ",
					"badExample": " 函数定义和函数调用的情况\n\nint result = Foo(arg1,arg2);\n                      ^         // 不符合： 逗号后面应该有空格\n\nint result = Foo( arg1, arg2 );\n                 ^          ^   // 不符合： 小括号内部两侧不应有空格 ",
					"recommend": " 按要求增加/减少空格 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.11 用空格突出关键字和重要信息—— 一元表达式【c】",
					"language": "c",
					"id": "51c7d9690fef11edb76584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 空格应该突出关键字和重要信息。总体要求如下：\n\n行末不应加空格\nif, switch, case, do, while, for 等关键字之后应加空格\n小括号内部的两侧，不应加空格\n二元操作符（= + ‐ < > * / % | & ^ <= >= == !=）两侧都应加空格\n一元操作符（& * + ‐ ~ !）之后不应加空格\n三元操作符（? :）符号两侧都应加空格\n结构体中表示位域的冒号，两侧都应加空格\n前置和后置的自增、自减（++ –）和变量之间不应加空格\n结构体成员操作符（. ->）前后不应加空格\n大括号内部两侧有无空格，左右应保持一致\n逗号、分号、冒号（不含三元操作符和表示位域的冒号）紧跟前面内容无空格，其后需要空格\n函数参数列表的小括号与函数名之间不应加空格\n类型强制转换的小括号与被转换对象之间不应加空格\n数组的中括号与数组名之间不应加空格\n涉及到换行时，行末的空格可以省去\n对于大括号内部两侧的空格，建议如下：\n\n2的，大括号内部两侧建议加空格\n对于空的，或单个标识符，或单个字面常量，空格不是必须\n如：’{}’, ‘{0}’, ‘{NULL}’, ‘{“hi”}’ 等\n连续嵌套的多重括号之间，空格不是必须\n如：’{{0}}’, ‘{{ 1, 2 }}’ 等\n错误示例：’{ 0, {1}}’，不属于连续嵌套场景，而且最外侧大括号左右不一致\n注意：可在集成开发环境（IDE）和代码编辑器中设置保存文件时删除行末空格功能。 ",
					"systemTag": "clangtidy",
					"goodExample": " 变量定义\nint i = 0;               // 符合：变量初始化时，= 前后应该有空格，分号前面不要留空格\nint buf[BUF_SIZE] = {0}; // 符合：数组初始化时，大括号内空格可选\nint arr[] = { 10, 20 };  // 符合: 正常大括号内部两侧建议加空格\n指针和取地址\nx = *p;   // 符合：*操作符和指针p之间不加空格\np = &x;   // 符合：&操作符和变量x之间不加空格\nx = r.y;  // 符合：通过.访问成员变量时不加空格\nx = r->y; // 符合：通过->访问成员变量时不加空格\n操作符\nx = 0;    // 符合：赋值操作的=前后都要加空格\nx = -5;   // 符合：负数的符号之前要加空格\n++x;      // 符合：前置和后置的++/--和变量之间不要加空格\nx--;\n\nif (x && !y)       // 符合：布尔操作符前后要加上空格，！操作和变量之间不要空格\nv = w * x + y / z; // 符合：二元操作符前后要加空格\nv = w * (x + z);   // 符合：括号内的表达式前后不需要加空格\n循环和条件语句\nif (condition) { // 符合：if关键字和括号之间加空格，括号内条件语句前后不加空格\n    ...\n} else {         // 符合：else关键字和大括号之间加空格\n    ...\n}\n\n// 符合：while关键字和括号之间加空格，括号内条件语句前后不加空格\nwhile (condition) {}\n\n// 符合：for关键字和括号之间加空格，分号之后加空格\nfor (int i = 0; i < someRange; i++) {\n    ...\n}\n\nswitch (var) { // 符合: switch 关键字后面有1空格\n    case 0:    // 符合：case语句条件和冒号之间不加空格\n        ...\n        break;\n    ...\n    default:\n        ...\n        break;\n} ",
					"badExample": " 函数定义和函数调用的情况\n\nint result = Foo(arg1,arg2);\n                      ^         // 不符合： 逗号后面应该有空格\n\nint result = Foo( arg1, arg2 );\n                 ^          ^   // 不符合： 小括号内部两侧不应有空格 ",
					"recommend": " 按要求增加/减少空格 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.11 用空格突出关键字和重要信息——类型转换【c】",
					"language": "c",
					"id": "51c7d96b0fef11edb8e484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 空格应该突出关键字和重要信息。总体要求如下：\n\n行末不应加空格\nif, switch, case, do, while, for 等关键字之后应加空格\n小括号内部的两侧，不应加空格\n二元操作符（= + ‐ < > * / % | & ^ <= >= == !=）两侧都应加空格\n一元操作符（& * + ‐ ~ !）之后不应加空格\n三元操作符（? :）符号两侧都应加空格\n结构体中表示位域的冒号，两侧都应加空格\n前置和后置的自增、自减（++ –）和变量之间不应加空格\n结构体成员操作符（. ->）前后不应加空格\n大括号内部两侧有无空格，左右应保持一致\n逗号、分号、冒号（不含三元操作符和表示位域的冒号）紧跟前面内容无空格，其后需要空格\n函数参数列表的小括号与函数名之间不应加空格\n类型强制转换的小括号与被转换对象之间不应加空格\n数组的中括号与数组名之间不应加空格\n涉及到换行时，行末的空格可以省去\n对于大括号内部两侧的空格，建议如下：\n\n2的，大括号内部两侧建议加空格\n对于空的，或单个标识符，或单个字面常量，空格不是必须\n如：’{}’, ‘{0}’, ‘{NULL}’, ‘{“hi”}’ 等\n连续嵌套的多重括号之间，空格不是必须\n如：’{{0}}’, ‘{{ 1, 2 }}’ 等\n错误示例：’{ 0, {1}}’，不属于连续嵌套场景，而且最外侧大括号左右不一致\n注意：可在集成开发环境（IDE）和代码编辑器中设置保存文件时删除行末空格功能。 ",
					"systemTag": "clangtidy",
					"goodExample": " 变量定义\nint i = 0;               // 符合：变量初始化时，= 前后应该有空格，分号前面不要留空格\nint buf[BUF_SIZE] = {0}; // 符合：数组初始化时，大括号内空格可选\nint arr[] = { 10, 20 };  // 符合: 正常大括号内部两侧建议加空格\n指针和取地址\nx = *p;   // 符合：*操作符和指针p之间不加空格\np = &x;   // 符合：&操作符和变量x之间不加空格\nx = r.y;  // 符合：通过.访问成员变量时不加空格\nx = r->y; // 符合：通过->访问成员变量时不加空格\n操作符\nx = 0;    // 符合：赋值操作的=前后都要加空格\nx = -5;   // 符合：负数的符号之前要加空格\n++x;      // 符合：前置和后置的++/--和变量之间不要加空格\nx--;\n\nif (x && !y)       // 符合：布尔操作符前后要加上空格，！操作和变量之间不要空格\nv = w * x + y / z; // 符合：二元操作符前后要加空格\nv = w * (x + z);   // 符合：括号内的表达式前后不需要加空格\n循环和条件语句\nif (condition) { // 符合：if关键字和括号之间加空格，括号内条件语句前后不加空格\n    ...\n} else {         // 符合：else关键字和大括号之间加空格\n    ...\n}\n\n// 符合：while关键字和括号之间加空格，括号内条件语句前后不加空格\nwhile (condition) {}\n\n// 符合：for关键字和括号之间加空格，分号之后加空格\nfor (int i = 0; i < someRange; i++) {\n    ...\n}\n\nswitch (var) { // 符合: switch 关键字后面有1空格\n    case 0:    // 符合：case语句条件和冒号之间不加空格\n        ...\n        break;\n    ...\n    default:\n        ...\n        break;\n} ",
					"badExample": " 函数定义和函数调用的情况\n\nint result = Foo(arg1,arg2);\n                      ^         // 不符合： 逗号后面应该有空格\n\nint result = Foo( arg1, arg2 );\n                 ^          ^   // 不符合： 小括号内部两侧不应有空格 ",
					"recommend": " 按要求增加/减少空格 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.OTH.01 删除无效或永不执行的代码【c】",
					"language": "c",
					"id": "51c7d96d0fef11eda5ac84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": " 无效或永不执行的代码（即无效代码或无法访问的代码）通常是编程错误的结果，并且可能导致意外行为。通常在编译时，编译器会对此类代码进行优化。但是，为了提高可读性并确保解决逻辑错误，应该主动对其进行识别，理解和消除。\n\n虽然大多数现代编译器在许多情况下可以对无效或从不执行的代码告警，但程序员还是应该主动识别无效的语句或表达式，并将其从代码中删除。 ",
					"systemTag": "clangtidy",
					"goodExample": " 删除无效代码取决于程序员的意图，下面代码是一种改进方案。\nint Func(int condVal)\n{\n    if (condVal == 1) {\n        char *s = (char *)malloc(ALLOC_SIZE);\n        if (s == NULL) {\n           ... // 错误处理\n        }\n        ... // 处理 s\n        free(s);\n        return 0;\n    }\n    ...\n    return 0;\n}\n\n该代码可能是程序员错误的使用相等操作符(==)而不是赋值操作符(=)的情况。\nint a = ...;\nint b = ...;\n...\na = b;\n\n更正此示例取决于程序员的意图。例如，如果解引用p是错误的，则p不应解引用。\nint *p = NULL;\n...\np++;\n\nif (param == 1) {\n    DoSomething1();\n} else if (param == 2) {\n    DoSomething2();\n} else if (param == 3) {\n    DoSomething3();\n} else {\n    ...\n} ",
					"badExample": " 下面代码中，最后的 if 条件语句永远无法成立，应该删除或重新优化代码。\nint Func(int condVal)\n{\n    char *s = NULL;\n    if (condVal == 1) {\n        s = (char *)malloc(ALLOC_SIZE);\n        if (s == NULL) {\n           ... // 错误处理\n        }\n        ... // 处理 s\n        return 0;\n    }\n    ...\n    if (s != NULL) {\n        ... // 此处代码不可达\n    }\n    return 0;\n}\n\n下面代码进行了a与b的比较，没有任何效果。\nint a = ...;\nint b = ...;\n...\na == b; // 不符合： 这一行代码没有任何作用\n\n如下代码示例中，对指针进行解引用后，指针值增加了，但解引用没有任何作用。\nint *p = NULL;\n...\n*p++;\n\n从上到下评估一串if/else if语句。最多只执行该链的一个分支：第一个分支的条件求值为true。因此，在if/else if语句序列中复制条件会自动导致无效代码。\nif (param == 1) {\n    DoSomething1();\n} else if (param == 2) {\n    DoSomething2();\n} else if (param == 1) {  // 条件重复，永远不成立，预期是3？\n    DoSomething3();\n} else {\n    ...\n} ",
					"recommend": " 删除不可执行代码 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.TYP.03 使用合适的类型表示字符【c】",
					"language": "c",
					"id": "51c7d96f0fef11edbf7a84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 字符串是一个连续的字符序列，以第一个null字符结束，并且包含第一个null字符。\nC编程语言支持窄字符串(包括单字节字符串，多字节字符串)和宽字符字符串（参考C11标准7.1.1）。\n窄字符串是以第一个null字符（’\\0’）结尾的字节字符串。\n宽字符串是连续的宽字符序列，以第一个null宽字符（L’\\0’）结尾，并包含第一个null宽字符。\n\n字符串可以通过字符数组实现，并且容易遇到与数组相同的问题。因此，对数组的相关条款也适用于字符串。\n用于表示字符数据时，窄字符串的每个元素类型都要使用char类型。\n由于在不同系统中，char类型可以实现为signed char或unsigned char，因此不要使用char类型来表示整数。\nunsigned char可以在当不关心被操作的对象类型，并且需要访问该对象的所有bit位时使用。unsigned char不能表示字符，也不能表示字符串。 ",
					"systemTag": "clangtidy",
					"goodExample": " char ch = 'A'; // 符合，用char表示字符 ",
					"badExample": " char ch;\nint x;\n\nx = ch + 1; // 不符合，将char当整数使用 ",
					"recommend": " 正确使用字符和字符类型 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CTL.03-循环必须安全退出【C】",
					"language": "c",
					"id": "51c7d9710fef11ed81d384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "在应用程序中，一个重复提供服务的逻辑循环应当设计退出机制，并且将资源正确释放后安全退出。退\n出条件的设计，除了让程序逻辑更加完整，也能通过实现优雅退出的代码，显式释放服务循环中分配的\n资源，避免资源泄漏。",
					"systemTag": "codemars",
					"goodExample": "1. \nbool ParseMsg(unsigned char *msg, size_t msgLen)\n{\n...\nif (msg-&gt;type == EXIT_MESSAGE_TYPE) {\nreturn false;\n} else {\nreturn true;\n}\n}\nvoid DoService(void)\n{\n...\nsize_t size = 0;\nunsigned char *pMsg = NULL;\nbool doRunServiceFlag = true; // 服务退出条件\nCreateServiceResource(); // 分配服务资源\nwhile (doRunServiceFlag) {\npMsg = ReceiveMsg(&size);\nif (pMsg != NULL) {\ndoRunServiceFlag = ParseMsg(pMsg, size);\nFreeMsg(pMsg);\n}\nsize = 0;\n}\nReleaseServiceResource(); // 释放服务资源\n}\n2. \nvoid loop_control_variable_update()\n{\n    int i = 0;\n    while (i &lt; 10) {\n        i++;\n        /* do something */\n    }\n}",
					"badExample": "1. \nvoid DoService(void)\n{\n...\nsize_t size = 0;\nunsigned char *pMsg = NULL;\nCreateServiceResource(); // 分配服务资源\nwhile (true) {\npMsg = ReceiveMsg(&size);\nif (pMsg != NULL) {\nParseMsg(pMsg, size);\nFreeMsg(pMsg);\n}\nsize = 0;\n}\n}\n2. \nvoid loop_control_variable_not_update()\n{\n    int i = 0;\n    // POTENTIAL FLAW:while循环中，循环变量i未更新\n    while (i &lt; 10) {\n        /* do something */\n    }\n}",
					"recommend": "确保循环能够正常退出，不出现死循环的情况",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.ARR.04-避免整数与指针间的互相转化【C】",
					"language": "c",
					"id": "51c7d9730fef11ed8a1b84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "整数与指针之间相互转换的结果是由实现定义的。在linux下，将指针转换为long类型之后再转换为原类\n型的做法通常不会丢失信息，但C语言标准并未对此予以保证。",
					"systemTag": "codemars",
					"goodExample": "char *p = ...;\nchar *p2 = ...;\nuintptr_t number = (uintptr_t)(void *)p;\nuintptr_t number2 = (uintptr_t)(void *)p2;",
					"badExample": "char *p = ...;\nchar *p2 = ...;\n// 直接将指针转换为 int 可能会超出int表示范围导致错误\nunsigned int number = (unsigned int)p;\n// 将uintptr_t转换为int 可能会发生数据截断导致错误\nunsigned int number2 = (unsigned int)(uintptr_t)p2;",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.AST.01-断言必须使用宏定义，且只能在调试版本中生效；\n【C】",
					"language": "c",
					"id": "51c7d9750fef11ed869784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "C语言标准定义断言为用于诊断测试的宏(assert)，因此，断言只能在调试版本中使用。断言被触发后，\n程序会立即退出，因此严禁在正式发布版本使用断言，请通过编译选项进行控制。\n断言触发时虽然能提供少量提示信息，但这样的提示信息通常只对程序员有用，对用户几乎没有价值。\n程序总是应该优先考虑从错误中恢复，因此，断言应只在调试阶段作为诊断方式生效，其他时候，断言\n是一种比注释更好的文档说明。例如，断言可以用来声明使用函数的前提条件。",
					"systemTag": "codemars",
					"goodExample": "",
					"badExample": "#ifdef DEBUG\n#define ASSERT(f) assert(f)\n#else\n#define ASSERT(f) do { \\\nif (!(f)) { \\\nprintf(\"Error in function=%s, Line=%d\\n\", __FUNCTION__, __LINE__); \\\n} \\\n} while (0)\n#endif",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.AST.03-禁止用断言检测程序在运行期间可能导致的错误，可能发生的错误要用错误处理代码来处理【C】",
					"language": "c",
					"id": "51c7d9790fef11edb4e984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "断言主要用于调试期间，在发布版本中应将其关闭。因此，断言应该用于防止不正确的程序员假设，而\n不能用在发布版本上检查程序运行过程中发生的错误。\n断言永远不应用于验证是否存在运行时（与逻辑相对）错误，包括但不限于：\n无效的用户输入（例如：命令行参数和环境变量）\n文件错误（例如：打开、读取或写入文件时出错）\n网络错误（例如：网络协议错误）\n内存不足的情况（例如：malloc()类似的故障）\n系统资源耗尽（例如：文件描述符、进程、线程）\n系统调用错误（例如：执行文件、锁定或解锁互斥锁时出错）\n无效的权限（例如：文件、内存、用户）",
					"systemTag": "codemars",
					"goodExample": "FILE *fp = fopen(path, \"r\");\nif (fp == NULL) {\n... // 错误处理\n}\nchar *str = (char *)malloc(MAX_LINE);\nif (str == NULL) {\n... // 错误处理\n}\nReadLine(fp, str);\nchar *p = strstr(str, \"age=\");\nif (p == NULL) {\n... // 错误处理\n}\nchar *end = NULL;\nlong age = strtol(p + 4, &end, 10);\nif (age &lt;= 0) {\n... // 错误处理\n}",
					"badExample": "FILE *fp = fopen(path, \"r\");\nASSERT(fp != NULL); // 不符合：文件有可能打开失败\nchar *str = (char *)malloc(MAX_LINE);\nASSERT(str != NULL); // 不符合：内存有可能分配失败\nReadLine(fp, str);\nchar *p = strstr(str, \"age=\"\");\nASSERT(p != NULL); // 不符合：文件中不一定存在该字符串\nchar *end = NULL;\nlong age = strtol(p + 4, &end, 10);\nASSERT(age &gt; 0); // 不符合：文件内容不一定符合预期\n",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.AST.05-一个断言只用于检查一个错误【C】",
					"language": "c",
					"id": "51c7d97b0fef11ed963084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "为了更加准确地发现错误的位置，每一条断言只校验一个错误。",
					"systemTag": "codemars",
					"goodExample": "int Foo(int *array, size_t size)\n{\nASSERT(array != NULL);\nASSERT(size &gt; 0);\nASSERT(size &lt;= ARRAY_SIZE_MAX);\n...\n}",
					"badExample": "int Foo(int *array, size_t size)\n{\nASSERT(array != NULL && size &gt; 0 && size &lt;= ARRAY_SIZE_MAX);\n...\n}",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.04-禁用atexit函数【C】",
					"language": "c",
					"id": "51c7ff4d0fef11edad4284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "atexit函数使用有严格限制：在一个程序中最多只能注册32个例程；例程必须通过return返回，不允许\n调用退出函数（如exit()）或调用longjmp()等方式返回，否则例程可能得不到正确执行，还会造成程序\n产生未定义行为。同时对于所有的退出处理程序来说，程序员应该主动清理不再使用的资源，而不应在\n最终程序退出后通过使用atexit函数事先注册的例程被动地清理资源。",
					"systemTag": "codemars",
					"goodExample": "void ProcessExit(void)\n{\nif (g_someResource == 0) {\n... // g_someResource，在这里清理程序资源，代码省略\n}\nreturn;\n}\nint main(void)\n{...\n// main函数退出\nProcessExit(); // 符合：主动调用资源清理函数\nreturn 0;\n}",
					"badExample": "\nint g_someResource = 1;\nvoid ProcessExit(void)\n{\nif (g_someResource == 0) {\n... // g_someResource，在这里清理程序资源，代码省略\nexit(0); // 不符合：在本例程中调用exit，导致程序产生未定义行为\n}\nreturn;\n}\nint main(void)\n{\n// 不符合：注册atexit()例程ProcessExit()，清理资源\nif (atexit(ProcessExit) != 0) {\n... // 错误处理\n}\n...\n// main函数退出\nreturn 0;\n}\n",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.05-禁止调用kill、TerminateProcess函数直接终止其他进程【C】",
					"language": "c",
					"id": "51c7ff4f0fef11ed863784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "调用kill、TerminateProcess等函数直接强行终止其他进程(如kill -SIGKILL，kill -SIGSTOP)，会导致被终\n止的进程中的资源得不到清理。\n进程终止时，进程特有的资源将由系统自动释放，而其他资源(尤其是不属于进程的系统资源)在程序退出\n前难以得到有效地清理。\n对于进程/线程间通信，应该主动发送一个停止命令，通知对方安全退出。接收到停止命令的进程应尽快完成进程资源和不再使用的系统资源的清理和释放。\n当发送给对方进程/线程退出信号后，在等待一定时间内如果对方仍然未退出，可以调用kill、\nTerminateProcess函数强行终止目标进程。",
					"systemTag": "codemars",
					"goodExample": "\nif (isFatalStatus) {\n...\nkill(pid, SIGUSR1); // 符合：目标进程将SIGUSR1定义为停止命令\n...\nif (WaitForRemoteProcessExit() == TIME_OUT) {\nkill(pid, SIGKILL); // 目标进程在限定时间内仍然未退出，强行结束目标进程\n}\n}",
					"badExample": "if (isFatalStatus) {\n...\nkill(pid, SIGKILL); // 不符合：直接调用kill强行结束目标进程\n}",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.06-禁用pthread_exit、ExitThread函数【C】",
					"language": "c",
					"id": "51c7ff510fef11ed969a84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "严禁在线程内主动终止自身线程，线程函数在执行完毕后会自动、安全地退出。主动终止自身线程的操作，不仅导致代码复用性变差，同时容易导致资源泄漏错误。\npthread_exit()函数将终止调用它的线程，线程终止时不释放任何应用程序可见的进程资源，包括但不限\n于互斥锁和文件描述符，也不执行任何进程级别的清理操作。\nwindows环境下ExitThread用于使当前正在运行的线程正常且干净地停止。运行该函数可能导致主线程\n退出，而其他线程仍然在执行。停止线程的正确方法是发出干净的退出信号，然后允许线程自行退出，\n然后再允许主线程退出。",
					"systemTag": "codemars",
					"goodExample": "",
					"badExample": "",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.07-除main函数以外的其他函数，禁止使用exit、ExitProcess函数退出【C】",
					"language": "c",
					"id": "51c7ff530fef11eda83484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "除了main函数以外，禁止任何地方调用exit、ExitProcess函数退出进程。直接退出进程可能会导致代码\n的复用性降低，某些资源（尤其是不属于进程的系统资源）在程序退出前难以得到有效地清理。\n处理程序退出时必须通过不断返回上一层函数来终止运行。对于所有退出处理程序来说，能够正确执行\n它们的清理操作是很重要的，在安全性上可能很关键。",
					"systemTag": "codemars",
					"goodExample": "\nbool LoadFile(const char *filePath)\n{\nASSERT(filePath != NULL);\nbool ret = false;\nFILE *fp = fopen(filePath, \"rt\");\nif (fp == NULL) {\n... // 错误处理\nreturn ret;\n}\n…\nreturn ret;\n}",
					"badExample": "\nvoid LoadFile(const char *filePath)\n{\nASSERT(filePath != NULL);\nFILE *fp = fopen(filePath, \"rt\");\nif (fp == NULL) {\nexit(0); // 不符合\n}\n...\n}",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.08-禁用abort函数【C】",
					"language": "c",
					"id": "51c7ff550fef11ed883484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "abort()将会导致程序立即退出，资源得不到清理。因为在使用abort()退出程序时，不能保证输入/输出\n流已经被清空，文件已经正确关闭，或者临时文件已经删除。",
					"systemTag": "codemars",
					"goodExample": "【例外】只有发生致命错误，程序无法继续执行的时候，在错误处理函数中使用abort退出程序，如：\nvoid FatalError(int sig)\n{\n  abort();\n}\nint main(int argc, char *argv[])\n{\n  signal(SIGSEGV, FatalError);\n  ...\n}",
					"badExample": "void use_abort()\n{\n    /* POTENTIAL FLAW: Do not use abort. */\n    abort(); \n}",
					"recommend": "禁用abort函数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.09-禁止使用realloc()函数【C】",
					"language": "c",
					"id": "51c7ff570fef11ed95cb84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "realloc()是一个非常特殊的函数,随着参数的不同，其行为也是不同,一个简单的C函数，却被赋予了3种行为，这不是一个设计良好的函数。虽然在编程中提供了\n一些便利性，如果认识不足，使用不当，是却极易引发各种bug。",
					"systemTag": "codemars",
					"goodExample": "// 使用malloc()函数代替realloc()函数\nchar *newPtr = (char *)malloc(NEW_SIZE);\nif (newPtr == NULL) {\n... // 错误处理\n}\nerrno_t ret = memcpy_s(newPtr, NEW_SIZE, oldPtr, oldSize);\n... // 校验ret，确保安全函数执行成功\n... // 返回前，释放oldPtr",
					"badExample": "// 当realloc()分配内存失败时会返回NULL，导致内存泄漏\nchar *ptr = (char *)realloc(ptr, NEW_SIZE);\nif (ptr == NULL) {\n.. // 错误处理\n}",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.10-禁止使用alloca()函数申请栈上内存【C】",
					"language": "c",
					"id": "51c7ff590fef11eda9ac84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "POSIX和C99均未定义alloca()的行为，在有些平台下不支持该函数，使用alloca会降低程序的兼容性和可\n移植性，该函数在栈帧里申请内存，申请的大小很可能超过栈的边界，影响后续的代码执行。请使用malloc从堆中动态分配内存。",
					"systemTag": "codemars",
					"goodExample": "",
					"badExample": "",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.13 禁止封装安全函数【C】",
					"language": "c",
					"id": "51c7ff5b0fef11edbb0e84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "华为安全函数是C11标准的相关标准接口一个实现，在开发时充分考虑了规范要求，安全性，运行效率，可移植性等方面。\n保留所有安全检查和返回值信息的封装，不必要的增加了函数调用开销；对入参检查及返回值进行修改的封装，丢失了安全函数的部分安全特性。因此安全函数不允许进行封装。",
					"systemTag": "codemars",
					"goodExample": "使用华为安全函数\n\nvoid test_good_case(void *dest, size_t destmax, const void *src, size_t count) \n{\n  ...\n  errno_t ret = memcpy_s(dest, destmax, src, count);\n  ... // 校验ret，确保安全函数执行成功\n}",
					"badExample": "错误示例1：使用类似危险函数的接口封装安全函数，destMax与count参数使用相同参数\n\nvoid XXX_memcpy(void *dest, const void *src, size_t count)\n{\n  ...\n  memcpy_s(dest, count, src, count); \n  ...\n  }\n错误示例2：使用函数简单封装安全函数，封装函数的接口入参类型与安全函数入参相同，但封装函数内调用安全函数时destMax与count参数使用相同参数。\n\nerrno_t XXX_memcpy_s(void *dest, size_t destMax, const void *src, size_t count)\n{\n  ...\n  memcpy_s(dest, count, src, count);\n  ...\n}\n错误示例3：使用类似安全函数的名字的函数，但是参数与安全函数不同\n\nerrno_t XXX_memcpy_s(void *dest, const void *src, size_t count)\n{\n  ...\n}\n错误示例4：将函数的名字命名为类似安全函数(函数名称内包含安全函数的名字），但实现为危险函数。\n\nerrno_t XXX_memcpy_s(void *dest, size_t destmax, const void *src, size_t count)\n{\n  ...\n  memcpy(dest, src, count);\n  ...\n}\n错误示例5：用函数实现自定义不安全函数\n\nerrno_t XXX_strncpy(char *dest, size_t destMax, const char *src)\n{\n  ...\n}",
					"recommend": "对安全函数做封装时，正确理解destMax的用法，不要用count替代destMax",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.15-只能使用华为安全函数库中的安全函数或经华为认可的其他安全函数——检查安全函数定义是否在安全函数库中【C】",
					"language": "c",
					"id": "51c7ff5d0fef11eda1c084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "Huawei Secure C库中提供的安全函数符合C11标准中已有的定义，并结合产品诉求，在平台兼容性和执\n行效率上有其独特优势。使用类似名称创建的函数难以与C11标准中的函数定义相适配，同时也容易与\nHuawei Secure C的实现产生混淆，造成误用，并引入安全风险。因此不应当实现私有的安全函数。",
					"systemTag": "codemars",
					"goodExample": "",
					"badExample": "void IgnoreHandler(const wchar_t *expression,\nconst wchar_t *function,\nconst wchar_t *file,\nunsigned int line,\nuintptr_t pReserved)\n{\n... // 不做退出处理\n}\nint main(int argc, char *argv[])\n{\n_invalid_parameter_handler oldHandler =\n_set_invalid_parameter_handler(IgnoreHandler);\n...\nchar buf[MAX_LEN];\nerrno_t ret = strcpy_s(buf, sizeof(buf), argv[1]);\nif (ret != 0) {\n... // 错误处理\n}\n...\nreturn 0;\n}",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": false
				},
				{
					"name": "Non_Reentrant_Function【C】",
					"language": "c",
					"id": "51c7ff5f0fef11ed996484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "C语言标准库中有一些函数是不可重入函数。不可重入函数在多线程环境下的执行结果可能不能达到预\n期效果，需谨慎使用。",
					"systemTag": "codemars",
					"goodExample": "",
					"badExample": "void Foo(void)\n{\nchar *wxEnv = NULL;\nchar *bdEnv = NULL;\nwxEnv = getenv(\"TABLE_WX_ENV\");\nif (wxEnv == NULL) {\n... // 错误处理\nreturn;\n}\nbdEnv = getenv(\"TABLE_BD_ENV\");\nif (bdEnv == NULL) {\n... // 错误处理\nreturn;\n}\nif (strcmp(wxEnv, bdEnv) == 0) {\nprintf(\"They are the same.\\n\");\n} else {\nprintf(\"They are NOT the same.\\n\");\n}\n}",
					"recommend": "谨慎使用不可重入函数。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.OTH.05-禁止代码中包含公网地址【C】",
					"language": "c",
					"id": "51c7ff610fef11eda24884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "对产品发布的软件（包含软件包/补丁包）中包含的公网地址（包括公网IP地址、公网URL地址/域名、邮\n箱地址）要求如下：\n1、禁止包含用户界面不可见、或产品资料未描述的未公开的公网地址。\n2、已公开的公网地址禁止写在代码或者脚本中，可以存储在配置文件或数据库中。\n对于开源/第三方软件自带的公网地址必须至少满足上述第1条公开性要求。",
					"systemTag": "codemars",
					"goodExample": "",
					"badExample": "",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.09-禁止使用realloc()函数【C】",
					"language": "c",
					"id": "51c8279b0fef11ed934a84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "禁止使用realloc()函数。\nrealloc()是一个非常特殊的函数，原型如下：\n```C\nvoid *realloc(void *ptr, size_t size);\n```\n随着参数的不同，其行为也是不同：\n - 当ptr不为NULL，且size不为0时，该函数会重新调整内存大小，并将新的内存指针返回，并保证最小的size的内容不变；\n - 参数ptr为NULL，但size不为0，那么其行为等同于malloc(size)；\n - 参数size为0，则realloc的行为等同于free(ptr)。\n\n由此可见，一个简单的C函数，却被赋予了3种行为，这不是一个设计良好的函数。虽然在编程中提供了一些便利性，如果认识不足，使用不当，是却极易引发各种bug。",
					"systemTag": "codemars",
					"goodExample": "\"// 使用malloc()函数\nchar *newPtr = (char *)malloc(NEW_SIZE);\nif (newPtr == NULL) {\n  ... // 错误处理\n}\nerrno_t ret = memcpy_s(newPtr, NEW_SIZE, oldPtr, oldSize);\n... // 校验ret，确保安全函数执行成功\n... // 返回前，释放oldPtr\"",
					"badExample": "void use_alloca()\n{\n    /* POTENTIAL FLAW: Forbid use alloca() */\n    int *p = (int *)alloca(sizeof(int) * 10); \n    free(p); \n    return;\n}",
					"recommend": "禁止调用alloca函数，请使用malloc从堆中动态分配内存。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FUU.15-只能使用华为安全函数库中的安全函数或经华为认可的其他安全函数——检查用户自定义类安全函数【C】",
					"language": "c",
					"id": "51c8279d0fef11ed9cbf84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "Huawei Secure C库中提供的安全函数符合C11标准中已有的定义，并结合产品诉求，在平台兼容性和执\n行效率上有其独特优势。使用类似名称创建的函数难以与C11标准中的函数定义相适配，同时也容易与\nHuawei Secure C的实现产生混淆，造成误用，并引入安全风险。因此不应当实现私有的安全函数。",
					"systemTag": "codemars",
					"goodExample": "使用华为安全函数\nvoid test_good_case(void *dest, size_t destmax, const void *src, size_t count) {\n   ...\n   errno_t ret = memcpy_s(dest, destmax, src, count);\n   ... // 校验ret，确保安全函数执行成功\n}",
					"badExample": "#define SECUREC_MEM_MAX_LEN (0x7fffffffUL)\nvoid MemcpySafe(void *dest, unsigned int destMax,\nconst void *src, unsigned int count)\n{\nif (destMax == 0 || destMax &gt; SECUREC_MEM_MAX_LEN ) {\nreturn;\n}\nif (dest == NULL || src == NULL) {\nreturn;\n}\nif (count &gt; destMax) {\nreturn;\n}\nif (dest == src) {\nreturn;\n}\nif (((uint32_t)dest &gt; (uint32_t)src &&\n(uint32_t)dest &lt; (uint32_t)(void *)((uint8_t *)src + count)) ||\n((uint32_t)src &gt; (uint32_t)dest &&\n(uint32_t)src &lt; (uint32_t)(void *)((uint8_t *)dest + count))) {\nreturn;\n}\nmemcpy(dest, src, count);\n}",
					"recommend": "不要自定义安全函数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": false
				},
				{
					"name": "G.FIL.03 不要在共享目录中创建临时文件【C】",
					"language": "c",
					"id": "51c8279f0fef11edad3384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "不能在共享目录中创建临时文件。\n共享目录是指其它非特权用户可以访问的目录。程序的临时文件应当是程序自身独享的，任何将自身临时文件置于共享目录的做法，\n将导致其他共享用户获得该程序的额外信息，产生信息泄露。因此，不要在任何共享目录创建仅由程序自身使用的临时文件。\"",
					"systemTag": "codemars",
					"goodExample": "void ProcData_GoodCase01(const char *filename)\n{\n  // POTENTIAL FLAW GOOD\n  FILE *fp = fopen(filename, \"wb+\");\n  if (fp == NULL) {\n    ... // 错误处理\n  }\n  ... // 写文件\n  fclose(fp);\n}\nint main(void)\n{\n  char *pFile = \"file.txt\";\n  ... \n  ProcData(pFile);\n  ... \n  return 1;\n}",
					"badExample": "1. 程序在Linux系统的共享目录/tmp下创建临时文件来保存临时数据，且文件名是硬编码的。\nvoid ProcData_BadCase01(const char *filename)\n{\n  // POTENTIAL FLAW: filename中包含\"tmp\"\n  FILE *fp = fopen(filename, \"wb+\");\n  if (fp == NULL) {\n    ... // 错误处理\n  }\n  ... // 写文件\n  fclose(fp);\n}\nint main(void)\n{\n  // 不符合：1.在系统共享目录中创建临时文件；2.临时文件名硬编码\n  char *pFile = \"/tmp/data\";\n  ... \n  ProcData(pFile);\n  ... \n  return 0;\n}\n3. 调用了不安全的创建临时文件的函数tmpfile。\nvoid use_insecure_method_to_create_temp_file()\n{\n  FILE *fp;\n  /* POTENTIAL FLAW: use insecure method to create temp file */\n  fp = tmpfile();\n  /*do something*/\n  fclose(fp);\n}",
					"recommend": "不要在共享目录中创建临时文件。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.EXP.05 不要向sizeof传递有副作用的操作数【C】",
					"language": "c",
					"id": "51c827a10fef11ed850384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "",
					"systemTag": "codemars",
					"goodExample": "正确示例： 如下代码示例中，将 sizeof(buffer) 修改为申请的缓冲区大小\nvoid sizeof_good()\n{\n    char path[MAX_PATH];\n    char *buffer = (char *)malloc(SIZE);\n    memset(path, 0, sizeof(path));\n    memset(buffer, 0, SIZE); // 使用申请的缓冲区大小\n}",
					"badExample": "错误示例： 如下代码示例中，buffer和path分别是指针和数组，程序员想对这2个内存进行清0操作，但由于程序员的疏忽，将内存大小误写成了 sizeof(buffer) ，与预期不符。\nvoid sizeof_bad()\n{\n    char path[MAX_PATH];\n    char *buffer = (char *)malloc(SIZE);\n\n    memset(path, 0, sizeof(path));\n    // sizeof与预期不符，其结果为指针本身的大小而不是缓冲区大小\n    memset(buffer, 0, sizeof(buffer));\n}",
					"recommend": "不要向sizeof传递有副作用的操作数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				}
			],
			"ruleSetName": "华为云规范(C语言)",
			"updateTime": "2021-09-30 00:00:00",
			"ruleSetId": "c_rules",
			"ruleSetUrl": "",
			"language": "c"
		},
		{
			"rules": [
				{
					"name": "G.NAM.01 标识符应由不超过64字符的字母、数字和下划线组成",
					"language": "java",
					"id": "51be3d9d0fef11edbbd584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "所有标识符仅使用ASCII字母、数字、下划线_，名称由正则表达式匹配\\w{2,64}\n\n工具检查场景:\n- 接口，枚举，类，变量，方法名，参数，常量，枚举常量的标识符长度在2到64之间；\n- 只检查标识符的声明，不检查标识符的引用；\n- 例外：循环变量和catch块中的异常变量允许1个字符",
					"systemTag": "fixbotengine-java",
					"goodExample": "String str;",
					"badExample": "String s;\n",
					"recommend": "修改变量名",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.DCL.04 避免枚举常量序号的产生依赖于ordinal()方法",
					"language": "java",
					"id": "51be637e0fef11eda8d284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "Java枚举类型通过ordinal()方法返回枚举常量的排列序号。默认情况下，序号是根据声明顺序从0开始累加，但某些情况下我们希望指定某些枚举常量为某个固定值以代表特殊意义。（例如，键盘某个按键的具体编码）返回该固定值的方法不能基于ordinal()方法来实现。\n\n\n工具检查场景:\n- 检查枚举类中是否调用了ordinal方法",
					"systemTag": "fixbotengine-java",
					"goodExample": "enum Keyboard {\n    MOUSE_KEY_LEFT(1),\n    MOUSE_KEY_RIGHT(2),\n    MOUSE_KEY_CANCEL(4),\n    MOUSE_KEY_MIDDLE(8);\n\n    private final int mouseKeyValue;\n\n    Keyboard(int value) {\n        this.mouseKeyValue = value;\n    }\n\n    public int getMouseKeyValue() {\n        return mouseKeyValue;\n    }\n}\n上述示例中，重写了枚举的构造方法，需要为枚举常量显式指定固定值。当新增枚举常量时，避免了原有枚举常量值发生变化。",
					"badExample": "enum Keyboard {\n    MOUSE_KEY_LEFT,\n    MOUSE_KEY_RIGHT,\n    MOUSE_KEY_CANCEL,\n    MOUSE_KEY_MIDDLE;\n\n    public int getMouseKeyValue() {\n        return ordinal() + 1;\n    }\n}\n上述示例中，在新增枚举常量时可能会导致原有枚举常量的值发生变化。",
					"recommend": "覆写orinal方法",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.DCL.02 局部变量被声明在接近它们首次使用的行",
					"language": "java",
					"id": "51be63800fef11ed851b84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "局部变量被声明为接近它们首次使用的点，以最小化它们的范围。\n局部变量声明通常具有初始化，或在声明后立即初始化，无需为局部变量设置无效的null值。\n类的成员字段要集中声明。\n\n工具检查场景:\n- 检查是否存在如下场景：局部变量声明未初始化，且该变量最近的一个赋值语句和该声明在同一个作用域\n- 检查是否存在如下场景：局部变量的首次使用与它的声明在同一个作用域，且与声明语句间相隔超过10行（非空，非注释）",
					"systemTag": "fixbotengine-java",
					"goodExample": "int var2;\nint var1 = 0;",
					"badExample": "int var1;\n    int var2;\n    var1 = 0;",
					"recommend": "合并声明和首次赋值位置",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.DCL.01 每行声明一个变量",
					"language": "java",
					"id": "51be63820fef11edb15584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "每行的变量声明（字段或本地）都只声明一个变量。\n\n2021年4月8日：新增类成员变量检查\n\n工具检查场景:\n- 检查是否每行只声明一个变量\n- 例外场景\n  - `for`语句中第1部分通常用于计数器的初始化，可以接受多个变量声明 。",
					"systemTag": "fixbotengine-java",
					"goodExample": "int length;\n    int result;",
					"badExample": "int length, result;",
					"recommend": "每个变量声明一行",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.DCL.03 禁止C风格的数组声明",
					"language": "java",
					"id": "51be63840fef11ed82ae84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "数组类型中应该包含中括号([])，数组声明格式应该是String[] nonEmptyArray，而不是String nonEmptyArray[]。\n\n2021年4月8日：新增参数变量、成员变量检查\n\n工具检查场景:\n- 检查数组元素类型是否紧跟中括号（[]）。",
					"systemTag": "fixbotengine-java",
					"goodExample": "String[] strs;",
					"badExample": "String strs[];",
					"recommend": "数组元素类型紧跟中括号（[]）",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.TYP.09 字符与字节的互相转换操作，要指明正确的编码方式",
					"language": "java",
					"id": "51be63860fef11eda29a84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "使用java.nio.charset包中的类编码解码字符集; 更简便的写法可用String的getBytes(Charset)和构造方法，它们已经通过StringCoding类进行了封装。\n\n工具检查场景：\n- 检查是否出现String.getBytes()方法的调用，但没有传编码参数\n- 检查是否出现new String(bytes[])方法的调用，但没有传编码参数\n- 检查是否出现URLEncoder.encode()或URLEncoder.decode()，但没有传编码参数\n- 检查是否出现new InputStreamReader()或new OutputStreamWriter()，但没传编码参数",
					"systemTag": "fixbotengine-java",
					"goodExample": "String data = \"123ABC中国\";\nbyte[] buf = data.getBytes(StandardCharsets.UTF_8);",
					"badExample": "String data = \"123ABC中国\";        \nbyte[] buf = data.getBytes();",
					"recommend": "增加编码参数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.SER.04 禁止直接序列化指向系统资源的信息",
					"language": "java",
					"id": "51be63880fef11edb4cf84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "序列化对象可以在Java程序以外被修改，除非它们受特殊机制保护（如jar签名）。如果一个指向系统资源的对象可以被序列化，并且攻击者可以替换掉该对象的序列化形式，那么该对象就具备修改特定句柄指向的系统资源的能力。\n\n工具检查场景:\n-检查一个实现Serializable接口的类中是否有指向系统资源的句柄（File，FileDescription)变量没有用transient 修饰",
					"systemTag": "fixbotengine-java",
					"goodExample": "final class SomeResource implements Serializable {\n    private static final long serialVersionUID = 6562477636399915529L;\n    transient File file;\n\n    public SomeResource(String fileName) {\n        file = new File(fileName);\n        ...\n    }\n}",
					"badExample": "final class SomeResource implements Serializable {\n    private static final long serialVersionUID = -2589766491699675794L;\n    File file;\n\n    public SomeResource(String fileName) {\n        file = new File(fileName);\n        ...\n    }\n}",
					"recommend": "增加transient",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.SER.01 尽量避免实现Serializable接口",
					"language": "java",
					"id": "51be638a0fef11edbc1284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "使用Java内置序列化功能的主要场景是为了在当前程序之外保存对象并在需要的时候重新获得对象。鉴于以下原因，建议除非必须使用的第三方接口要求必须实现Serializable接口，否则请选用其它方式代替。\n\n\n工具检查场景:\n- 检查每个类声明是否实现Serializable接口",
					"systemTag": "fixbotengine-java",
					"goodExample": "",
					"badExample": "public class ClassDemo implements Serializable {\n}",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.02 用括号明确表达式的操作顺序，避免过分依赖默认优先级",
					"language": "java",
					"id": "51be638c0fef11edb19d84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "使用括号强调所使用的操作符，防止因默认的优先级与设计思想不符而导致程序出错。\n\n工具检查场景:\n- 检查每个算术表达式内是否包含不同算术运算符且未用括号",
					"systemTag": "fixbotengine-java",
					"goodExample": "// 直接布尔比较\nif (var1 boolOp var2)\nif (func(var1) boolOp func(var2))\nif (var1 &gt; min || var1 &lt; max || func1(num) != 0)\n\n// 类型转换后布尔比较\nif (var1 boolOp (short) var2)\n\n// 有额外的算术运算的场景\nif (var1 boolOp (var2 + var3))\nif (var1 boolOp ((short) var2 - var3))\nif (func(var1) boolOp (func(var2) + var3))\nif (var1 &gt; min || var1 &lt; max || (func1(num) - base) != 0)\n\n// 直接布尔比较\nreturn list == null || list.isEmpty();\n\n// 逗号两边的表达式，不需要括号\nint result = func(n1 + n2, n3);\n\n// 有额外的算术运算\nint result = n1 == n2 ? n1 : (n1 – n2);\n\n// 直接布尔比较\nint result = maximumValue &gt; minimumValue ? minimumValue : maximumValue;\nint result = func1(param1) &gt; func2(param2) ? minimumValue : maximumValue;\n\n// 直接布尔比较\nif (func1(param1) &gt; func2(param2) || func1(param1) &lt; func3(params3)) {\n    result = func1(param1);\n}\n\n/*\n * 可以考虑使用Stream的方法：\n * allMatch和noneMatch - 注意流为空时返回true\n * anyMatch - 注意流为空时返回false\n */\nStream&lt;Object&gt; xs = Stream.of(foo, bar, baz);\nif (xs.anyMatch(Objects::isNull)) { ... }",
					"badExample": "System.out.println(1 + 1 - 1);\n    System.out.println(1 &lt;&lt; 2 + 3);",
					"recommend": "增加括号",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.04 表达式的比较，应该遵循左侧倾向于变化、右侧倾向于不变的原则——表达式比较左变右不变",
					"language": "java",
					"id": "51be638e0fef11edbc7e84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "当变量或方法调用与常量比较时，如果常量放左边，如 if (MAX == v) 不符合阅读习惯，而 if (MAX &gt; v) 更是难于理解。\n应当按人的正常阅读、表达习惯，将常量放右边。\n\n工具检查场景:\n- 检查每个比较表达式（==、!=、&gt;、&lt;、&gt;=、&lt;=），如果是变量或方法调用与常量比较时，常量是否放左边\n  - 常量的识别：本类中static final的成员或者由大写字母，数字和下划线组成的标识符\n- 例外场景：\n  - 描述区间时，前半段表达式常量在左，也是允许的，如`if (MIN &lt; bar && bar &lt; MAX)`。",
					"systemTag": "fixbotengine-java",
					"goodExample": "if (obj != null) { ... }",
					"badExample": "if (null != obj) { ... }",
					"recommend": "左侧变量，右侧常量",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.01 不要在单个的表达式中对相同的变量赋值超过一次",
					"language": "java",
					"id": "51be8bc40fef11edb93184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "对相同的变量进行多次赋值的表达式会产生混淆，并且容易产生非预期的行为。清晰的变量赋值会使代码更易懂，也更能保证程序按预期运行。\n\n\n工具检查场景:\n- 检查赋值语句的右侧是否有赋值变量的自增操作",
					"systemTag": "fixbotengine-java",
					"goodExample": "public class Increment {\n    public static void main(String[] args) {\n        int count = 0;\n        for (int i = 0; i &lt; 100; i++) {\n            ...\n            count++;\n        }\n        System.out.println(count);\n    }\n}\n上述示例中，可以实现正常的循环计数，输出结果为100。",
					"badExample": "public class Increment {\n    public static void main(String[] args) {\n        int count = 0;\n        for (int i = 0; i &lt; 100; i++) {\n            ...\n            count = count++;\n        }\n        System.out.println(count);\n    }\n}\n上述示例中，预期使用count对循环计数，而实际输出的结果却为0。",
					"recommend": "拆分表达式",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CTL.02 含else if分支的条件判断应在最后加一个else分支",
					"language": "java",
					"id": "51be8bc60fef11ed95e184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "含多个else if条件组合的判断逻辑，往往会出现被遗漏的分支，在最后设置一个else分支可对遗漏场景进行处理(类似于switch-case语句要有default分支) 。\n最后的else分支如果没有明确的处理场景，可以考虑仅记录日志或抛出异常等，如：log(\"unkown condition\")、throw new IllegalStateException(\"bad parameter\")等。\n\n\n工具检查场景：\n- 检查含else if分支的条件判断的最后是否有else分支",
					"systemTag": "fixbotengine-java",
					"goodExample": "if ((employee.flags & HOURLEY_FLAG) && (employee.age &gt; RETIRED_AGE)) {\n    ...\n} else if ((employee.flags & HOURLEY_FLAG) && (employee.age &lt; RETIRED_AGE)) {\n    ...\n} else if ((employee.flags & HOURLEY_FLAG) && (employee.age == RETIRED_AGE)) {\n    ...\n} else {\n    ...\n}",
					"badExample": "if ((employee.flags & HOURLEY_FLAG) && (employee.age &gt; RETIRED_AGE)) {\n    ...\n} else if ((employee.flags & HOURLEY_FLAG) && (employee.age &lt; RETIRED_AGE)) {\n    ...\n} else if ((employee.flags & HOURLEY_FLAG) && (employee.age == RETIRED_AGE)) {\n    ...\n}",
					"recommend": "增加else分支",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CTL.01 不要在控制性条件表达式中执行赋值操作或执行复杂的条件判断",
					"language": "java",
					"id": "51be8bc80fef11edb78384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "复杂的条件判断是指在一个条件表达式中boolean运算符数量超过3（Checkstyle工具BooleanExpressionComplexity）。\n在控制性条件表达式中执行赋值或执行复杂的条件判断，常常导致意料之外的行为，且代码的可读性非常差。\n\n工具检查场景:\n- 检查控制条件表达式中是否将变量与true或false比较（冗余）\n- 检查控制条件表达式中是否有赋值操作\n- 检查控制条件表达式中是否超过3个子条件表达式",
					"systemTag": "fixbotengine-java",
					"goodExample": "boolean isFoo = someBoolean; // 在上面赋值，if条件判断中直接使用\nif (isFoo)\n\npublic void fun(boolean isBar) {\n    boolean isFoo = isBar;   // 在上面赋值，if条件判断中直接使用\n    if (isFoo) {\n        ...\n    }\n}\n\npublic void fun(boolean isBar, boolean isFlag) {\n    boolean isFoo = isBar;   // 在上面赋值，while条件判断直接使用\n    while (isFoo && isFlag) {\n        ...\n    }\n}",
					"badExample": "if (isFoo = false)  // 在控制性判断中赋值不易理解\n\nif (isFoo == false) // 冗余不简洁，容易出错\n\nif (false == isFoo) // 冗余不简洁，容易出错\n\npublic void fun(boolean isBar) {\n    boolean isFoo;\n    if (isFoo = isBar) {\n        ...\n    }\n}\n\npublic void fun(boolean isBar, boolean isFlag) {\n    boolean isFoo;\n    while ((isFoo = isBar) && isFlag) {\n        ...\n    }\n}",
					"recommend": "拆分控制条件表达式",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.COL.04 不要在foreach循环中通过remove()/add()方法更改集合",
					"language": "java",
					"id": "51be8bca0fef11ed821b84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "不要在foreach循环中通过remove()/add()方法更改集合\n\n工具检查场景:\n- 检查foreach循环中是否有调用循环变量（集合变量）的`remove()`或`add()`方法\n- 例外场景\n  - `remove()`/`add()`的下个语句是return或break语句\n  - `remove()`/`add()`是循环体的最后一个语句",
					"systemTag": "fixbotengine-java",
					"goodExample": "// 使用Java 8 Collection中的removeIf方法\nlist.removeIf(item -&gt; shouldDelete(item));\n\n// 使用Iterator删除元素\nIterator&lt;String&gt; iterator = list.iterator();\nwhile (iterator.hasNext()) {\n    String item = iterator.next();\n    if (shouldDelete(item)) {\n        iterator.remove();\n    }\n}",
					"badExample": "以下代码，某些场景下可正常删除集合中的元素，但大部分场景下会抛出ConcurrentModificationException。\nfor (String item : list) {\n    if (shouldDelete(item)) {\n        list.remove(item);\n    }\n}",
					"recommend": "使用迭代器",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CTL.04 禁止使用空的无限循环",
					"language": "java",
					"id": "51be8bcc0fef11ed871084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "编写一个空的循环体，不会完成具体功能，反倒可能会消耗CPU；另一方面，如果刻意编写空循环来消耗CPU，却又可能被编译器或者JIT优化而消除。总之，空的循环体要么没有意义，要么不能确保符合开发者的预期。因此，禁止使用空的无限循环。\n\n\n工具检查场景:\n- 检查代码中是否有条件表达式为true且循环体为空的while语句",
					"systemTag": "fixbotengine-java",
					"goodExample": "public final int INTERVAL = 10000; // 单位：毫秒\n\npublic void alwaysRun() {\n    while (true) {\n        try {\n            Thread.sleep(INTERVAL);\n        } catch (InterruptedException ex) {\n            ...\n        }\n    }\n}",
					"badExample": "public void alwaysRun() {\n    while (true) {\n        // 什么也不做\n    }\n}\n上述示例中，编写了一个alwaysRun()方法试图模拟一个空闲任务，然而它并非一定能满足开发者的预期，因为编译器或者JIT可能会因为优化而删除这个循环。",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.ERR.07 一个方法不应抛出超过5个异常，并在Javadoc的@throws标签中记录每个抛出的异常及其条件",
					"language": "java",
					"id": "51be8bce0fef11edb82984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "方法抛出过多的异常，会增加客户端异常处理的工作，同时也表明方法承担了过多的职责。如果没有为抛出的异常建立Javadoc，其他人就很难或者根本不可能有效地使用你的类和接口。\n\n工具检查场景:\n- 检查方法是否抛出5个以上的异常；本规则不检查方法的javadoc中的@throws标签，在G.CMT.03和G.CMT.04中检查\n- 例外场景\n  - 重写方法（@Override）不检查",
					"systemTag": "fixbotengine-java",
					"goodExample": "",
					"badExample": "public void test() throws E1, E2, E3, E4, E5, E6 {\n    }",
					"recommend": "减少抛出的异常类型",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.ERR.01 不要通过一个空的catch块忽略异常",
					"language": "java",
					"id": "51be8bd00fef11ed999084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "空的catch块会使异常达不到应有的目的。\n\n工具检查场景:\n- 检查catch块是否为空\n- 例外场景\n  - 空的catch块所属的try语句中有close方法调用（对应规范中的场景：释放资源类操作2是在finally代码段中执行，发生异常只会导致资源没有被释放，不会对程序产生其他影响，不需要执行任何恢复动作）",
					"systemTag": "fixbotengine-java",
					"goodExample": "InputStream inputStream = null;\ntry {\n    inputStream = new InputStream(null);\n    doSomething();\n} catch (MyException t) {\n    logger.error(\"something is wrong\");\n} finally {\n    try {\n        inputStream.close();\n    } catch (IOException e) {\n    }\n}",
					"badExample": "InputStream inputStream = null;\ntry {\n    inputStream = new InputStream(null);\n    doSomething();\n} catch (SomeException ex) {\n}",
					"recommend": "增加异常处理逻辑",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.ERR.02 不要直接捕获异常的基类Throwable、Exception、RuntimeException",
					"language": "java",
					"id": "51be8bd20fef11ed802b84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "捕获受检异常的目的是为了进行恢复，而如果不加区分的捕获所有受检异常，则无法进行对应异常的恢复处理。\n\n工具检查场景：\n- 检查try块是否直接捕获Throwable\n- 检查try块的第一个catch语句是否捕获Exception或RuntimeException\n- 检查用同一个处理逻辑的多个catch语句，是否使用并语法`(ExceptionType1 | ... | ExceptionTypeN 变量)`来减少重复代码",
					"systemTag": "fixbotengine-java",
					"goodExample": "catch (ParseException | IOException exception) {\n    // 处理异常\n}",
					"badExample": "catch (Exception exception) {\n    // 处理异常\n}",
					"recommend": "区分受检异常",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.ERR.10 尽量消除非受检的异常，不应该在整个类上使用SuppressWarning",
					"language": "java",
					"id": "51be8bd40fef11ed84d084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "在源代码中通过@SuppressWarning(\"unchecked\")屏蔽告警，是个坏的实践。\n它丢失了类型安全和描述性的好处。\n\n\n工具检查场景:\n- 检查类/接口/枚举声明上是否有@SuppressWarnings标签",
					"systemTag": "fixbotengine-java",
					"goodExample": "public class SuppressWarningsTest {\n     public void test(List&lt;String&gt; list) {\n     }\n }",
					"badExample": "@SuppressWarnings(\"uncheck\")\n public class SuppressWarningsTest {\n     public void test(List&lt;String&gt; list) {\n     }\n }",
					"recommend": "正确处理unchecked warning，删除@SuppressWarning标签",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.ERR.05 方法抛出的异常，应该与本身的抽象层次相对应",
					"language": "java",
					"id": "51beb2c50fef11ed968084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "当方法把一个异常传给调用方时，请确保异常的抽象层次与方法的抽象层次是一致的。定义异常时应该区分checked/runtime异常，避免直接抛出RuntimeException，更不应该直接抛出Exception或Throwable。\n\n工具检查场景:\n- 检查方法是否抛出Exception、RuntimeException、Throwable或Error",
					"systemTag": "fixbotengine-java",
					"goodExample": "public class Employee {\n    ...\n    public TaxId getTaxId() {\n        ...\n       throw new EmployeeDataNotAvailable();\n    }\n    ...\n}",
					"badExample": "public class Employee {\n    ...\n    public TaxId getTaxId() {\n        ...\n        throw new RuntimeException();\n    }\n    ...\n}\ngetTaxId把更底层的RuntimeException返回给调用方，使调用方代码与底层耦合起来。\n推荐：抛出EmployeeDataNotAvailable异常，抽象层次与方法一致",
					"recommend": "对底层异常进行封装",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.ERR.08 在finally块中不要使用return、break或continue使finally块非正常结束(通用)",
					"language": "java",
					"id": "51beb2c70fef11edb51984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "在finally中使用return、break或continue会使finally块非正常结束，造成的影响是，即使在try块或catch中抛出了异常，也会因为finally非正常结束而导致无法抛出。finally块非正常结束会有编译告警。\n\n工具检查场景:\n- 检查finally块中是否有return, break, continue或throws语句",
					"systemTag": "fixbotengine-java",
					"goodExample": "",
					"badExample": "public static void main(String[] args) {\n    try {\n        System.out.println(func());\n    } catch (MyException ex) {\n        // 处理异常\n    }\n}\n\npublic static int func() throws MyException {\n    for (int i = 1; i &lt; 2; i++) {\n        try {\n            throw new MyException();\n        } finally {\n            continue; // 不推荐\n        }\n    }\n    return 0;\n}\n上述示例中，main方法中不会捕获到异常，而是直接输出0。",
					"recommend": "去除finally中非正常结束语句",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.COL.02 优先使用泛型集合，而不是数组",
					"language": "java",
					"id": "51beb2c90fef11ed8cd484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "数组与泛型集合相比，有两个重要不同点。首先，数组是协变的(covariant)，即Sub是Super的子类型，则Sub[]也是Super[]的子类型。\n相反，泛型则是不可变的(invariant)，对于任意两个类型Type1和Type2，即使Type1和Type2有继承关系，但是List&lt;Type1&gt;既不是List&lt;Type2&gt;的子类型，也不是其超类型。其次，数组是具体化的，因此数组在运行时才知道并检查它们的元素类型约束。\n如想利用数组的协变得到一个“泛型化的数组”，但是泛型与数组不能很好地混合使用，更好地选择是用列表。\n\n工具检查场景:\n- 检查是否使用Object[]或T[](泛型数组)\n- 检查是否使用X[] x = new Y[];",
					"systemTag": "fixbotengine-java",
					"goodExample": "private final List&lt;T&gt; lists; // 泛型列表\nprivate final List&lt;String&gt; longs; // 具体化的列表\n\nList&lt;Object&gt; objectList = new ArrayList&lt;String&gt;(DEFAULT_CAPACITY); // 不兼容类型，编译报错\nobjectList.add(\"test value\");",
					"badExample": "private final T[] someArray; // 泛型数组，不建议\nprivate final Object[] objArray; // 协变化的数组声明，不建议\n\nObject[] objectArray = new Integer[10]; // 协变化的数组初始化，不建议\nobjectArray[0] = \"test value\"; // 运行时抛出ArrayStoreException\n上述示例中，代码是合法的，但运行时会报错。",
					"recommend": "使用泛型集合",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.LOG.03 日志必须分等级",
					"language": "java",
					"id": "51beb2cb0fef11eda48f84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "如果日志不分等级，则定位问题时，无法快速有效屏蔽大量低级别信息，给快速定位带来难度。\n\n工具检查场景:\n- 检查info及以下级别（debug，trace，verbose）的日志中是否有变量拼接操作但没有使用条件形式\n- 例外场景\n  - 不检查安卓的日志打印（android.util.Log）",
					"systemTag": "fixbotengine-java",
					"goodExample": "// 如果日志库提供了带\"msgSupplier\"的API，如下这样调用可以消除不必要的消息创建\nLOGGER.debug(() -&gt;\n    \"Processing trade with id: \" + id + \" and symbol: \" + symbol.fetchBigMessage());\n\n// 采用条件方式\nif (LOGGER.isDebugEnabled()) {\n    LOGGER.debug(\"Processing trade with id: \" + id + \" and symbol: \" + symbol);\n}\n\n// 或者使用占位符\nLOGGER.debug(\"Processing trade with id: {} and symbol: {}\" , id, symbol);",
					"badExample": "如果日志级别设置为warning，下面日志不会打印，但是会执行字符串拼接操作，如果symbol是对象，会执行toString()方法，这样执行了上述操作，浪费系统资源，最终日志却没有打印。\nLOGGER.debug(\"Processing trade with id: \" + id + \" and symbol: \" + symbol);",
					"recommend": "采用占位符或条件判断",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.LOG.02 日志工具Logger类的实例应声明为private static final或者private final",
					"language": "java",
					"id": "51beb2cd0fef11ed9e2184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "如果声明时并初始化了，应该是private static final，如果只是声明没有初始化赋值的，则可以是private final。\n\n工具检查场景:\n- 检查声明并初始化的Logger类的实例，是否使用private static final修饰词\n- 检查声明但没初始化的Logger类的实例，是否使用private final修饰词",
					"systemTag": "fixbotengine-java",
					"goodExample": "private static final Logger LOGGER =\n    LoggerFacotry.getLogger(com.huawei.product.MyClass.class);",
					"badExample": "Logger LOGGER = LoggerFacotry.getLogger(com.huawei.product.MyClass.class);",
					"recommend": "增加相应的修饰词",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.LOG.01 记录日志应该使用Facade模式的日志框架",
					"language": "java",
					"id": "51beb2cf0fef11eda8b784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "专用日志工具比控制台打印提供了更丰富的日志记录功能，且使用更加简单。\n\n\n- 检查代码中是否出现System.out.print和System.err.print",
					"systemTag": "fixbotengine-java",
					"goodExample": "start = System.currentTimeMillis();\n// 其他加载数据的代码\nLOGGER.info(\"items loaded, use {}ms.\", (System.currentTimeMillis() - start));",
					"badExample": "start = System.currentTimeMillis();\n// 其他加载数据的代码\nSystem.out.println (\"items loaded, use \" + (System.currentTimeMillis() - start) + \"ms.\");",
					"recommend": "使用日志打印",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.LOG.04 非仅限于中文区销售产品禁止用中文打印日志",
					"language": "java",
					"id": "51beb2d10fef11edae8484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "非仅限于中文区销售产品禁止用中文打印日志\n\n工具检查场景:\n- 检查日志打印方法（`trace`, `verbose`, `debug`, `info`, `error`, `warn`）参数的字符串中是否有中文",
					"systemTag": "fixbotengine-java",
					"goodExample": "String message = \"message\";\n    ...\n    LOGGER.debug(\"Chinese\" + message); ",
					"badExample": "String message = \"消息\";\n    ...\n    LOGGER.debug(\"中文\" + message); ",
					"recommend": "修改成对应语言",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.NAM.02 包名中的字母应小写，包名以点号分隔层级",
					"language": "java",
					"id": "51beb2d30fef11ed9b4c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "包名都是小写的，连续的单词简单地连接在一起（没有下划线），再加上产品名称和模块名称。部门内部应该规划好包名的范围，防止产生冲突。包名允许有数字，例如org.apache.commons.lang3、xxx.yyy.v2。所有的源文件都要设置一个具体的package。\n\n工具检查场景:\n- 检查包名是否满足正则表达式^(_[0-9]+)?[a-z0-9]*$\n- 下划线只能在一些特殊情况使用，如包名以数字开头或是java中保留关键字时，如:int_.example、com.example._123name",
					"systemTag": "fixbotengine-java",
					"goodExample": "package com.huawei.test;",
					"badExample": "package com.huawei.Test;",
					"recommend": "修改包名",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.NAM.03 类、枚举和接口名应采用大驼峰命名",
					"language": "java",
					"id": "51beb2d50fef11ed874c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "类名通常是名词或名词短语，采用首字母大写的驼峰命名法UpperCamelCase。例如， Character或 ImmutableList。接口名称也可以是名词或名词短语（例如List），但有时可能是形容词或形容词短语（例如Readable）。\n说明：类的命名，不应用动词，而应使用名词，比如Customer，WikiPage，Account；避免采用类似Manager，Processor，Data，Info这样模糊的词。\n测试类以它们正在测试的类的名称开头，并以Test结尾。例如，HashTest或HashIntegrationTest。\n抽象类命名时推荐以Abstract或Base开头。\n\n工具检查场景:\n- 检查类、枚举和接口名是否采用大驼峰命名（`^[A-Z][a-zA-Z0-9]*$`)\n",
					"systemTag": "fixbotengine-java",
					"goodExample": "class MarcoPolo {}\ninterface TaPromotion {}\nclass OrderInfo {}",
					"badExample": "class marcoPolo {}\ninterface TAPromotion {}\nclass info {}",
					"recommend": "修改类型名",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.NAM.04 方法名应采用小驼峰命名",
					"language": "java",
					"id": "51beb2d70fef11edb31d84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "方法名称通常是动词或动词短语，并采用首字母小写的驼峰命名法lowerCamelCase。\n\n\n工具检查场景:\n- 检查方法名是否采用小驼峰命名（`^[a-z][a-zA-Z0-9]*$`)\n- 例外场景\n  - 不检查Junit单元测试方法（@Test，@Before，@After...）\n  - 不检查覆写的方法（@Override）",
					"systemTag": "fixbotengine-java",
					"goodExample": "public boolean isFinished()\npublic void setVisible(boolean)\npublic void draw()\npublic void addKeyListener(Listener)\nboolean hasNext()",
					"badExample": "public boolean Finished()\npublic void visible(boolean)\npublic void DRAW()\npublic void KeyListener(Listener)\nboolean next()",
					"recommend": "修改方法名",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.NAM.05 常量名采用全大写单词，单词间以下划线分隔",
					"language": "java",
					"id": "51bed9d10fef11ed995384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "1. 常量是静态最终字段，其内容不可变，其方法没有可检测的副作用。这包括基本类型，字符串，不可变类型和不可变类型的不可变/不可修改集合。\n2. 常量命名，由全大写单词组成，单词间用下划线分隔CONSTANT_CASE，且使用 static final修饰。\n3. 常见的用于内容不可变场景的，例如Logger，Lock等对象，其命名既可以全大写来强调，也可以按普通变量命名。\n4. 不要使用魔鬼数字(难以理解的数字或字符串)，用有意义的常量代替。SQL或日志的字符串，不应视为魔鬼数字，不需定义为字符串常量；\n\n工具检查场景:\n- 检查常量名是否全大写并以下划线分隔(^[A-Z0-9_]+$)，常量为static和final同时修饰的类成员\n- 例外场景\n  - Logger常量\n  - Lock常量\n  - serialVersionUID",
					"systemTag": "fixbotengine-java",
					"goodExample": "static final int MAX_USER_NUM = 200;\nstatic final String APPLICATION_NAME = \"Launcher\";\nstatic final int MAX_FILE_NUM = 5;",
					"badExample": "static int MAXUSERNUM = 200;\nstatic String sL = \"Launcher\";\nstatic final int NUM_FIVE = 5;\nstatic final int NUM_5 = 5;",
					"recommend": "修改常量名",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.NAM.07 避免使用具有否定含义布尔变量名",
					"language": "java",
					"id": "51bed9d30fef11ed8ff084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "当使用逻辑非运算符并出现双重否定时，会出现理解问题。!isNotError意味着什么，不是很直白。\nJavaBeans规范会对布尔型的类的属性自动生成isXxx()的getter。但此条目不是强制要求所有的布尔变量以is开头。\n为避免有些自动处理工具（Spring，IDE，Lombok）对类的布尔属性的意外处理，不强制要求以is命名类的布尔属性。\n\n工具检查场景:\n- 检查布尔变量名是否具有否定含义（包含no或not）\n注意，IDE可以定制getter/setter代码生成模版；序列化等框架也是可设置注解的，例如更改序列化字段名",
					"systemTag": "fixbotengine-java",
					"goodExample": "boolean isError;\nboolean isFound;\n",
					"badExample": "boolean isNoError;\nboolean isNotFound;",
					"recommend": "修改变量名，去除否定含义的词",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.NAM.06 变量采用小驼峰命名",
					"language": "java",
					"id": "51bed9d50fef11edac2584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "变量、属性、参数等非常量字段的名称通常是名词或名词短语，应采用首字母小写的驼峰命名法(lowerCamelCase)。\n即使局部变量是final或不可改变(immutable)的，也不应该把它视为常量，自然也不能用常量的规则去命名。\n\n工具检查场景:\n- 检查变量名（类成员变量、类变量、方法参数，局部变量）是否采用小驼峰命名（^[a-z][a-zA-Z0-9]*$）",
					"systemTag": "fixbotengine-java",
					"goodExample": "String customerName;\nList&lt;String&gt; users = new ArrayList&lt;&gt;(DEFAULT_CAPACITY);",
					"badExample": "String Customername;\nList&lt;String&gt; User = new ArrayList&lt;&gt;(DEFAULT_CAPACITY);",
					"recommend": "修改变量名",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CMT.03 方法的Javadoc中应该包含功能说明，根据实际需要按顺序使用@param、@return、@throws标签对参数、返回值、异常进行注释",
					"language": "java",
					"id": "51bed9d70fef11ed869584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "方法的Javadoc中应该包含功能说明，根据实际需要按顺序使用@param、@return、@throws标签对参数、返回值、异常进行注释\n\n工具检查场景:\n- 检查方法的Javadoc是否有功能说明；如果没有Javadoc，这条规则不告警，会在G.CMT.01中告警\n- 检查方法的Javadoc的功能描述与标签之间是否只空1行，没有空行和多余空行都会告警\n- 如果方法有参数，检查Javadoc中是否对每个参数都有@param标签\n- 如果方法有返回值，检查Javadoc中是否有@return标签\n- 如果方法有抛异常，检查Javadoc中是否对每个异常都有@throws标签\n- 检查标签是否按照@param、@return、@throws的顺序排列\n- 检查Javadoc第一行或最后一行不能有注释内容\n- 例外场景：\n  - 不检查继承的Javadoc（ @inheritDoc）\n  - 不检查隐藏的Javadoc（@hide）",
					"systemTag": "fixbotengine-java",
					"goodExample": "/**\n * 对示例接口的概述介绍\n *\n * @since 2019-01-01\n */\nprotected abstract class Sample {\n    /**\n     * 这是一段长注释，要根据注释内容进行合理拆分为多行注释...\n     * 这是第二行注释。\n     * 符合： 功能说明要与下面的@标签之间保留一个空行\n     *\n     * @param fox 参数fox的说明，例如：与懒狗进行挑战的狐狸对象\n     * @return 方法返回值的说明，例如：返回狐狸与狗的交战结果\n     */\n    protected abstract int foo(Fox fox);\n\n    /**\n     * 函数的功能说明\n     * 符合： 功能说明要与下面的@标签之间保留一个空行\n     *\n     * @return 方法返回值的说明，例如：返回狐狸与狗的交战结果\n     * @throws ProblemException 异常说明，例如：懒狗死亡抛出该异常\n     */\n    protected int bar() throws ProblemException {\n        // 变量注释\n        var aVar = ...;\n\n        // 方法注释  符合：注释要与前面的代码之间保留一个空行\n        doSome();\n    }\n}",
					"badExample": "/**\n     */\n    public void methodDemo() {\n    }",
					"recommend": "增加功能说明和相应标签",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CMT.01 public或protected修饰的元素应添加Javadoc注释",
					"language": "java",
					"id": "51bed9d90fef11edafa784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "在最低限度，Javadoc用于每一个 public或 protected 修饰的类、接口、枚举、方法和成员字段，其他类和成员可以根据需要来写Javadoc。非public非protected的方法，命名无法表达的信息，应该加注释辅助说明，方法头注释统一放在方法声明或定义上方。\n\n工具检查场景:\n- 检查每个public或protected修饰的类、接口、枚举、类方法和类属性是否没有Javadoc注释（方法注释为单行注释或块注释也会告警）\n- 例外场景：\n  - 不检查main方法\n  - 不检查@Override（重写）方法\n  - 不检查Junit框架中的测试方法\n  - 不检查get/set等简单方法，简单方法判断标准：方法中只有一个return语句，或方法中只有对成员变量的赋值语句，或this(..)/super(...)方法调用",
					"systemTag": "fixbotengine-java",
					"goodExample": "/**\n  * 功能描述\n  *\n  * @since 1.0\n  */\npublic class ClassDemo {\n    /**\n     * 成员变量描述\n     */\n    protected int varDemo;\n    \n    /**\n     * 方法描述\n     */\n    public void methodDemo() {\n    }\n        \n    @Override\n    public void overrideMethodDemo() {\n    }\n        \n    public int getVarDemo() {\n        return varDemo;\n    }\n        \n    public static void main(String[] args) {\n    }\n}",
					"badExample": "public class ClassDemo {\n     protected int varDemo;\n        \n    public void methodDemo() {\n    }\n}",
					"recommend": "增加Javadoc",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CMT.02 顶层public类的Javadoc应该包含功能说明和创建日期/版本信息",
					"language": "java",
					"id": "51bed9db0fef11ed80e384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "顶层public类的Javadoc中应该有功能说明、@since信息。产品自主决定是否添加@author（作者信息），其中名字（拼音或英文）可选，工号与邮箱不推荐添加到注释中；对外开源的代码不推荐添加@author。日期格式为Java 8 time包中的ISO_DATE，例如“2011-12-03”或者“2011-12-03+01:00”。\n\n工具检查场景:\n- 检查顶层pulic类的Javadoc是否有功能说明；如果没有Javadoc，这条规则不告警，会在G.CMT.01中告警\n- 检查顶层pulic类的Javadoc是否包含@since标签\n- 检查顶层pulic类的Javadoc的功能描述与标签之间是否只空1行，没有空行和多余空行都会告警",
					"systemTag": "fixbotengine-java",
					"goodExample": "/**\n * 功能描述\n *\n * @author 王二\n * @since 2012-12-22（或版本号）\n */\npublic class TopClass {\n}",
					"badExample": "/**\n * @author 王二\n */\npublic class TopClass {\n}",
					"recommend": "增加功能说明和@since",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CMT.04 不写空有格式的方法头注释",
					"language": "java",
					"id": "51bed9dd0fef11ed94b484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "对于不需要添加注释的方法无需添加空有格式的注释，这样代码更整洁。\n\n工具检查场景:\n- 检查方法的Javadoc中@param标签后面是否紧跟描述（描述的起始行必须和标签在同一行）\n- 检查方法的Javadoc中@return标签后面是否紧跟描述（描述的起始行必须和标签在同一行）\n- 检查方法的Javadoc中@throws标签后面是否紧跟描述（描述的起始行必须和标签在同一行）",
					"systemTag": "fixbotengine-java",
					"goodExample": "/**\n     * 方法描述\n     *\n     * @param varDemo 示例变量\n     */\n    public void methodDemo(int varDemo) {\n    }",
					"badExample": "/**\n     * 方法描述\n     *\n     * @param varDemo\n     */\n    public void methodDemo(int varDemo) {\n    }",
					"recommend": "增加描述信息",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.OTH.03 不用的代码段包括import，直接删除，不要注释掉——不用的import语句，直接删除，不要注释掉",
					"language": "java",
					"id": "51bed9df0fef11ed8bae84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "不用的import，增加了代码的耦合度，不利于维护。\n被注释掉的代码，无法被正常维护；当企图恢复使用这段代码时，极有可能引入易被忽略的缺陷。 \n正确的做法是，不需要的代码直接删除掉。若再需要时，考虑移植或重写这段代码。\n这里说的注释掉代码，包括用 /** */， /* */ 和 // 等等。\n\n工具检查场景:\n- 检查是否有无用的import语句\n- 检查是否有注释掉的代码",
					"systemTag": "fixbotengine-java",
					"goodExample": "int b;",
					"badExample": "// int a;\nint b;",
					"recommend": "删除注释或无用import语句",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.OTH.03 不用的代码段包括import，直接删除，不要注释掉——不用的代码段，直接删除，不要注释掉",
					"language": "java",
					"id": "51bed9e10fef11ed93cd84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "不用的import，增加了代码的耦合度，不利于维护。\n被注释掉的代码，无法被正常维护；当企图恢复使用这段代码时，极有可能引入易被忽略的缺陷。 \n正确的做法是，不需要的代码直接删除掉。若再需要时，考虑移植或重写这段代码。\n这里说的注释掉代码，包括用 /** */， /* */ 和 // 等等。\n\n工具检查场景:\n- 检查是否有无用的import语句\n- 检查是否有注释掉的代码",
					"systemTag": "fixbotengine-java",
					"goodExample": "int b;",
					"badExample": "// int a;\nint b;",
					"recommend": "删除注释或无用import语句",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CMT.07 正式交付给客户的代码不应包含TODO/FIXME注释",
					"language": "java",
					"id": "51bed9e30fef11edb4d184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "TODO 注释2用来描述已知待改进、待补充的修改点。FIXME 注释2用来描述已知缺陷。在版本开发阶段，可以使用此类注释用于突出标注；交付前应该全部处理掉。\n\n工具检查场景:\n- 检查注释中是否以TODO或FIXME开头",
					"systemTag": "fixbotengine-java",
					"goodExample": "int var;",
					"badExample": "// TODO(&lt;author-name&gt;): 补充XX处理\n// FIXME: XX缺陷\nint var;",
					"recommend": "删除TODO注释",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CMT.06 注释与代码之间应该有空行或空格，注释符与注释内容之间应该有空格",
					"language": "java",
					"id": "51bf00e70fef11edbe2584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "Javadoc注释正文（2是功能描述），与其下的各个Javadoc tag之间加1个空行；类级成员（2是类或接口中的字段、方法，嵌套类/内部类依次类推），注释与上面的代码之间加一个空行，但是如果上面已经是本范围（2是个大括号），则不用加空行。\n在方法内部（语句级），注释与上面的代码之间可以考虑加一个空行，以便更加清晰，但工具不作扫描。空行不会作为NBNC计数。\n\n工具检查场景:\n- 检查类级成员注释与上面的代码之间是否有空行\n- 检查注释符与注释内容之间是否有空白字符（空格或制表符）\n- 检查右置注释与左侧代码之间是否有空白字符（空格或制表符）",
					"systemTag": "fixbotengine-java",
					"goodExample": "int foo = 100; // 变量注释",
					"badExample": "int foo = 100;//变量注释",
					"recommend": "增加空行或空格",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.04 一个类或接口的声明部分应该按照类变量、静态初始化块、实例变量、实例初始化块、构造器、方法的顺序出现，且用空行分隔",
					"language": "java",
					"id": "51bf00e90fef11ed97d184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "一个类或接口的声明部分应该按照以下顺序排列：\n1.类（静态）变量\n2.静态初始化块\n3.实例变量\n4.实例初始化块\n5.构造器\n6.方法或嵌套类，嵌套类可以与成员方法根据业务7.逻辑交替出现，把概念上相近的放在一起，无需把所有嵌套类都下移至文件底部\n8.类（静态）变量、实例变量、构造器，均按访问修饰符从大到小排列：public、protected、package（default）、private\n\n说明：\n1.对于自注释成员变量之间可以不加空行；\n2.非自注释成员变量应该加注释且成员变量间以空行分隔。\n【例外】\n类中的LOG控制开关和TAG的声明，修饰符定义为private static final，允许放在类中的最前面。包括TAG、mTAG、STAG、DBG、DEBUG、logger、xxxLogger，不以名字的大小写区分。\n\n2021年4月8日：新增不同成员组之间（如成员变量和成员方法之间）没有空行检查\n\n工具检查场景:\n- 检查类或接口声明部分是否按如下顺序：\n  - public类变量\n  - protected类变量\n  - package(default)类变量\n  - private类变量\n  - 静态初始化块\n  - public实例变量\n  - protected实例变量\n  - package(default)实例变量\n  - private实例变量\n  - 实例初始化块\n  - public构造方法\n  - protected构造方法\n  - package(default)构造方法\n  - private构造方法\n  - 方法或嵌套类\n- 检查类变量、静态初始化块、实例变量、实例初始化块、构造器、方法之间是否有空行",
					"systemTag": "fixbotengine-java",
					"goodExample": "public class ClassDemo {\n    public static int varDemo8;\n    protected static int varDemo7;\n    static int varDemo6;\n    private static int varDemo5;\n     \n    static {\n        int temp = 0;\n    }\n        \n    public int varDemo4;\n    protected int varDemo3;\n    int varDemo2;\n    private int varDemo;\n    \n    {\n        int temp = 0;\n    }\n        \n    public DeclarationOrderTest(Float c) {}\n    protected DeclarationOrderTest(String b) {}\n    DeclarationOrderTest() {}\n    private ClassDemo(int a) {}\n    \n    private void privateMethod() {}\n    static class StaticClass {}\n}",
					"badExample": "public class ClassDemo {\n    static class StaticClass {}\n    private void privateMethod() {}\n     \n    private ClassDemo(int a) {}\n    DeclarationOrderTest() {}\n    protected DeclarationOrderTest(String b) {}\n    public DeclarationOrderTest(Float c) {}\n     \n    {\n        int temp = 0;\n    }\n     \n    private int varDemo;\n    int varDemo2;\n    protected int varDemo3;\n    public int varDemo4;\n    \n    static {\n      int temp = 0;\n    }\n     \n    private static int varDemo5;\n    static int varDemo6;\n    protected static int varDemo7;\n    public static int varDemo8;\n}",
					"recommend": "按顺序排列类中成员",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.02 一个源文件按顺序包含版权、package、import、顶层类，且用空行分隔",
					"language": "java",
					"id": "51bf00eb0fef11edb7e784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "一个源文件中应按顺序包含以下信息：\n许可证或版权信息；\npackage语句，且不换行；\nimport语句，且不换行，不能用通配符*；\n一个顶级类 (只有一个)，在一个与它同名的.java源文件中。\n以上每个部分之间用一个空行隔开。\n\n工具检查场景:\n- 检查版权信息与package之间是否有空行\n- 检查package语句是否有换行\n- 检查package语句和import语句之间是否有空行\n- 检查每个import语句是否有换行\n- 检查import语句是否有通配符*\n- 检查import语句和顶层类之间是否有空行\n- 例外场景\n  - 不检查package-info.java文件",
					"systemTag": "fixbotengine-java",
					"goodExample": "/*\n     * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.\n     */\n     \n    package com.huawei.demo;",
					"badExample": "/*\n     * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.\n     */\n    package com.huawei.demo;",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.16 case语句块结束时如果不加break，需要有注释说明(fall-through)",
					"language": "java",
					"id": "51bf00ed0fef11edbc6884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "在switch块内，每个语句组会突然终止（用 break， continue， return或抛出的异常），或标有注释，表明执行会或可能会持续到下一个语句组。加上fall-through概念的注释即可（通常 // fall through）。在switch块的最后一个语句组中不需要此特殊注释。\nEclipse和IntelliJ IDEA支持$FALL-THROUGH$这种特殊的注释，来suppress缺少break的告警。尽管这不是Java的标准，但它被主流的IDE支持，推荐优先使用。\n注意，当javac开启 -Xlint:fallthrough选项编译时 ，加与不加$FALL-THROUGH$，它可能都会告警；修复此告警可以考虑改用if else if写法替代switch case。\n如果case语句是空语句，则可以不用加注释特别说明。\n\n工具检查场景：\n- 检查case语句块的结束语句不是break/return/continue/throws，是否有注释说明\n- 例外场景\n  - 最后一个case语句块不检查\n  - 空的case语句块不检查",
					"systemTag": "fixbotengine-java",
					"goodExample": "switch (label) {\n    case 0:\n    case 1:\n        System.out.println(\"1\");\n        // $FALL-THROUGH$\n    case 2:\n        System.out.println(\"2\");\n        // $FALL-THROUGH$\n    case 3:\n        System.out.println(\"3\");\n        break;\n    default:\n        System.out.println(\"Default case!\");\n}",
					"badExample": "switch (label) {\n    case 0:\n    case 1:\n        System.out.println(\"1\");\n    case 2:\n        System.out.println(\"2\");\n    case 3:\n        System.out.println(\"3\");\n        break;\n    default:\n        System.out.println(\"Default case!\");\n}",
					"recommend": "增加break语句或注释",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.17 应用于类、方法、类属性的每个注解独占一行",
					"language": "java",
					"id": "51bf00ef0fef11edb39184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "应用于类，方法或构造方法的注解都在其自己的行上（即，每行一个注解）\n\n工具检查场景:\n- 检查注解是否位于注解对象上方\n- 检查注解是否一行一个",
					"systemTag": "fixbotengine-java",
					"goodExample": "@Nullable\n    DataLoader loader;",
					"badExample": "@Nullable DataLoader loader;",
					"recommend": "注解一行一个",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.18 块注释的缩进级别应与上下文代码相同",
					"language": "java",
					"id": "51bf00f10fef11ed807484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "块注释与周围代码的缩进级别相同。它们可以是 /* ... */风格或 // ...风格。对于多行 /* ... */注释，后续行必须以*与*前一行对齐的方式开始 。\n\n2021年4月8日：修复注释在文件末尾越界问题\n\n\n工具检查场景:\n- 检查注释是否与下方代码的缩进级别相同\n- 检查多行注释中每行是否以`*`开头\n- 检查多行注释中每行内容是否对齐\n- 例外场景\n  - 如果注释行下方是右大括号（块语句的结尾），则检查注释是否比下方代码多缩进一层",
					"systemTag": "fixbotengine-java",
					"goodExample": "// comment\n    private void method(String str) {\n    }",
					"badExample": "// comment\n    private void method(String str) {\n    }",
					"recommend": "注释与代码对齐",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.19 类和成员修饰符（如果存在）按Java语言规范建议的顺序显示",
					"language": "java",
					"id": "51bf00f30fef11ed8af284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "推荐的顺序（如果存在）：\npublic protected private abstract default static final transient volatile synchronized native strictfp\n\n工具检查场景:\n- 检查类和成员修饰符是否按下列顺序排列：public protected private abstract default static final transient volatile synchronized native strictfp",
					"systemTag": "fixbotengine-java",
					"goodExample": "private static final int VAR = 0;",
					"badExample": "private final static int VAR = 0;",
					"recommend": "修饰符按顺序排列",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.20 数字字面量应该设置合适的后缀，long类型应该使用L作为后缀",
					"language": "java",
					"id": "51bf00f50fef11ed94d884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "对于long、float、double类型的数字要使用合理的后缀指定数值的类型。Java 10 增加了局部类型推断LVTI，一些字面量如果不加后缀，类型推断时可能出乎意料。为了形成良好的习惯，写出更健壮的代码，应参考LVTI的Style Guidelines。如果不加后缀，数值推断为int，float可能会推断为double。因此，应该在字面量后面加上后缀。\nlong值必须使用L后缀，禁止使用l（以避免与数字1混淆）。例如，使用3000000000L而不是3000000000l。其它d、f等不易引起混淆，不强制采用大写字母。\n\n2021年4月8日：新增以下场景检查（1）long常量不加L或用l（2）float常量不加f\n\n工具检查场景：\n- 检查long类型常量是否使用小写`l`作为后缀，float类型常量是否使用小写`f`作为后缀，double类型常量是否使用小写`d`作为后缀",
					"systemTag": "fixbotengine-java",
					"goodExample": "var idx = 0;   // 符合\nlong sum = 0L; // 符合\nvar sum = 0L;  // 符合：若不加后缀则会推断为int\n\nvar isReady = true; // 符合: boolean\nvar chr = '\\ufffd'; // 符合: char\nvar str = \"wombat\"; // 符合: String\nvar flt = 1.0f; // 符合: float\nvar dbl = 2.0d; // 符合: double",
					"badExample": "byte flags = 0;\nshort mask = 0x7fff;\n\n// 不符合: 如下两个声明的变量被推断为int\nvar flags = 0;\nvar mask = 0x7fff;\n\nstatic final float INITIAL = 3.0f;\ndouble amount = INITIAL;\nvar amount = INITIAL; // 不符合: 推断为float",
					"recommend": "增加相应后缀",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.05 在条件语句和循环块中应该使用大括号",
					"language": "java",
					"id": "51bf27d10fef11edb57384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "在条件语句和循环块中应该使用大括号\n\n2021年4月8日：新增循环块的检查（for, forEach, while, doWhile）\n\n工具检查场景:\n- 检查if， else， for，do和 while是否使用大括号",
					"systemTag": "fixbotengine-java",
					"goodExample": "public class ClassDemo {\n    private void method(String str, boolean bool, List&lt;String&gt; list) {\n        if (bool) {\n            System.out.println();\n        } else if (bool) {\n            System.out.println();\n        } else {\n            System.out.println();\n        }\n    \n        for (String s : list) {\n            System.out.println(s);\n        }\n    \n        for (int i = 0; i &lt; list.size(); i++) {\n            System.out.println(list.get(i));\n        }\n    \n        while (bool) {\n            System.out.println();\n        }\n    \n        do {\n            System.out.println();\n        } while (bool);\n    }\n}",
					"badExample": "public class ClassDemo {\n    private void method(String str, boolean bool, List&lt;String&gt; list) {\n        if (bool)\n            System.out.println();\n        else if (bool)\n            System.out.println();\n        else\n            System.out.println();\n  \n        for (String s : list)\n            System.out.println(s);\n          \n        for (int i = 0; i &lt; list.size(); i++)\n            System.out.println(list.get(i));\n    \n        while (bool)\n            System.out.println();\n    \n        do\n           System.out.println();\n        while (bool);\n    }\n}",
					"recommend": "增加大括号",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.06 对于非空块状结构，左大括号应该放在行尾，右大括号应该另起一行",
					"language": "java",
					"id": "51bf27d30fef11ed861e84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "对于非空块和块状结构（含初始化块），大括号遵循K&R风格（俗称埃及括号）：\n左大括号不换行；\n右大括号自己单独一行；\n右大括号后，可以跟逗号、分号等，也可以跟随 else、 catch、finally等关键字语句。\n\n工具检查场景:\n- 检查左大括号是否换行\n- 检查右大括号是否单独一行\n- 检查else、 catch、finally等关键字语句是否在行首",
					"systemTag": "fixbotengine-java",
					"goodExample": "try {\n    doSomething();\n} catch (MyException ex) {\n    handleException(ex);\n}",
					"badExample": "try {\n    doSomething();\n} catch (MyException ex) { handleException(ex); }",
					"recommend": "正确换行",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.08 使用空格进行缩进，每次缩进4个空格",
					"language": "java",
					"id": "51bf27d50fef11ed8faf84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "使用空格进行缩进，每次缩进4个空格\n\n工具检查场景:\n- 检查每行的缩进空格数是4的倍数",
					"systemTag": "fixbotengine-java",
					"goodExample": "public class ClassDemo {\n    int varDemo = 0;\n}",
					"badExample": "public class ClassDemo {\n int varDemo = 0;\n}",
					"recommend": "使用4个空格缩进",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.07 应该避免空块，必须使用空块时，应采用统一的大括号换行风格",
					"language": "java",
					"id": "51bf4dca0fef11edbf2184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "空块或块状结构遵循排版格式-大括号的要求，也可以在打开后立即关闭，在（{}）之间没有字符或换行符，除非它是 多块语句的一部分（if/else或者 try/catch/finally等）。\n\n\n工具检查场景:\n- 检查类（静态）初始化块、方法块、语句块是否为空块\n- 例外场景：\n  - 空的重写方法（@Overide）不检查\n  - 空的catch块不检查",
					"systemTag": "fixbotengine-java",
					"goodExample": "public class ClassDemo {\n    private void avoidEmptyBlock(String str) {\n        if (str.isEmpty()) {\n            doSomething();\n        }\n    }\n}",
					"badExample": "public class ClassDemo {\n    private void avoidEmptyBlock(String str) {\n        if (str.isEmpty()) {\n        }\n    }\n}",
					"recommend": "删除空块",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.09 每行不超过一个语句",
					"language": "java",
					"id": "51bf4dcc0fef11ed9e1984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "每个语句后面都有一个换行符\n\n工具检查场景:\n-检查一行是否有多个语句",
					"systemTag": "fixbotengine-java",
					"goodExample": "int a;\nint b;",
					"badExample": "int a; int b;",
					"recommend": "增加空行",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.10 行宽不超过120个窄字符",
					"language": "java",
					"id": "51bf4dce0fef11eda9cc84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "每行限长120个窄字符",
					"systemTag": "fixbotengine-java",
					"goodExample": "",
					"badExample": "",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.11 建议换行起点在操作符之前",
					"language": "java",
					"id": "51bf4dd00fef11ed961984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "当在非赋值运算符处断行时，中断点出现在 符号之前。\n这也适用于以下“类似运算符”的符号：\n点分隔符（.）；\n方法引用的两个冒号（::）；\n类型限定中的＆符号（&lt;T extends Foo & Bar&gt;）；\ncatch块中的管道（catch (FooException | BarException ex)）。\n\n2021年4月8日：新增算术运算符出现在行首的检查",
					"systemTag": "fixbotengine-java",
					"goodExample": "// 链式方法调用\nStudent student = Student.builder()\n    .setName(\"zhangsan\")\n    .setAge(14)\n    .setGrade(\"5年级\")\n    .setMajor(\"软件工程\")\n    .setNum(\"123456789\")\n    .build();",
					"badExample": "Student student = Student.builder().\n    setName(\"zhangsan\").\n    setAge(14).\n    setGrade(\"5年级\").\n    setMajor(\"软件工程\").\n    setNum(\"123456789\").\n    build();",
					"recommend": "按规范换行",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.12 减少不必要的空行，保持代码紧凑",
					"language": "java",
					"id": "51bf4dd20fef11edbe7384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "减少不必要的空行，可以显示更多的代码，方便代码阅读。下面有一些建议遵守的规则：\n根据上下内容的相关程度，合理安排空行：空行出现在字段，构造方法，方法，嵌套类，静态初始化块之间；\n方法内部、类型定义内部、初始化表达式内部，不使用连续空行；\n不使用连续3个空行，或更多；\n大括号内的代码块行首之前和行尾之后不要加空行，包括类型和方法定义、语句代码块。\n\n2021年4月8日：新增enum内部不必要空行检查\n\n工具检查场景:\n- 检查大括号内的代码块行首之后和行尾之前是否有空行\n- 检查方法内部、类型定义内部、初始化表达式内部，是否有连续2个或更多空行\n- 检查是否有连续3个或更多空行",
					"systemTag": "fixbotengine-java",
					"goodExample": "int foo() {\n    ...\n}\n // 空行\nint bar() {\n    ...\n}",
					"badExample": "int foo() {\n    ...\n}\n // 空行\n // 空行\n // 空行\nint bar() { // 不推荐：最多使用连续2个空行\n    ...\n}",
					"recommend": "删除多余空行",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.13 用空格突出关键字和重要信息",
					"language": "java",
					"id": "51bf4dd40fef11ed9b1784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "水平空格应该突出关键字和重要信息。单个空格应该分隔关键字与其后的左括号、与其前面的右大括号，出现在任何二元/三元运算符/类似运算符的两侧，,:;或类型转换结束括号)之后使用空格。行尾和空行不能有空格space。总体规则如下：\n必须加空格的场景：\n（包括复合）赋值运算符前后，例如 =、*= 等；\n逗号,、非for-in的冒号:、for循环等分隔的;符号之后加空格；\n二元操作符、类型并交的|和＆符号、for-in的冒号：的前后两侧，例如base + offset；\nlambda表达式中的箭头前后，例如 str -&gt; str.length()。\n禁止加空格的场景：\nsuper、this等少数关键字之后（多数关键字之后自然地须加空格）；\n成员访问操作符（instance.member）前后；\n圆括号、方括号、注解或数组等非换行的大括号内两侧；\n一元操作符前后，例如cnt++；\n函数声明或者函数调用的左括号之前。\n\n工具检查场景:\n- 检查关键字与其后的左括号、与其前面的右大括号之间是否有空格\n- 检查任何二元/三元运算符/类似运算符的两侧是否有空格\n- 检查逗号、冒号、分号或类型转换之后是否有空格\n- 检查成员访问操作符前后是否有空格\n- 检查一元运算符前后是否有空格\n- 检查圆括号、方括号、注解或数组等非换行的大括号内两侧前后是否有空格\n- 检查行尾或空行是否有空格",
					"systemTag": "fixbotengine-java",
					"goodExample": "void baz(boolean var1) {\n    if (var1) {\n    } else {  \n    }\n}",
					"badExample": "void baz(boolean var1) {\n    if(var1){\n    }else{  \n    }\n}",
					"recommend": "按规范增加空格",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.14 不应插入多余空格使代码垂直对齐",
					"language": "java",
					"id": "51bf4dd60fef11edb4ff84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "水平对齐是在代码中添加可变数量的附加空格的做法，目的是使某些标记直接出现在前一行的某些其他标记下方。\n包括在Javadoc注释性的描述内容前不应插入空格对齐。\n如果参数/变量名长短差异较大，无规律插入的空白数呈凹凸状，并不美观；\n如果某个参数/变量名较长，例如gardenPlantingDetailViewModel，对应的描述内容也较长的话，就可能不得不换行，又可能会有换行对齐的顾忌；\n后续的维护者可能会困扰是否在整个module/package都刻意追求对齐。\n因此，对齐的弊大于利；为了减少维护成本，不造成困扰，不对齐是最好的选择。\n\n工具检查场景:\n- 检查代码中是否出现连续的两个空格\n- 例外场景\n  - 行首缩进不检查\n  - 注释里的空格不检查",
					"systemTag": "fixbotengine-java",
					"goodExample": "private int size;\nprivate String name;",
					"badExample": "private int    size; // 维护者可能不得不修改这些对齐空格数\nprivate String name; // 不必与上行对齐注释",
					"recommend": "删除不必要的空格",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.15 枚举常量间用逗号隔开， 换行可选",
					"language": "java",
					"id": "51bf4dd80fef11ed969684a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "在枚举常量后面的每个逗号之后，换行符是可选的。还允许额外的空白行（通常只有一行）\n\n工具检查场景：\n- 检查枚举常量间是否有超过一个空白行",
					"systemTag": "fixbotengine-java",
					"goodExample": "public enum EnumDemo {\n    ENUM_A, ENUM_B,\n\n    ENUM_C,\n\n    // ENUM_D\n    ENUM_D\n}",
					"badExample": "public enum EnumDemo {\n    ENUM_A, ENUM_B,\n    // 空行\n    // 空行\n    ENUM_C,\n    // 空行\n    // 空行\n    // 空行\n    // ENUM_D\n    ENUM_D\n}",
					"recommend": "删除多余空行",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.TYP.05 浮点型数据判断相等不要直接使用==，浮点型包装类型不要用equals()或者 flt.compareTo(another) == 0作相等的比较",
					"language": "java",
					"id": "51bf4dda0fef11eda70f84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "浮点型数据判断相等不要直接使用==，浮点型包装类型不要用equals()或者 flt.compareTo(another) == 0作相等的比较\n\n2021年4月8日：新增两个浮点变量==比较的场景\n\n工具检查场景:\n- 检查浮点型数据使用==、!=来判断相等。\n- 检查浮点型数据使用equals或compareTo来判断相等",
					"systemTag": "fixbotengine-java",
					"goodExample": "考虑浮点数的精度问题，可在一定的误差范围内判定两个浮点数值相等。这个误差应根据实际需要进行定义。另外，对于符号不同的两个浮点数，即使在误差范围内也不应该判为相等。如下示例中，两个浮点数值误差在1e-6f内判为相等。\nprivate static final float EPSILON = e-f;\n\nfloat foo = ...;\nfloat bar = ...;\nif (Math.abs(foo - bar) &lt; EPSILON) {\n    ...\n}",
					"badExample": "float f1 = 1.0f - 0.9f;\nfloat f2 = 0.9f - 0.8f;\nif (f1 == f2) {\n    // 预期进入此代码块，执行其他业务逻辑\n    // 但事实上 fl == f2 的结果为 false\n}\nFloat flt1 = Float.valueOf(f1);\nFloat flt2 = Float.valueOf(f2);\nif (flt1.equals(flt2)) {\n    // 预期进入此代码块，执行其他业务逻辑\n    // 但事实上 equals 的结果为 false\n}",
					"recommend": "使用误差判等",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.TYP.06 禁止尝试与NaN进行比较运算，相等操作使用Double或Float的isNaN()方法(通用)",
					"language": "java",
					"id": "51bf4ddc0fef11ed852484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "NaN(Not a Number，非数值)是无序的，当一个或两个操作数是NaN时，数值比较符&lt;、&lt;=、&gt;、&gt;=会返回false。当任意一个操作数是NaN，==运算符会返回false，!=运算符会返回true。因为无序的特性常常会导致意外结果，所以不能直接与NaN进行比较。\n\n\n工具检查场景：\n- 检查比较运算（`==`，`!=,` `&gt;=`, `&lt;=`, `&gt;`, `&lt;`)的左表达式或右表达式是否为Double.NaN或Float.NaN",
					"systemTag": "fixbotengine-java",
					"goodExample": "public class NanComparison {\n    public void doSomething(double num) {\n        // 如果num的值为0.0d，则Math.cos(infinity)返回NaN\n        double result = Math.cos(1 / num);\n        if (Double.isNaN(result)) {\n            System.out.println(\"result is NaN\");\n        }\n        ...\n    }\n}\n上述示例中，使用Double.isNaN()方法来检查result是否为NaN，可以获得正确的结果。",
					"badExample": "public class NanComparison {\n    public void doSomething(double num) {\n        // 如果num的值为0.0d，则Math.cos(infinity)返回NaN\n        double result = Math.cos(1 / num);\n        if (result == Double.NaN) { // 相等比较总是false\n            System.out.println(\"result is NaN\");\n        }\n        ...\n    }\n}\n上述示例中，与NaN进行直接比较。根据NaN的语义，代码中的比较运算返回false，不会输出“result is NaN”。",
					"recommend": "使用isNaN",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.TYP.04 需要精确计算时使用BigDecimal，不要使用float和double",
					"language": "java",
					"id": "51bf74d90fef11eda8e784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "浮点数在一个范围很广的值域上提供了很好的近似，但是它不能产生精确的结果。二进制浮点数对于精确计算是非常不适合的，因为它不可能将0.1，或者10的其它任何负次幂表示为一个长度有限的二进制小数。涉及精确的数值计算（货币、金融等），建议使用int、long、 BigDecimal等；在构造BigDecimal时，使用浮点数容易导致精度损失，应该使用字符串格式的数值构造BigDecimal，即应该用BigDecimal​(String val)，而不是BigDecimal​(double val)。\n\n工具检查场景:\n- 检查是否使用浮点数常量做算术运算",
					"systemTag": "fixbotengine-java",
					"goodExample": "BigDecimal income = new BigDecimal(\"1.03\");\nBigDecimal expense = new BigDecimal(\"0.42\");\nSystem.out.println(income.subtract(expense));",
					"badExample": "System.out.println(1.03d - 0.42d);",
					"recommend": "使用BigDecimal",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.TYP.03 禁止使用浮点数作为循环计数器",
					"language": "java",
					"id": "51bf74db0fef11eda11084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "浮点数不能为循环因子，精度问题会导致(float) 2000000000 == 2000000050为true\n\n工具检查场景:\n- 检查在for语句的第一个子句中是否使用浮点数（float，double，Float，Double）声明或初始化",
					"systemTag": "fixbotengine-java",
					"goodExample": "for (int index = 2000000000; index &lt; 2000000050; index++) {\n    ...\n}\n\n上述示例中，使用整数作为循环计数器。",
					"badExample": "for (float flt = (float) 2000000000; flt &lt; 2000000050; flt++) {\n    ...\n}\n\n上述示例中，由于浮点数的精度问题导致条件判断结果与预期不符：因为(float) 2000000000 == 2000000050结果为true，所以循环体不会执行。",
					"recommend": "使用整型作为循环变量",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FMT.01 源文件编码格式（包括注释）应该是UTF-8",
					"language": "java",
					"id": "51bf74dd0fef11ed978e84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "源文件编码格式（包括注释）应该是UTF-8",
					"systemTag": "fixbotengine-java",
					"goodExample": "",
					"badExample": "",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": false
				},
				{
					"name": "G.TYP.07 不要在代码中硬编码用于表示换行、文件路径分隔的字符——不要在代码中硬编码用于表示换行字符",
					"language": "java",
					"id": "51bf74df0fef11ed9e0c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "回车换行符(\"\\r\"、\"\\n\")、文件路径分隔符(\"\\\"、\"/\")在不同操作系统下是有区别的。如果需要换行，尽量用PrintStream、PrintWriter的println()来代替在字符串中使用硬编码换行符，也可以使用**System.lineSeparator()**获取运行时环境的换行符。文件路径分割符可以使用java.io.File中的separator和pathSeparator静态字段。\n\n工具检查场景:\n-检查代码中使用换行（回车“\\r”、换行“\\n”）\n-检查代码中文件路径分隔（“\\\\”、“/”）的字符",
					"systemTag": "fixbotengine-java",
					"goodExample": "System.out.println(\"Hello,world!\");\nString filePath = path + File.separator + \"temp.txt\";",
					"badExample": "System.out.print(\"Hello,world!\\n\");\nString filePath = path + \"\\\\temp.txt\";",
					"recommend": "使用系统API获取回车换行符和文件路径分割符",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.TYP.08 字符串大小写转换、数字格式化为西方数字时，必须加上Locale.ROOT或Locale.ENGLISH",
					"language": "java",
					"id": "51bf74e10fef11ed9c4c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "String类的toUpperCase()、toLowerCase()方法、format()方法，如果不指定输入参数，则会按当前系统默认的编码模式转换，可能会导致非预期的转换结果。\n字符对区域不敏感的，例如协议关键字、HTML的tags优先用ROOT，字符对区域敏感或者强调英文习惯的应使用ENGLISH。\n\n工具检查场景:\n- 检查是否出现String.getBytes()方法的调用，但没有传编码参数\n- 检查是否出现new String(bytes[])方法的调用，但没有传编码参数\n- 检查是否出现URLEncoder.encode()或URLEncoder.decode()，但没有传编码参数\n- 检查是否出现new InputStreamReader()或new OutputStreamWriter()，但没传编码参数",
					"systemTag": "fixbotengine-java",
					"goodExample": "String testString = \"i\";\nSystem.out.println(testString.toUpperCase(Locale.ROOT));\nString testString2 = String.format(Locale.ROOT, \"%d\", 2);\nSystem.out.println(testString2);\n\n字符串的大小写转换2都是对26个英文字母，建议显式指定语言为Locale.ROOT。",
					"badExample": "String testString = \"i\";\nSystem.out.println(testString.toUpperCase());\nString testString2 = String.format(\"%d\", 2);\nSystem.out.println(testString2); // locale设置为ar-SA，2格式化后输出'٢'\n\n上述示例中，如果当前环境是土耳其Turkish/阿拉伯语/孟加拉语/尼泊尔语/马拉帝语/阿萨姆语等，那toUpperCase输出的结果将不是预期的大写I，可能是另外一个字符（?）；format格式化后的数字也不是预期的西方数字2。\n",
					"recommend": "增加编码参数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.TYP.07 不要在代码中硬编码用于表示换行、文件路径分隔的字符——不要在代码中硬编码用于表示文件路径分隔的字符",
					"language": "java",
					"id": "51bf74e30fef11eda71784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "回车换行符(\"\\r\"、\"\\n\")、文件路径分隔符(\"\\\"、\"/\")在不同操作系统下是有区别的。如果需要换行，尽量用PrintStream、PrintWriter的println()来代替在字符串中使用硬编码换行符，也可以使用**System.lineSeparator()**获取运行时环境的换行符。文件路径分割符可以使用java.io.File中的separator和pathSeparator静态字段。\n\n工具检查场景:\n-检查代码中使用换行（回车“\\r”、换行“\\n”）\n-检查代码中文件路径分隔（“\\\\”、“/”）的字符",
					"systemTag": "fixbotengine-java",
					"goodExample": "System.out.println(\"Hello,world!\");\nString filePath = path + File.separator + \"temp.txt\";",
					"badExample": "System.out.print(\"Hello,world!\\n\");\nString filePath = path + \"\\\\temp.txt\";",
					"recommend": "使用系统API获取回车换行符和文件路径分割符",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.TYP.13 在引用类型向下转换前用instanceof进行判断",
					"language": "java",
					"id": "51bf74e50fef11eda6e184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "没有判断直接进行类型转换，可能会因类型不匹配而导致运行期异常java.lang.ClassCastException。参见G.ERR.10 尽量消除非受检的异常，不应该在整个类上使用SuppressWarning\n简单的修改方法即是在强制转换之前使用instanceof进行判断，确认转换操作可行，但可能带来的问题是修改点过多，工作量巨大，同时维护的工作量也会倍增。最好的方式还是改善设计，使集合中只有同一种类型的对象。\n\n工具检查场景：\n- 检查类型转换前是否有instanceof判断",
					"systemTag": "fixbotengine-java",
					"goodExample": "void test(Object obj) {\n    String str;\n    if (obj instanceof String) {\n        str = (String) obj;\n    }\n}",
					"badExample": "void test(Object obj) {\n    String str = (String) obj;\n}",
					"recommend": "增加instanceof判断",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.MET.01 方法要简短——方法行数不应超过50行",
					"language": "java",
					"id": "51bf74e70fef11ed82f784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "方法要简短\n\n工具检查场景:\n- 检查每个方法行数是否超过50行（非空非注释）\n- 检查每个方法的参数是否超过5个\n- 检查每个方法的代码块嵌套深度是否超过4层（方法本身算一层，try-catch不算一层，lamda表达式、局部类或匿名类层次以最内层方法计算，不累计）",
					"systemTag": "fixbotengine-java",
					"goodExample": "嵌套层数是2：\nint foo(Item msg) {\n    ...\n    if (!isReceived) {\n        return -1;\n    }\n\n    type = getMsgType(msg);\n    if (type == UNKNOWN) {\n        return -1;\n    }\n\n    return dealMsg(type);\n}",
					"badExample": "嵌套层数是4：\nint foo(Item msg) {\n    ...\n    if (isReceived) {\n        type = getMsgType(msg);\n        if (type != UNKNOWN) {\n            if (msg.isEmpty()) {\n                return dealMsg(type);\n            }\n        }\n    }\n    return -1;\n}",
					"recommend": "重构和简化方法",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.MET.01 方法要简短——方法的参数不应超过5个",
					"language": "java",
					"id": "51bf74e90fef11eda29f84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "方法要简短\n\n工具检查场景:\n- 检查每个方法行数是否超过50行（非空非注释）\n- 检查每个方法的参数是否超过5个\n- 检查每个方法的代码块嵌套深度是否超过4层（方法本身算一层，try-catch不算一层，lamda表达式、局部类或匿名类层次以最内层方法计算，不累计）",
					"systemTag": "fixbotengine-java",
					"goodExample": "嵌套层数是2：\nint foo(Item msg) {\n    ...\n    if (!isReceived) {\n        return -1;\n    }\n\n    type = getMsgType(msg);\n    if (type == UNKNOWN) {\n        return -1;\n    }\n\n    return dealMsg(type);\n}",
					"badExample": "嵌套层数是4：\nint foo(Item msg) {\n    ...\n    if (isReceived) {\n        type = getMsgType(msg);\n        if (type != UNKNOWN) {\n            if (msg.isEmpty()) {\n                return dealMsg(type);\n            }\n        }\n    }\n    return -1;\n}",
					"recommend": "重构和简化方法",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.MET.05 对于返回数组或者容器的方法，应返回长度为0的数组或者容器，代替返回null",
					"language": "java",
					"id": "51bf74eb0fef11edbbe984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "在方法返回值中，用长度为0的数组或者容器，来代替返回null，则上层调用代码在使用此返回的容器前，无需再判断是否为空，业务逻辑一气呵成，代码更简洁。\n同时，也避免了程序员因为忘记了对返回值进行空指针检查，而导致的NullPointerException。\n方法的返回值可以为null，应该添加注释充分说明什么情况下会返回 null 值。\n\n\n工具检查场景:\n- 检查返回类型是容器或数组的方法中是否有return null语句",
					"systemTag": "fixbotengine-java",
					"goodExample": "public static List&lt;String&gt; decorate(String[] personDescs) {\n    if (personDescs == null || personDescs.length == 0) {\n        return Collections.emptyList();\n    }\n    List&lt;String&gt; personNames = new ArrayList&lt;&gt;(personDescs.length);\n    for (String personDesc : personDescs) {\n        String personName = getPersonName(personDesc);\n        personNames.add(personName);\n    }\n    return personNames;\n}\n\npublic static void main(String[] args) {\n    // personDescs.length为0\n    List&lt;String&gt; personNames = decorate(personDescs);\n\n    for (String personName : personNames) {\n        ...\n    }\n}\n\n上述示例中，被调用方法在发现参数不满足要求时，返回空容器给外层调用者。外层调用无需检查返回值是否为null，一套代码解决问题。",
					"badExample": "public static List&lt;String&gt; decorate(String[] personDescs) {\n    if (personDescs == null || personDescs.length == 0) {\n        return null;\n    }\n\n    List&lt;String&gt; personNames = new ArrayList&lt;&gt;(personDescs.length);\n    for (String personDesc : personDescs) {\n        String personName = getPersonName(personDesc);\n        personNames.add(personName);\n    }\n    return personNames;\n}\n\npublic static void main(String[] args) {\n    ...\n    List&lt;String&gt; personNames = decorate(personDescs);\n    if (personNames == null) {\n        return;\n    }\n\n    for (String personName : personNames) {\n        ...\n    }\n}\n\n上述示例中，被调用方法在发现参数不满足要求时，返回null给外层调用者。外层调用者必须时刻记得检查返回值是否为null，否则会发生空指针异常。而添加检查代码后，代码臃肿。",
					"recommend": "使用空数组或容器替代null作为返回值",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.MET.03 不应把方法的参数当做临时变量",
					"language": "java",
					"id": "51bf9bf10fef11edb0a884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "每个变量/参数都有自己独特的功用，让一个变量承担多个职责，变量名将无法清晰表达其功能，会使程序难以理解；\n为减轻因疏忽导致的再次对入参赋值，可在参数前加final关键字（但工具不作扫描）。\n\n工具检查场景:\n- 检查方法的参数是否作为赋值语句的左值",
					"systemTag": "fixbotengine-java",
					"goodExample": "int sample(final int basicSalary) {  // 使用final能够帮助判断，避免意外修改\n    int performanced = basicSalary * currentMultiplier(basicSalary);\n    int bonused = performanced * currentAdder(performanced);\n    ...\n    return bonused;\n}\n上述示例中，方法参数命名与业务逻辑相匹配，参数功能单一，代码逻辑清晰。",
					"badExample": "int sample(int inputVal) {\n    inputVal = inputVal * currentMultiplier(inputVal);\n    inputVal = inputVal * currentAdder(inputVal);\n    return inputVal;\n}\n上述示例中，方法参数用作临时变量，增加了程序理解的难度。",
					"recommend": "增加局部变量，将参数赋值给该局部变量，进行后续操作",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.MET.06 使用Optional代替null作为返回值或者可能的缺失值；禁止对Optional对象赋值为null",
					"language": "java",
					"id": "51bf9bf30fef11edb52f84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "Java 8使用Optional代替null作为返回值或者可能的缺失值；禁止对Optional对象赋值为null\n\n工具检查场景:\n- 检查是否将null赋值给Optional对象\n- 检查是否将Optional对象和null进行比较（==或!=）\n- 检查方法是否返回null；重写的方法（@Override）不检查\n- 检查方法返回类型是否为Optional\\&lt;Integer&gt;、Optional\\&lt;Long&gt;或Optional\\&lt;Double&gt;\n- 检查方法返回类型是否为Optional&lt;集合或数组&gt;",
					"systemTag": "fixbotengine-java",
					"goodExample": "Optional&lt;Foo&gt; foo = Optional.empty();\n\nif (foo.isPresent()) {\n    ...\n}\n\nOptional&lt;String&gt; foo2() {\n    ...\n    return Optional.empty();\n}\n\nOptionalInt foo3() {\n    ...\n}\n\nList&lt;String&gt; foo4() {\n    ...\n    return new ArrayList&lt;String&gt;();\n}",
					"badExample": "Optional&lt;Foo&gt; foo = null;\n\nif (foo == null) {\n    ...\n}\n\nString foo2() {\n    ...\n    return null;\n}\n\nOptional&lt;Integer&gt; foo3() {\n    ...\n}\n\nOptional&lt;List&lt;String&gt;&gt; foo4() {\n    ...\n    return Optional.empty();\n}",
					"recommend": "使用Optional替代null",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.MET.04 谨慎使用可变数量参数",
					"language": "java",
					"id": "51bf9bf50fef11eda38084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "在JDK 1.5版本中初次引入Varargs（variable number of arguments）可变数量参数，可以接受指定类型的零个到多个参数。不建议使用varargs重写使用一个固定长度数组作为参数的方法，而应该在确实需要操作可变长度的值的序列时使用。\n\n工具检查场景：\n- 检查类中是否有对可变数量参数方法进行重载",
					"systemTag": "fixbotengine-java",
					"goodExample": "public double sum(double[] values) {\n    ...\n}\n\npublic double sum(double value1, double value2) {\n    ...\n}",
					"badExample": "public double sum(double... values) {\n    ...\n}\n\npublic double sum(double value1, double value2) {\n    ...\n}\n上述示例中，对可变数量参数方法进行了重载，可能会导致对于sum(23d, 32d)不确定实际执行的是哪个方法。",
					"recommend": "使用数组替代可变数量参数",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.OBJ.06 覆写equals方法时，要同时覆写hashCode方法",
					"language": "java",
					"id": "51bf9bf70fef11eda8e684a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "Java对象在存放到基于Hash的集合（如HashMap、HashTable等）时，会使用其Hash码进行索引，如果只覆写了equals方法，而没有正确覆写hashCode方法，则会导致效率低下甚至出错；Java对象的hashCode方法有如下约定：\n\n同一次运行中，同一个对象如果equals方法中用到的信息没有改变，多次调用其hashCode方法返回值必须相同；\n如果对两个对象调用equals方法时相等，则这两个对象的hashCode方法，也必须返回相同的值；\n如果对两个对象调用equals方法时不相等，则对这两个对象的hashCode方法，不要求其返回值不同，但是出于减少哈希碰撞的性能考虑，最好能不同。\n\n工具检查场景：\n- 检查类中是否覆写equals方法但没有覆写hashCode方法",
					"systemTag": "fixbotengine-java",
					"goodExample": "public class ClassDemo {\n    @Override\n    public boolean equals(Object obj) {\n        ...\n    }\n    \n    @Override\n    public int hashCode() {\n        return ...\n    }\n}",
					"badExample": "public class ClassDemo {\n    @Override\n    public boolean equals(Object obj) {\n        ...\n    }\n}",
					"recommend": "覆写hashCode方法",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.OBJ.04 避免在无关的变量或无关的概念之间重用名字，避免隐藏（hide）、遮蔽（shadow）和遮掩（obscure）",
					"language": "java",
					"id": "51bf9bf90fef11edaa8184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "在声明子类的字段、方法或嵌套类型时，除了覆写（override）、重载（overload）之外，要尽量避免重名导致的隐藏（hide）、遮蔽（shadow）和遮掩（obscure）。\n\n\n工具检查场景:\n- 检查局部变量（方法参数）是否覆盖类成员变量",
					"systemTag": "fixbotengine-java",
					"goodExample": "public class HiddenFieldTest {\n        Object obj;\n    \n        public void test(Object obj1) {\n        }\n    }",
					"badExample": "public class HiddenFieldTest {\n        Object obj;\n    \n        public void test(Object obj) {\n        }\n    }",
					"recommend": "重命名该变量",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.OBJ.01 应避免定义public且非final的类属性",
					"language": "java",
					"id": "51bf9bfb0fef11ed9a1884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "将字段设置为私有（private）的理由是：我们不想其他人依赖这个变量，依赖类内部的实现细节。这样，当内部实现需要变更时，影响面就比较小，变更的成本就比较低。不应该使用系统属性System Properties (set/get)来配置和传递信息。 这种2也不常见，但如果发生，很难察觉。\n\n\n\n工具检查场景:\n- 检查类的成员变量是否是public且非final的",
					"systemTag": "fixbotengine-java",
					"goodExample": "public class ClassDemo {\n    private int varDemo;\n}",
					"badExample": "public class ClassDemo {\n    public int varDemo;\n}",
					"recommend": "修改为私有成员",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.OBJ.03 构造方法如果有多个，尽量重用",
					"language": "java",
					"id": "51bf9bfd0fef11edbb9b84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "如果有多个构造方法，参数较少的，可以重用参数更多的构造方法。\n\n工具检查场景:\n- 检查类中构造方法是否出现如下所有场景，如果出现则报告构造方法1应该复用构造方法2\n  - 构造方法1，只包含类成员变量赋值语句或父类构造方法调用语句\n  2. 构造方法2，只包含类成员变量赋值语句或父类构造方法调用语句\n  - 构造方法2的参数列表覆盖构造方法1的参数列表",
					"systemTag": "fixbotengine-java",
					"goodExample": "public class ClassDemo {\n    int var1;\n    int var2;\n       \n    public ClassDemo(int var1) {\n        this(var1, 0);\n    }\n    \n    public ClassDemo(int var1, int var2) {\n        this.var1 = var1;\n        this.var2 = var2;\n    }\n}",
					"badExample": "public class ClassDemo {\n    int var1;\n    int var2;\n       \n    public ClassDemo(int var1) {\n        this.var1 = var1;\n        this.var2 = 0;\n    }\n    \n    public ClassDemo(int var1, int var2) {\n        this.var1 = var1;\n        this.var2 = var2;\n    }\n}",
					"recommend": "复用参数更多的构造方法",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.OBJ.09 使用类名调用静态方法，而不要使用实例或表达式来调用",
					"language": "java",
					"id": "51bf9bff0fef11edbeb684a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "明确的使用类名调用静态方法不容易造成混淆。使用实例调用静态方法时，调用的静态方法是声明类型的静态方法，与实例的实际类型无关，可能会导致与预期的结果不一致。当父类和子类有同名静态方法时，声明父类变量引用子类实例，调用该静态方法时调用的是父类的静态方法，而非子类的静态方法。\n\n工具检查场景:\n- 检查是否使用实例或表达式来调用静态方法",
					"systemTag": "fixbotengine-java",
					"goodExample": "用类名来调用静态方法\nclass Dog {\n    public static void bark() {\n        System.out.print(\"woof\");\n    }\n}\n\nclass Basenji extends Dog {\n    public static void bark() {\n        System.out.println(\"miao\");\n    }\n}\n\npublic class Bark {\n    public static void main(String[]  args) {\n        Dog.bark();\n        Basenji.bark();\n    }\n}",
					"badExample": "class Dog {\n    public static void bark() {\n        System.out.println(\"woof\");\n    }\n}\n\nclass Basenji extends Dog {\n    public static void bark() {\n        System.out.println(\"miao\");\n    }\n}\n\npublic class Bark {\n    public static void main(String[]  args) {\n        Dog woofer = new Dog();\n        Dog nipper = new Basenji();\n        woofer.bark();\n        nipper.bark();\n    }\n}\n上述示例中，对bark()的两次调用，实际调用的都是Dog.bark()方法。",
					"recommend": "通过类名调用",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.OBJ.08 正确实现单例模式",
					"language": "java",
					"id": "51bf9c010fef11eda4fc84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "2来说，正确实现单例有如下几点要求：\n将其构造函数设为私有\n防止对象在初始化被多个线程同时运行\n确保该对象不可序列化\n确保该对象无法克隆\n\n工具检查场景:\n- 检查是否将构造方法设为私有\n- 是否确保该对象不可序列化\n- 是否确保该对象无法克隆\n- 是否防止对象初始化被多个线程同时运行",
					"systemTag": "fixbotengine-java",
					"goodExample": "final class RecommandSingleton {\n    private static class SingletonHolder {\n        static final RecommandSingleton INSTANCE = new RecommandSingleton();\n    }\n\n    private RecommandSingleton() {\n    }\n\n    public static RecommandSingleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n利用静态内部类实现单例",
					"badExample": "class UntrustedSingletonDemo {\n    private static UntrustedSingletonDemo instance;\n\n    protected UntrustedSingletonDemo() {\n        instance = new UntrustedSingletonDemo();\n    }\n}\n非私有构造方法",
					"recommend": "修改成私有构造方法",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.OBJ.10 接口定义中去掉多余的修饰词",
					"language": "java",
					"id": "51bf9c030fef11eda4b984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "在接口定义中，属性已缺省具有public static final修饰词，方法已缺省具有public abstract修饰词。因此在代码中不要再次提供这些修饰词。\n\n- 检查接口的属性是否包含public、static或final修饰词\n- 检查接口的方法是否包含public或abstract修饰词",
					"systemTag": "fixbotengine-java",
					"goodExample": "public interface InterfaceDemo {\n    int STATIC_VAR = 100;\n}",
					"badExample": "public interface InterfaceDemo {\n    public static final int STATIC_VAR = 100;\n}",
					"recommend": "增加相应的修饰词",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CON.07 创建新线程时必须指定线程名",
					"language": "java",
					"id": "51bfc3040fef11ed80b184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "推荐使用线程池，有些场景不得不独立创建Thread时，遵循本规则。\n\n工具检查场景:\n- 检查Thread变量是否通过如下几种方式指定线程名，另外需要在start之前指定\n  - 构造方法：Thread t = new Thread(null, \"myThreadName\");\n  - set方法：Thread t = new Thread(); t.setName(\"myThreadName\");\n- 检查继承Thread的类是否在构造方法中没有指定线程名 ",
					"systemTag": "fixbotengine-java",
					"goodExample": "Thread t1 = new Thread();\n    t1.setName(name1);\n    t1.start();\n    \n    Thread t2 = new Thread();\n    t2.setName(name2);\n    t2.start();",
					"badExample": "Thread t1 = new Thread();\n    t1.start();\n    \n    Thread t2 = new Thread();\n    t2.start();\n    t2.setName(name);",
					"recommend": "设置线程名",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CON.06 使用新并发工具代替wait()和notify()",
					"language": "java",
					"id": "51bfc3060fef11edb67e84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "自从Java1.5发行版本开始，Java平台就提供了更高级的并发工具，它们可以完成以前必须在wait()和notify()上手写代码来完成的各项工作。\n\n工具检查场景:\n- 检查是否调用notify方法",
					"systemTag": "fixbotengine-java",
					"goodExample": "",
					"badExample": "public void test() {\n        notify();\n    }",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CON.08 使用Thread对象的setUncaughtExceptionHandler方法注册未捕获异常处理者",
					"language": "java",
					"id": "51bfc3080fef11edb56f84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "推荐使用线程池，线程池(包括ScheduledThreadPoolExecutor)的线程setUncaughtExceptionHandler是无效的。但如果有些场景不得不独立创建Thread时，遵循本规则。\n\n- 检查Thread变量是否调用`setUncaughtExceptionHandler`方法注册未捕获异常处理者\n- 例外场景\n  - 在Android app中不检查（import语句中出现android）",
					"systemTag": "fixbotengine-java",
					"goodExample": "public class TestUncaughtException {\n    public static void main(String[] args) {\n        TestThread thread = new TestThread(\"meaningful-name\");\n        thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n            @Override\n            public void uncaughtException(Thread tr, Throwable ex) {\n                System.out.println(tr.getName() + \" : \" + ex.getMessage());\n            }\n        });\n\n        thread.start();\n    }\n\n    public static class TestThread extends Thread {\n        public TestThread(String name) {\n            super.setName(name);\n        }\n\n        @Override\n        public void run() {\n            throw new RuntimeException(\"just a test\");\n        }\n    }\n}",
					"badExample": "Thread thread = new Thread(\"meaningful-name\");\n    thread.start();",
					"recommend": "设置异常处理方法",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CON.12 避免不加控制地创建新线程，应该使用线程池来管控资源",
					"language": "java",
					"id": "51bfc30a0fef11ed854284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "Java虚拟机能够管理的线程数量有限，不加控制的创建新线程可能会导致Java虚拟机崩溃。\n\n工具检查场景:\n- 检查是否使用new Thread或Executors的方法创建线程",
					"systemTag": "fixbotengine-java",
					"goodExample": "使用线程池来管理线程资源，对线程池指定核心线程数，最大线程数，工作队列大小，线程工厂及丢弃策略等参数\n\nprivate BlockingQueue blockingQueue = new LinkedBlockingQueue(100);\nprivate ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 64, 60L,\n    TimeUnit.SECONDS, blockingQueue,\n    new SelfThreadFactory(\"ProductName\", \"ThreadName\", false),\n    new DiscardOldestPolicy(LOGGER, \"ThreadName\"));\n\npublic void processEntity2(List&lt;Entity&gt; items) {\n    for (Entity entity : items) {\n        threadPool.execute(new EntityProcessor(entity));\n    }\n}",
					"badExample": "public void processEntity1(List&lt;Entity&gt; items) {\n    for (Entity entity : items) {\n        new Thread(new EntityProcessor(entity)).start();\n    }\n}",
					"recommend": "使用ThreadPoolExecutor创建线程",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRM.01 将集合转为数组时使用Collection.toArray(T[])方法；Java 11后使用Collection.toArray(IntFunction&lt;T[]&gt;)",
					"language": "java",
					"id": "51bfc30c0fef11ed88bf84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "JDK 11引入了Collection&lt;T&gt;.toArray(IntFunction&lt;T[]&gt; generator)，它更好的就是不需要创建临时数组，一方面节省空间，另一方面这样就不用去考虑toArray(T[])里的参数长度对函数行为以及结果的影响。\n\n工具检查场景:\n- 检查toArray方法的参数（数组类型）的长度是否为0或集合大小",
					"systemTag": "fixbotengine-java",
					"goodExample": "List&lt;String&gt; list = new ArrayList&lt;&gt;(DEFAULT_CAPACITY);\n    list.add(getElm());\n    String[] array = list.toArray(new String[0]);",
					"badExample": "List&lt;String&gt; list = new ArrayList&lt;&gt;(DEFAULT_CAPACITY);\n    list.add(getElm());\n    String[] array = list.toArray(new String[DEFAULT_CAPACITY + 1]);",
					"recommend": "size设置为0",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRM.02 使用System.arraycopy()或Arrays.copyOf()进行数组复制",
					"language": "java",
					"id": "51bfc30e0fef11ed90c984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "在将一个数组对象复制成另外一个数组对象时，不要自己使用循环复制，可以使用Java提供的System.arraycopy()功能来复制数据对象，这样做可以避免出错，而且效率会更高。java.util.Arrays.copyOf()是对System.arraycopy()便利化封装。\n\n工具检查场景:\n- 检查是否存在这样的for循环：循环体中包含两个数组对应下标元素的赋值语句，形如a[i] = b[i];",
					"systemTag": "fixbotengine-java",
					"goodExample": "int[] src = {1, 2, 3, 4, 5};\nint[] dest = new int[5];\nSystem.arraycopy(src, 0, dest, 0, 5);",
					"badExample": "int[] src = {1, 2, 3, 4, 5};\nint[] dest = new int[5];\nfor (int i = 0; i &lt; 5; i++) {\n    dest[i] = src[i];\n}",
					"recommend": "使用System.arraycopy",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRM.04 不要对正则表达式进行频繁重复预编译",
					"language": "java",
					"id": "51bfc3100fef11eda7dc84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "在频繁调用的场景中，例如在方法体内或者是循环语句中定义Pattern可能导致重复预编译，降低程序执行效率。\n\n工具检查场景:\n- 检查是否在方法体内有Pattern.compile调用\n- 检查是否在循环中有Pattern.compile调用",
					"systemTag": "fixbotengine-java",
					"goodExample": "public class RegexExp {\n    private static final Pattern CHARSET_REG = Pattern.compile(\"[a-z]+\");\n\n    // 该方法被频繁调用\n    private boolean isLowerCase(String str) {\n        if (CHARSET_REG.matcher(str).find()) {\n            return true;\n        }\n        return false;\n    }\n}\n\n上述示例中，isLowerCase()使用的是被编译过的正则，即使是被频繁调用，也不会有正则的重复编译。",
					"badExample": "public class RegexExp {\n    // 该方法被频繁调用\n    private boolean isLowerCase(String str) {\n        Pattern pattern = Pattern.compile(\"[a-z]+\");\n        if (pattern.matcher(str).find()) {\n            return true;\n        }\n        return false;\n    }\n}\n上述示例中，isLowerCase()被调用时，会对正则进行编译。该方法被频繁调用时，都导致大量重复的正则编译操作。",
					"recommend": "将正则Pattern抽取为成员变量",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRM.09 禁止使用finalize()方法",
					"language": "java",
					"id": "51bfc3120fef11ed932584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "finalize方法的调用时机是不可预测的，常常也是危险的。使用finalize可能会导致不稳定的行为，更差的性能，以及带来移植性问题。\n\n\n工具检查场景:\n- 检查是否调用了finalize()方法",
					"systemTag": "fixbotengine-java",
					"goodExample": "",
					"badExample": "public void test() {\n    finalize();\n}",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRM.08 禁止使用主动GC（除非在密码、RMI等方面），尤其是在频繁/周期性的逻辑中",
					"language": "java",
					"id": "51bfc3140fef11edb87b84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "虽然主动调用GC方法时JVM规范不承诺立即进行垃圾回收操作，但是Oracle Java SE JVM在绝大多数情况下响应此方法调用，会触发JVM的全量GC操作，这会增加GC的次数，也就增加了程序因为GC而停顿的时间；而且在GC过程中的某些阶段程序会完全停顿，这会让程序失去响应，对系统造成非常大的风险。在频率/周期性的逻辑（for循环、定时器）中更要尽量避免主动GC的调用。\n\n\n工具检查场景:\n- 检查是否在循环中（for, while, do-while, enhanced-for）调用System.gc方法",
					"systemTag": "fixbotengine-java",
					"goodExample": "不使用主动GC，或者在循环之外的关键节点上调用主动GC。\n\nfor (String bookName : bookNames) {\n    Book book = new Book(bookName);\n    checkBook(book);\n    ... // 其他操作\n}\nSystem.gc();",
					"badExample": "在循环中调用了System.gc()，会引起JVM频繁、连续地全量GC，从而造成业务逻辑线程阻塞，不响应或者很慢地响应业务请求。\n\nfor (String bookName : bookNames) {\n    Book book = new Book(bookName);\n    checkBook(book);\n    ... // 其他操作\n    System.gc();\n}",
					"recommend": "去除循环内的gc调用，改到循环外",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRM.07 进行IO类操作时，必须在try-with-resource或finally里关闭资源",
					"language": "java",
					"id": "51bfc3160fef11edb52e84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "申请的资源不使用时，需要及时释放。而在产生异常时，资源释放常被忽视。\n\n\n工具检查场景:\n- 检查如下场景是否存在：资源变量`var`在try块中赋值，但没有finally块或者finally块中没有close或unlock\n- 检查的资源类型见本条规则末尾",
					"systemTag": "fixbotengine-java",
					"goodExample": "try (FileInputStream in = new FileInputStream(inputFileName);\n    FileOutputStream out = new FileOutputStream(outputFileName)) {\n    copy(in, out);\n}",
					"badExample": "FileInputStream in = null;\n    FileOutputStream out = null;\n    try {\n        in = new FileInputStream(inputFileName);\n        out = new FileOutputStream(outputFileName);\n        copy(in, out);\n    } catch (IOException e) {\n    }",
					"recommend": "使用try-with-resource或在finally关闭资源",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRM.10 不要创建临时变量作为return语句的返回值",
					"language": "java",
					"id": "51bfea150fef11edbb7184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "不要创建临时变量作为return语句的返回值，保持代码简洁。\n\n工具检查场景:\n-检查变量赋值后是否直接被返回。",
					"systemTag": "fixbotengine-java",
					"goodExample": "private List&lt;String&gt; func() {\n    return solve();\n}",
					"badExample": "private List&lt;String&gt; func() {\n    List&lt;String&gt; res = solve();\n    return res;\n}",
					"recommend": "去除临时变量和赋值，直接内联到return语句中",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRM.05 禁止创建不必要的对象",
					"language": "java",
					"id": "51bfea170fef11ed94b784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "重用一个已经创建的对象比创建一个新的对象要好得多，除非确实需要重新创建。创建重复不必要的对象会导致资源浪费，1时可能会导致性能问题。循环无关的计算和创建放到循环外面。\n\n\n工具检查场景:\n- 检查String的不必要创建\n- 检查Integer对象的不必要创建",
					"systemTag": "fixbotengine-java",
					"goodExample": "String foo = \"string\";\nInteger bar = Integer.valueOf(90);\n...\nInteger baz = Integer.valueOf(90); // 默认在-128~127间，会重用内存中缓存的对象",
					"badExample": "String foo = new String(\"string\"); // 建立了2个String对象\nInteger bar = new Integer(90);\n...\nInteger baz = new Integer(90);",
					"recommend": "删除不必要的new语句",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.SER.07 防止反序列化被利用来绕过构造方法中的安全操作",
					"language": "java",
					"id": "51bfea190fef11eda89d84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "反序列化操作可以在不执行构造方法的情况下创建对象的实例，所以反序列化操作中的行为应该设计为与构造方法保持一致，这些行为包括：\n1. 对参数的校验；\n2. 安全管理器的检查；\n3. 对属性赋初始值，特别是transient修饰的属性反序列化操作默认不会赋值；否则，攻击者就可能会通过反序列化操作构造出与预期不符合的对象实例。",
					"systemTag": "codemars",
					"goodExample": "在构造方法和反序列化的readObject()方法中执行了相同的安全检查，保证了系统中所有构造出的对象实例都是符合安全要求的。\npublic class SecureSerializeDemo implements Serializable {\n    private static final long serialVersionUID = 7727894840251340298L;\n    public SecureSerializeDemo() {\n        // 实例化敏感类需要权限\n        securityManagerCheck();\n        // 常规逻辑流程\n        // ...\n    }\n    private void readObject(ObjectInputStream in) {\n        // 实例化敏感类需要权限\n        securityManagerCheck();\n        // 常规逻辑流程\n        // ...\n    }\n    private void securityManagerCheck() {\n        // 权限安全检查\n        // ...\n    }\n}",
					"badExample": "安全管理器检查被应用在构造器中，但在反序列化涉及的readObject()方法中没有用到。这样会导致通过反序列化操作构造出不满足安全检查条件的对象实例。\npublic class SecureSerializeDemo implements Serializable {\n    private static final long serialVersionUID = 7727894840251340298L;\n    public SecureSerializeDemo() {\n        // 实例化敏感类需要权限\n        securityManagerCheck();\n        // 常规逻辑流程\n        // ...\n    }\n    /* POTENTIAL FLAW: 1）实现Serializable接口，并且在实现类的构造函数中包含安全检查器 2）基于第一点，工具检测readObject和writeObject方法中是否包含安全检查器，如果没有则报告警。 */\n    private void readObject(ObjectInputStream in) {\n        // 常规逻辑流程\n        // ...\n    }\n    private void securityManagerCheck() {\n        // 权限安全检查\n        // ...\n    }\n}",
					"recommend": "如果可序列化的类的构造方法中存在SecurityManager检查，请确保readObject()方法中存在相同的SecurityManager检查。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.SEC.02 自定义类加载器覆写getPermission()时，必须先调用父类的getPermission()方法",
					"language": "java",
					"id": "51bfea1b0fef11ed8b8384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "自定义类加载器未调用父类的getPermissions()方法。\n\n自定义类加载器，如果需要重写getPermissions()方法时，在给其它代码设置权限之前，必须要先调用父类的getPermissions()方法来应用默认的安全策略。自定义类加载器如果忽略调用父类的getPermissions()方法，该类加载器可以加载提升权限的不可信类。",
					"systemTag": "codemars",
					"goodExample": "public class CWE358_J_Rule8_2_Call_Super_GetPermission_Good extends URLClassLoader {\n\n // Other code…\n\n    \n\n    /* POTENTIAL FLAW: 继承URLClassLoader类时，重载getPermissions(CodeSource)函数时是否调用了super.getPermissions(...)。 */\n\n    @Override\n\n    protected PermissionCollection getPermissions(CodeSource cs) {\n\n        super.getPermissions(cs);\n\n        PermissionCollection pc = new Permissions();\n\n        // allow exit from the VM anytime\n\n        pc.add(new RuntimePermission(\"exitVM\"));\n\n        return pc;\n\n    }\n\n    \n\n    // Other code…\n\n}&lt;/pre&gt;",
					"badExample": "public class CWE358_J_Rule8_2_Call_Super_GetPermission_Bad extends URLClassLoader {\n\n // Other code…\n\n    \n\n    /* POTENTIAL FLAW: 继承URLClassLoader类时，重载getPermissions(CodeSource)函数时是否调用了super.getPermissions(...)。 */\n\n    @Override\n\n    protected PermissionCollection getPermissions(CodeSource cs) {\n\n        PermissionCollection pc = new Permissions();\n\n        // allow exit from the VM anytime\n\n        pc.add(new RuntimePermission(\"exitVM\"));\n\n        return pc;\n\n    }\n\n    \n\n    // Other code…\n\n}&lt;/pre&gt;",
					"recommend": "继承URLClassLoader类时，重载getPermissions(CodeSource)方法时需要调用super.getPermissions()。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FIO.04 防止外部进程阻塞在输入输出流上",
					"language": "java",
					"id": "51bfea1d0fef11ed9dfd84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "防止外部进程阻塞在输入输出流上。\n\nJava中有两种方式启动一个外部进程并与其交互：\n\n1. java.lang.Runtime的exec()方法。\n\n2. java.lang.ProcessBuilder的start()方法。\n\n他们都返回一个java.lang.Process对象，该对象封装了这个外部进程。每个Process对象，包含输入流、输出流及错误流各一个。应该恰当地处理这些流，避免外部进程阻塞在这些流上。不正确的处理会产生异常、DoS，及其他安全问题。",
					"systemTag": "codemars",
					"goodExample": "public class ProcessExecutor {\n    public void callExtProcess() throws IOException, InterruptedException {\n        Process proc = Runtime.getRuntime().exec(\"ProcessHasOutput\");\n        StreamConsumer errConsumer = new StreamConsumer(proc.getErrorStream());\n        StreamConsumer outputConsumer = new StreamConsumer(proc.getInputStream());\n        errConsumer.start();\n        outputConsumer.start();\n        int exitVal = proc.waitFor();\n        errConsumer.join();\n        outputConsumer.join();\n    }\n\n    class StreamConsumer extends Thread {\n        InputStream is;\n\n        StreamConsumer(InputStream is) {\n            this.is = is;\n        }\n\n        @Override\n        public void run() {\n            try {\n                byte data;\n                int result;\n                while ((result = is.read()) != -1) {\n                    data = (byte) result;\n                    handleData(data);\n                }\n            } catch (IOException ex) {\n                // 处理异常\n            }\n        }\n\n        private void handleData(byte data) {\n            // ...\n        }\n    }\n}&lt;/pre&gt;",
					"badExample": "public void execExtProcess() throws IOException, InterruptedException {\n    Process proc = Runtime.getRuntime().exec(\"ProcessHasOutput\");\n    int exitVal = proc.waitFor();\n}&lt;/pre&gt;",
					"recommend": "在运行一个外部进程时，如果此进程往其输出流发送任何数据，则必须将其输出流清空。类似的，如果进程会往其错误流发送数据，其错误流也必须被清空。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FIO.01 使用外部数据构造的文件路径前必须进行校验，校验前必须对文件路径进行规范化处理",
					"language": "java",
					"id": "51bfea1f0fef11ed8fad84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "禁止使用getAbsolutePath()对文件路径进行规范化处理。\n文件路径来自外部数据时，必须对其合法性进行校验，否则可能会产生路径遍历（Path Traversal）漏洞。文件路径有多种表现形式，如绝对路径、相对路径，路径中可能会含各种链接、快捷方式、影子文件等，这些都会对文件路径的校验产生影响，所以在文件路径校验前要对文件路径进行规范化处理，使用规范化的文件路径进行校验。对文件路径的规范化处理必须使用getCanonicalPath()，禁止使用getAbsolutePath()（该方法无法保证在所有的平台上对文件路径进行正确的规范化处理）。",
					"systemTag": "codemars",
					"goodExample": "使用外部输入的fileName构造文件路径后，先对文件路径进行规范化，然后用规范化的文件路径进行校验，满足条件后执行文件读写操作。这样可以有效避免路径遍历之类的风险。\npublic void doSomething() {\n    File file = new File(HOME_PATH, fileName);\n    try {\n        String canonicalPath = file.getCanonicalPath();\n        if (!validatePath(canonicalPath)) {\n            throw new IllegalArgumentException(\"Path Traversal vulnerability!\");\n        }\n        // ... 对文件进行读写等操作\n    } catch (IOException ex) {\n        throw new IllegalArgumentException(\"An exception occurred ...\", ex);\n    }\n}\nprivate boolean validatePath(String path) {\n    if (path.startsWith(HOME_PATH)) {\n        return true;\n    } else {\n        return false;\n    }\n}",
					"badExample": "代码中fileName来自外部输入，直接用fileName的值与固定路径进行拼接，作为实际访问文件的路径，在访问文件之前通过validatePath检查了拼接的路径是否在固定目录下，但是攻击者可以通过../这样的路径方式，访问HOME_PATH之外的任意文件。\npublic void doSomething() {\n    File file = new File(HOME_PATH, fileName);\n    /* POTENTIAL FLAW: 获取文件路径时，必须使用getCanonicalPath()，禁止使用getAbsolutePath() */\n    String path = file.getAbsolutePath();\n    if (!validatePath(path)) {\n        throw new IllegalArgumentException(\"Path Traversal vulnerabilities may exist！\");\n    }\n    // ... 对文件进行读写等操作\n}\nprivate boolean validatePath(String path) {\n    if (path.startsWith(HOME_PATH)) {\n        return true;\n    } else {\n        return false;\n    }\n}",
					"recommend": "在文件验证之前，使用getCanonicalPath()而非getAbsolutePath()获取文件路径。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.OTH.04 禁止代码中包含公网地址",
					"language": "java",
					"id": "51bfea210fef11ed8e3184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "硬编码公网IP地址。\n代码或脚本中包含用户不可见，不可知的公网地址，可能会引起客户质疑。对产品发布的软件（包含软件包/补丁包）中包含的公网地址（包括公网IP地址、公网URL地址/域名、 邮箱地址）要求如下：\n1、禁止包含用户界面不可见、或产品资料未描述的未公开的公网地址。\n2、已公开的公网地址禁止写在代码或者脚本中，可以存储在配置文件或数据库中。对于开源/第三方软件自带的公网地址必须至少满足上述第1条公开性要求。",
					"systemTag": "codemars",
					"goodExample": "public void doSomething() {\n    String ip = loadFromConfig();\n}&lt;/pre&gt;",
					"badExample": "公网IP地址硬编码\npublic void doSomething() {\n    /* POTENTIAL FLAW: IP地址硬编码 */\n    String ip = \"19.168.0.1\";\n}",
					"recommend": "不要硬编码公网IP地址&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.CON.01 对共享变量做同步访问控制时需避开同步陷阱——不要使用实例锁来保护静态共享数据",
					"language": "java",
					"id": "51bfea230fef11ed818984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "禁止使用一个实例锁来同步静态共享数据。\n实例锁的同步效果仅限于此实例本身，无法用来同步静态共享变量；如果试图使用实例锁来同步静态共享变量，在多实例情况下无法实现符合预期的同步效果。",
					"systemTag": "codemars",
					"goodExample": "示例一：使用实例锁来同步静态共享变量\npublic class SomeSharedResource {\n    private static volatile int counter;\n    private final Object lock = new Object();\n    public void updateResource() {\n        /* POTENTIAL FLAW: 程序不能使用实例锁来保护静态共享数据，因为实例锁在两个或多个实例的情况下是无效的，导致并发时的线程同步失效 */\n        synchronized (lock) {\n            counter++;\n        }\n    }\n}；\n实例二： 使用同步方法来同步静态共享变量\npublic class SomeSharedResource {\n    private static volatile int counter;\n    /* POTENTIAL FLAW: 程序不能使用同步方法来同步静态共享变量 */\n    public synchronized void updateResource() {\n        counter++;\n    }\n}",
					"badExample": "public class CWE413_J_Rule5_2_Forbid_Synchronize_Reused_Object_Bad {\n\n    private static final Logger LOGGER = Logger.getLogger(CWE413_J_Rule5_2_Forbid_Synchronize_Reused_Object_Bad.class);\n\n    private final String lock = \"LOCK\";\n\n \n\n    public void testBad() {\n\n        /* POTENTIAL FLAW: 程序不能基于那些可能会被重用的对象进行同步 */\n\n        synchronized (lock) {\n\n            LOGGER.info(\"synchronized start\");\n\n        }\n\n    }\n\n}&lt;/pre&gt;",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.OTH.01 安全场景下必须使用密码学意义上的安全随机数",
					"language": "java",
					"id": "51bfea250fef11edab5284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "安全场景下必须使用密码学意义上的安全随机数。\n\n不安全的随机数可能被部分或全部预测到，导致系统存在安全隐患，安全场景下使用的随机数必须是密码学意义上的安全随机数。密码学意义上的安全随机数分为两类：\n1.真随机数产生器产生的随机数；\n2.以真随机数产生器产生的少量随机数作为种子的密码学安全的伪随机数产生器产生的大量随机数。\n\n已知的可供产品使用的密码学安全的非物理真随机数产生器有：Linux操作系统的/dev/random设备接口（存在阻塞问题）和Windows操作系统的CryptGenRandom接口。Java中的SecureRandom是一种密码学安全的伪随机数产生器，对于使用非真随机数产生器产生随机数时，要使用少量真随机数作为种子。常见安全场景包括但不限于以下场景：\n1.用于密码算法用途，如生成IV、盐值、秘钥等；\n2.会话标识（sessionId）的生成；\n3.挑战算法中的随机数生成；\n4.验证码的随机数生成。",
					"systemTag": "codemars",
					"goodExample": "明确指定采用sun.security.provider.SecureRandom作为随机数产生器，然后使用generateSeed()方法产生的随机数作为种子，该方法产生的随机数默认为真随机数（如linux下从/dev/random获取）。下述代码实际是使用少量真随机数作为种子（种子长度推荐不少于64bytes），然后采用伪随机数产生器来产生随机数，避免linxu下阻塞问题。对于需要生成大量随机数的场景，需要周期性补充种子，SHA1PRNG算法目前业界没有明确标准，推荐获取2^32次随机数后设置一次种子（调用一次nextBytes()、nextInt()等都计为一次获取随机数操作）。\n",
					"badExample": "public byte[] generateSalt() {\n    byte[] salt = new byte[8];\n    Random random = new Random();\n    random.nextBytes(salt);\n    return salt;\n}&lt;/pre&gt;",
					"recommend": "使用安全的随机数。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FIO.03 对于从流中读取一个字符或字节的方法，使用int类型的返回值",
					"language": "java",
					"id": "51bfea270fef11ed909c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "从流中读取一个字符或字节的方法，未使用int类型的返回值。\n\nJava中InputStream.read()和Reader.read()方法用于从流中读取一个字节（byte）或字符（char）。InputStream.read()读取一个字节，返回值的范围为0x00-0xFF（补码），8位；Reader.read()读取一个字符，返回值的范围为0x0000-0xFFFF（补码），16位。当读取到流的末尾时，以上方法均返回int类型的-1（补码表示为0xFFFFFFFF），32位。因此，如果在未判断返回值是否是流末尾标志-1（补码表示为0xFFFFFFFF）前将返回值转为byte或 char，会导致无法正确判断返回值是流中的内容还是结束标识。",
					"systemTag": "codemars",
					"goodExample": "public class CWE682_J_Rule6_4_Invalid_Read_From_Stream_01_Good {\n\n    private static final Logger LOGGER = Logger.getLogger(CWE682_J_Rule6_4_Invalid_Read_From_Stream_01_Good.class);\n\n\n\n    public static void readBytesFromStreamGood() {\n\n        try (FileInputStream in = new FileInputStream(\"demo.txt\")) {\n\n            // Initialize stream\n\n            int data;\n\n            while ((data = in.read()) != -1) {\n\n                LOGGER.info(data);\n\n            }\n\n        } catch (Exception e) {\n\n            LOGGER.error(\"error\");\n\n        }\n\n    }\n\n}&lt;/pre&gt;",
					"badExample": "示例一：将 read() 方法返回的值直接转换为byte类型，并将转换后的结果与-1进行比较，进而判断是否达到流的末尾。如果 read() 返回值为0xFF，0xFF转为有符号byte即为byte类型-1，循环结束条件判断通过，结果就是错误的以为流结束了。\nFileInputStream in = getReadableStream();\nbyte data;\nwhile ((data = (byte) in.read()) != -1) {\n    // ... 使用data\n}，\n示例二：将 read() 方法返回的值直接转换为char类型，并将转换后的结果与-1进行比较，进而判断是否达到流的末尾。当读取流结束后，返回值转为char类型后也不为-1，因此即使流读取结束， while循环仍无法正确终止。 原因是流结束标志-1（补码表示为0xFFFFFFFF）被强转为char类型时，会被转为0xFFFF，再和-1进行比较时等式不成立，导致循环结束条件永假。\nFileReader in = getReader();\nchar data;\nwhile ((data = (char) in.read()) != -1) {\n    // ... 使用data\n}&lt;/pre&gt;",
					"recommend": "使用int类型的变量来保存read()的返回值，并使用该返回值判断是否读取到流的末尾，流未读完时，将读取的内容转换为byte类型。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.SER.06 序列化操作要防止敏感信息泄露",
					"language": "java",
					"id": "51c011150fef11ed9ce884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "敏感数据传递前，先签名再加密。\n\n敏感数据传输过程中要防止被窃取和恶意篡改。使用安全的加密算法加密传输对象可以保护数据。这就是所谓的对对象进行密封。而对密封的对象进行数字签名则可以防止对象被非法篡改，保持其完整性。在以下场景中，需要对对象进行密封和数字签名来保证数据安全：\n1.序列化或传输敏感数据；\n2.没有使用类似于SSL传输通道；\n3.敏感数据需要长久保存（如保存在硬盘驱动器上）。\n\n应该避免使用私有加密算法，因为这样会引入不必要的漏洞。在readObject()和writeObject()函数中使用私有加密算法的应用是典型的反面示例。",
					"systemTag": "codemars",
					"goodExample": "示例一：先为对象签名然后再加密。 这样既能保证数据的真实可靠性，又能防止“中间人攻击”（man-inmiddle attacks）。\npublic static void main(String[] args) throws IOException, GeneralSecurityException, ClassNotFoundException {\n    // Build map\n    SerializableMap&lt;String, Integer&gt; map = buildMap();\n    // Generate signing public/private key pair & sign map\n    KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n    KeyPair kp = kpg.generateKeyPair();\n    Signature sig = Signature.getInstance(\"SHA256withRSA\");\n    SignedObject signedMap = new SignedObject(map, kp.getPrivate(), sig);\n    // Generate sealing key & seal map\n    KeyGenerator generator = KeyGenerator.getInstance(\"AES\");\n    generator.init(new SecureRandom());\n    Key key = generator.generateKey();\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    SealedObject sealedMap = new SealedObject(signedMap, cipher);\n    // Serialize map\n    ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"data\"));\n    out.writeObject(sealedMap);\n    out.close();\n    // Deserialize map\n    ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"data\"));\n    sealedMap = (SealedObject) in.readObject();\n    in.close();\n    // Unseal map cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, key);\n    signedMap = (SignedObject) sealedMap.getObject(cipher);\n    // Verify signature and retrieve map\n    if (!signedMap.verify(kp.getPublic(), sig)) {\n        throw new GeneralSecurityException(\"Map failed verification\");\n    }\n    map = (SerializableMap&lt;String, Integer&gt;) signedMap.getObject();\n    // Inspect map\n    InspectMap(map);\n}&lt;/pre&gt;",
					"badExample": "示例一：未对数据进行签名，因此无法进行可靠性验证。\npublic static void main(String[] args) throws IOException, GeneralSecurityException, ClassNotFoundException {\n    // Build map\n    SerializableMap&lt;String, Integer&gt; map = buildMap();\n    // Generate sealing key & seal map\n    KeyGenerator generator = KeyGenerator.getInstance(\"AES\");\n    generator.init(new SecureRandom());\n    Key key = generator.generateKey();\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    SealedObject sealedMap = new SealedObject(map, cipher);\n    // Serialize map\n    ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"data\"));\n    out.writeObject(sealedMap);\n    out.close();\n    // Deserialize map\n    ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"data\"));\n    sealedMap = (SealedObject) in.readObject();\n    in.close();\n    // Unseal map\n    cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, key);\n    map = (SerializableMap&lt;String, Integer&gt;) sealedMap.getObject(cipher);\n    // Inspect map\n    InspectMap(map);\n},\n示例二：先将对象加密然后为其签名。任何恶意的第三方可以截获原始加密签名后的数据，剔除原始的签名，并对密封的数据加上自己的签名。这样一来，由于对象被加密和签名（只有在签名验证通过后才可以解密对象），恶意第三方和正常的接收者均无法得到原始的消息内容。\npublic static void main(String[] args) throws IOException, GeneralSecurityException, ClassNotFoundException {\n    /// Build map\n    SerializableMap&lt;String, Integer&gt; map = buildMap();\n    // Generate sealing key & seal map\n    KeyGenerator generator = KeyGenerator.getInstance(\"AES\");\n    generator.init(new SecureRandom());\n    Key key = generator.generateKey();\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    SealedObject sealedMap = new SealedObject(map, cipher);\n    // Generate signing public/private key pair & sign map\n    KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n    KeyPair kp = kpg.generateKeyPair();\n    Signature sig = Signature.getInstance(\"SHA256withRSA\");\n    SignedObject signedMap = new SignedObject(sealedMap, kp.getPrivate(), sig);\n    // Serialize map\n    ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"data\"));\n    out.writeObject(signedMap);\n    out.close();\n    // Deserialize map\n    ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"data\"));\n    signedMap = (SignedObject) in.readObject();\n    in.close();\n    // Verify signature and retrieve map\n    if (!signedMap.verify(kp.getPublic(), sig)) {\n        throw new GeneralSecurityException(\"Map failed verification\");\n    }\n    sealedMap = (SealedObject) signedMap.getObject();\n    // Unseal map\n    cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, key);\n    map = (SerializableMap&lt;String, Integer&gt;) sealedMap.getObject(cipher);\n    // Inspect map\n    InspectMap(map);\n}&lt;/pre&gt;",
					"recommend": "敏感数据传递前签名并加密。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.EDV.05 防止解析来自外部的XML导致的外部实体（XML External Entity）攻击",
					"language": "java",
					"id": "51c011170fef11ed819484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "XML实体攻击。XML实体包括内部实体和外部实体。\n外部实体格式：&lt;!ENTITY 实体名 SYSTEM \"URI\"\\&gt;  或者 &lt;!ENTITY 实体名 PUBLIC \"public_ID\" \"URI\"\\&gt; 。Java中引入外部实体的协议包括http、https、ftp、file、jar、netdoc、mailto等。XXE漏洞发生在应用程序解析来自外部的XML数据或文件时没有禁止外部实体的加载，造成任意文件读取、内网端口扫描、内网网站攻击、DoS攻击等危害。\nXML内部实体是实体的内容已经在Doctype中声明。内部实体格式： &lt;!ENTITY 实体名 \"实体的值\"\\&gt; 。\n内部实体攻击比较常见的是XML Entity Expansion攻击，它主要试图通过消耗目标程序的服务器内存资\n源导致DoS攻击。外部实体攻击和内部实体扩展攻击有不同的防护措施（禁止DTDs解析可以防护外部\n实体和内部实体攻击）。&lt;/pre&gt;",
					"systemTag": "codemars",
					"goodExample": "示例一：代码中设置禁止解析DTDs属性\nprivate void parseXmlFile(String filePath) throws Exception {\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n    factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n    DocumentBuilder db = factory.newDocumentBuilder();\n    Document doc = db.parse(new File(filePath));\n    // ...\n}，\n示例二：使用SAXReader解析xml，并设置禁止解析DTDs属性\n\nprivate void parseXmlFile(String filePath) throws Exception {\n    SAXReader reader = new SAXReader();\n    reader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n    Document doc = reader.read(new File(filePath));\n    // ...\n}，\n示例三：代码中设置禁止解析DTDs属性\nprivate void parseXmlFile(String filePath) throws Exception {\n    SAXTransformerFactory tf = (SAXTransformerFactory) SAXTransformerFactory.newInstance();\n    tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n    tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\");\n    Transformer transformer = tf.newTransformer();\n    // ...\n}，\n示例四： 代码中设置禁止解析DTDs属性\nprivate void parseXmlFile(String filePath) throws Exception {\n    XMLInputFactory xmlFactory = XMLInputFactory.newInstance();\n    xmlFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n    InputStream inputStream = new FileInputStream(filePath);\n    XMLStreamReader reader = xmlFactory.createXMLStreamReader(inputStream);\n    // ...\n}&lt;/pre&gt;",
					"badExample": "示例一：解析XML文件时未禁止解析DTDs属性\nprivate void parseXmlFile(String filePath) throws Exception {\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n    DocumentBuilder db = factory.newDocumentBuilder();\n    Document doc = db.parse(new File(filePath));\n    // ...\n}，\n示例二：使用SAXReader解析xml，并设置禁止解析DTDs属性\n\nprivate void parseXmlFile(String filePath) throws Exception {\n    SAXReader reader = new SAXReader();\n    Document doc = reader.read(new File(filePath));\n    // ...\n}，\n示例三：解析XML文件时未禁止解析DTDs属性\nprivate void parseXmlFile(String filePath) throws Exception {\n    SAXTransformerFactory tf = (SAXTransformerFactory) SAXTransformerFactory.newInstance();\n    Transformer transformer = tf.newTransformer();\n    // ...\n}，\n示例四：解析XML文件时未禁止解析DTDs属性\nprivate void parseXmlFile(String filePath) throws Exception {\n    XMLInputFactory xmlFactory = XMLInputFactory.newInstance();\n    InputStream inputStream = new FileInputStream(filePath);\n    XMLStreamReader reader = xmlFactory.createXMLStreamReader(inputStream);\n    // ...\n}&lt;/pre&gt;",
					"recommend": "为了避免 XXE 注入，应对 XML 解析器进行安全配置，使它不允许将外部实体包含在传入的 XML 文档中。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.CMT.03 方法的Javadoc中应该包含功能说明，根据实际需要按顺序使用@param、@return、@throws标签对参数、返回值、异常进行注释——功能描述和标签之间要有一个空行",
					"language": "java",
					"id": "51c0111b0fef11edb40584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": " 方法的Javadoc中应该包含功能说明，根据实际需要按顺序使用@param、@return、@throws标签对参数、返回值、异常进行注释\n\n工具检查场景:\n- 检查方法的Javadoc是否有功能说明；如果没有Javadoc，这条规则不告警，会在G.CMT.01中告警\n- 检查方法的Javadoc的功能描述与标签之间是否只空1行，没有空行和多余空行都会告警\n- 如果方法有参数，检查Javadoc中是否对每个参数都有@param标签\n- 如果方法有返回值，检查Javadoc中是否有@return标签\n- 如果方法有抛异常，检查Javadoc中是否对每个异常都有@throws标签\n- 检查标签是否按照@param、@return、@throws的顺序排列\n- 检查Javadoc第一行或最后一行不能有注释内容\n- 例外场景：\n  - 不检查继承的Javadoc（ @inheritDoc）\n  - 不检查隐藏的Javadoc（@hide） ",
					"systemTag": "fixbotengine-java",
					"goodExample": " /**\n * 对示例接口的概述介绍\n *\n * @since 2019-01-01\n */\nprotected abstract class Sample {\n    /**\n     * 这是一段长注释，要根据注释内容进行合理拆分为多行注释...\n     * 这是第二行注释。\n     * 符合： 功能说明要与下面的@标签之间保留一个空行\n     *\n     * @param fox 参数fox的说明，例如：与懒狗进行挑战的狐狸对象\n     * @return 方法返回值的说明，例如：返回狐狸与狗的交战结果\n     */\n    protected abstract int foo(Fox fox);\n\n    /**\n     * 函数的功能说明\n     * 符合： 功能说明要与下面的@标签之间保留一个空行\n     *\n     * @return 方法返回值的说明，例如：返回狐狸与狗的交战结果\n     * @throws ProblemException 异常说明，例如：懒狗死亡抛出该异常\n     */\n    protected int bar() throws ProblemException {\n        // 变量注释\n        var aVar = ...;\n\n        // 方法注释  符合：注释要与前面的代码之间保留一个空行\n        doSome();\n    }\n} ",
					"badExample": " /**\n     */\n    public void methodDemo() {\n    } ",
					"recommend": " 增加功能说明和相应标签 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CMT.05 文件头注释应该包含版权许可信息",
					"language": "java",
					"id": "51c0111d0fef11edbd3584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": " 文件头注释必须放在package和import之前，必须包含版权许可信息，如果需要在文件头注释中增加其他内容，可以在后面以相同格式补充。版权许可不应该使用javadoc样式或单行样式的注释，必须从文件顶头开始。如果包含“关键资产说明”类注释，则应紧随其后。\n\n工具检查场景:\n- 检查文件头注释是否在第一行\n- 检查文件头注释是否包含版权字样（\"Copyright\"或\"版权所有\"），是否包含文件首次创建时间和最后修改年份（如2012-2021）\n- 检查文件头注释的首次创建年份是否晚于最后修改年份\n- 检查文件头注释的最后修改年份是否晚于当前年份\n- 例外场景\n  - 如果为KIA文件，文件第一行是KIA注释，文件头注释可以在KIA注释下方 ",
					"systemTag": "fixbotengine-java",
					"goodExample": " 中文版：\n/*\n * 版权所有 (c) 华为技术有限公司 2012-2020\n */\n英文版：\n/* \n * Copyright (c) Huawei Technologies Co., Ltd. 2012-2020. All rights reserved. \n */ ",
					"badExample": " /**\n * Huawei Technologies Co., Ltd. 2012-2020. All rights reserved. \n */ ",
					"recommend": " 增加标准的版权信息 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CTL.03 switch语句要有default分支",
					"language": "java",
					"id": "51c0111f0fef11ed8c2184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " switch语句要有default分支\n\n工具检查场景：\n- 检查每个switch语句都应该包含一个default分支，即使default分支没有业务逻辑代码\n- 例外场景\n  - 不检查枚举类型（case变量为全大写/数字/下划线的标识符）的switch语句 ",
					"systemTag": "fixbotengine-java",
					"goodExample": " switch(var) {\n    case 1:\n        break;\n    default:\n        break;\n} ",
					"badExample": " switch(var) {\n    case 1:\n       break;\n} ",
					"recommend": " 增加default分支 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.03 条件表达式?:的第2和第3个操作数应使用相同的类型",
					"language": "java",
					"id": "51c011210fef11eda0ab84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 条件运算符?:使用第1个操作数的布尔值决定后续表达式哪个被执行。但是Java语言有相当复杂的规则去判定表达式的结果类型，不一致的操作数类型，可能导致意料之外的类型转换。如第2和第3个操作数在类型对齐时，可能会因为自动拆箱导致NullPointerException。\n\n工具检查场景：\n检查条件表达式?:的第2和第3个操作数是否具有相同类型 ",
					"systemTag": "fixbotengine-java",
					"goodExample": " char ch = 'A';\nint value = 50;\nboolean condition = ...; // condition的值为true时\nSystem.out.println(condition ? ch : ((char) value)); // 输出 A\nInteger integer = null;\nSystem.out.print(condition ? integer : Integer.valueOf(value)); // 输出 null ",
					"badExample": " ar ch = 'A';\nint value = 50;\nboolean condition = ...; // condition的值为true时\nSystem.out.println(condition ? ch : value); // 输出 65\nInteger integer = null;\nSystem.out.print(condition ? integer : value); // 抛 NullPointerException ",
					"recommend": " 修改成相同类型 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.MET.01 方法要简短——方法的代码块嵌套深度不应超过4层",
					"language": "java",
					"id": "51c011230fef11ed936e84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": " 方法要简短\n\n工具检查场景:\n- 检查每个方法行数是否超过50行（非空非注释）\n- 检查每个方法的参数是否超过5个\n- 检查每个方法的代码块嵌套深度是否超过4层（方法本身算一层，try-catch不算一层，lamda表达式、局部类或匿名类层次以最内层方法计算，不累计） ",
					"systemTag": "fixbotengine-java",
					"goodExample": " 嵌套层数是2：\nint foo(Item msg) {\n    ...\n    if (!isReceived) {\n        return -1;\n    }\n\n    type = getMsgType(msg);\n    if (type == UNKNOWN) {\n        return -1;\n    }\n\n    return dealMsg(type);\n} ",
					"badExample": " 嵌套层数是4：\nint foo(Item msg) {\n    ...\n    if (isReceived) {\n        type = getMsgType(msg);\n        if (type != UNKNOWN) {\n            if (msg.isEmpty()) {\n                return dealMsg(type);\n            }\n        }\n    }\n    return -1;\n} ",
					"recommend": " 重构和简化方法 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.NAM.08 布尔型变量建议以表达是非意义的动词开头",
					"language": "java",
					"id": "51c011250fef11edadd284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": " 布尔型变量建议以表达是非意义的动词开头\n\n工具检查场景:\n- 检查布尔变量名是否以是非意义的动词（is, has, can, should）开头 ",
					"systemTag": "fixbotengine-java",
					"goodExample": " boolean isError; \nboolean hasLicense; \nboolean canEvaluate; \nboolean shouldAbort = false; ",
					"badExample": " boolean error;\nboolean found; ",
					"recommend": " 修改变量名，增加是非意义的动词 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.OBJ.05 避免基本类型与其包装类型的同名重载方法",
					"language": "java",
					"id": "51c011270fef11edad0484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 有歧义的重载或者误导性的重载，会导致非预期的结果。\n\n工具检查场景：\n- 检查类中是否有基本类型和其包装类型的同名重载方法 ",
					"systemTag": "fixbotengine-java",
					"goodExample": " class SomeResource {\n    HashMap<Integer, Integer> hm = ...;\n\n    public static Employee createSomeResourceByInt(int id, String name) {\n        // 非重载，使用int类型的id构造对象\n    }\n\n    public static Employee createSomeResourceByInteger(Integer id, String name) {\n        // 非重载，使用Integer类型的id构造对象\n    }\n\n    public Integer getDataByIndex(int id) {\n        // 非重载\n    }\n\n    public String getDataByValue(Integer id) {\n        // 非重载\n    }\n} ",
					"badExample": " class SomeResource {\n    HashMap<Integer, Integer> hm = ...;\n\n    public SomeResource(int id, String name) {\n        ...\n    }\n\n    public SomeResource(Integer id, String name) {\n        ...\n    }\n\n    public String getData(Integer id) { // 重载序列 #1\n        // 获取一个特定的记录\n        String str = hm.get(id).toString();\n        return str + SUFFIX;\n    }\n\n    public Integer getData(int id) { // 重载序列 #2\n        // 获取在位置id的记录\n        return hm.get(id);\n    }\n} ",
					"recommend": " 重命名方法，消除重载 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.OBJ.07 子类覆写父类方法或实现接口时必须加上@Override注解",
					"language": "java",
					"id": "51c038340fef11ed817b84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 加上@Override注解的好处是，如果覆写时因为疏忽，导致子类方法的参数同父类不一致，编译时会报错，使问题在编译期就被发现；如果父类修改了方法定义造成子类不再覆写父类方法，也能使问题在编译期尽早被发现。\n\n工具检查场景：\n- 检查子类覆写父类方法或实现接口时是否加了@Override注解 ",
					"systemTag": "fixbotengine-java",
					"goodExample": " public class ClassDemo {\n    public void methodDemo() {\n        ...\n    }\n}\n\npublic class SubClassDemo extends ClassDemo {\n    @Override\n    public void methodDemo() {\n        ...\n    }\n} ",
					"badExample": " public class ClassDemo {\n    public void methodDemo() {\n        ...\n    }\n}\n\npublic class SubClassDemo extends ClassDemo {\n    public void methodDemo() {\n        ...\n    }\n} ",
					"recommend": " 增加@Override注解 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.SER.02 实现Serializable接口的可序列化类应该显式声明serialVersionUID",
					"language": "java",
					"id": "51c038360fef11eda9d784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 实现Serializable接口的可序列化类应该显式声明serialVersionUID\n\n工具检查场景:\n- 检查一个实现Serializable接口的类是否显示声明了serialVersionUID ",
					"systemTag": "fixbotengine-java",
					"goodExample": " public class BeanType implements Serializable {\n    private static final long serialVersionUID = -2589766491699675794L;\n    ...\n} ",
					"badExample": " public class BeanType implements Serializable {\n    ...\n} ",
					"recommend": " 增加serialVersionUID ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.TYP.11 基本类型优于包装类型，注意合理使用包装类型",
					"language": "java",
					"id": "51c038380fef11eda9e784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": " 很多情况下基本类型优于包装类型\n\n工具检查场景：\n- 检查for循环变量是否为包装类型（Integer）\n- 检查整数型包装类型变量是否用==比较 ",
					"systemTag": "fixbotengine-java",
					"goodExample": " for(int i = 0; i < 10; ++i) {\n    ...\n} ",
					"badExample": " for(Integer i = 0; i < 10; ++i) {\n    ...\n} ",
					"recommend": " 使用基本类型 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.TYP.12 明确地进行类型转换，避免依赖隐式类型转换",
					"language": "java",
					"id": "51c0383a0fef11ed90cb84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": " 明确的类型转换表明程序员知道混合运算中所涉及的不同类型。\n\n避免意外地浮点数转换截取，否则会导致误差被逐步放大。\n\n工具检查场景：\n- 检查算术表达式（`+`, `-`, `*`, `/`)中是否一个是int/long类型，另一个是float/double类型\n- 检查算术表达式（`+`, `-`, `*`, `/`)中是否全是int类型，但赋值给一个float/double类型 ",
					"systemTag": "fixbotengine-java",
					"goodExample": " int value1 =  1799999999;\ndouble value2 = 1.0d;\n\n// 明确将int型转为double型\ndouble result = (double) value1 * value2; // 结果为 1.799999999E9\n\ndouble value3 = 0xffffffa;\nvalue3 += 1.0d; // 运算后的结果为 0xffffffb，与预期一致 ",
					"badExample": " int value1 =  1799999999;\ndouble value2 = 1.0d;\n\n// 明确将int型转为double型\ndouble result = (double) value1 * value2; // 结果为 1.799999999E9\n\ndouble value3 = 0xffffffa;\nvalue3 += 1.0d; // 运算后的结果为 0xffffffb，与预期一致 ",
					"recommend": " 增加显示类型转换 ",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.OTH.02 必须使用SSLSocket代替Socket来进行安全数据交互",
					"language": "java",
					"id": "51c0383c0fef11ed840684a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "使用不安全的通讯协议Socket进行敏感数据传输。当网络通信中涉及明文的敏感信息时，需要使用SSLSocket而不是Socket，Socket是明文通信，攻击者 可以通过网络监听获取其中的敏感信息，通过中间人攻击对报文进行恶意篡改。SSLSocket是在Socket 的基础上进行了一层安全性保护，包括身份认证、数据加密和完整性保护。&lt;/pre&gt;",
					"systemTag": "codemars",
					"goodExample": "try {\n    SSLSocketFactory sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n    SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(ip, port);\n    os = sslSocket.getOutputStream();\n    os.write(userInfo.getBytes(StandardCharsets.UTF_8));\n    // ...\n} catch (IOException ex) {\n    // 处理异常\n} finally {\n    // 关闭流\n}&lt;/pre&gt;",
					"badExample": "try {\n    Socket socket = new Socket();\n    socket.connect(new InetSocketAddress(ip, port), 10000);\n    os = socket.getOutputStream();\n    os.write(userInfo.getBytes(StandardCharsets.UTF_8));\n    // ...\n} catch (IOException ex) {\n    // 处理异常\n} finally {\n    // 关闭流\n}&lt;/pre&gt;",
					"recommend": "当网络通信中涉及明文的敏感信息时，需要使用SSLSocket而不是Socket。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.SER.05 禁止序列化非静态的内部类",
					"language": "java",
					"id": "51c0383e0fef11eda70a84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "序列化非静态内部类。\n内部类是没有显式或隐式声明为静态的嵌套类。内部类（包括本地类和匿名类）的序列化很容易出错。 \n1. 在使用非静态内部类时，实际上隐含着对外部类实例的非transient引用，在对内部类进行序列化时，会一起将外部类也序列化。\n2. 内部类的实现与synthetic属性有关，对synthetic关键字，不同的编译器的实现不同，会影响程序的兼容性。并且会跟默认的serialVersionID产生冲突。\n3. 内部类不能声明静态成员以外的运行时常量，所以不能使用serialPersistentFields机制来指定可以序列化的属性。\n4. 与外部实例关联的内部类没有无参构造方法（此内部类的构造方法隐式的接收外部实例作为前置参数）。内部类无法实现Externalizable接口，Externalizable接口要求实现对象通过writeExternal()和readExternal()方法手动保存和恢复其状态。基于以上原因，禁止序列化非静态内部类。但是这些原因不适用于静态内部类，所以静态内部类可以进行序列化。",
					"systemTag": "codemars",
					"goodExample": "public class SomeResource implements Serializable {\n    private static final long serialVersionUID = 3938280590455555273L;\n    private String fileName;\n    // ...\n    static class InnerClass implements Serializable {\n        private static final long serialVersionUID = 6562477636399915529L;\n        private String name;\n        // ...\n    }\n}&lt;/pre&gt;",
					"badExample": "内部类序列化时，外部类中的属性也将被序列化。\npublic class SomeResource implements Serializable {\n    private static final long serialVersionUID = 2589766491699675794L;\n    private String fileName;\n    // ...\n    /* POTENTIAL FLAW: 实施 java.io.Serializable 的内部类可能会导致问题以及泄露外部类中的信息。 */\n    class InnerClass implements Serializable {\n        private static final long serialVersionUID = 6562477636399915529L;\n        private String name;\n        // ...\n    }\n}",
					"recommend": "在使用内部类时，不应对其进行序列化，否则它们将变为静态嵌套类，由此就不会出现对非静态内部类执行序列化时会出现的问题。如果嵌套类为静态类型，则其本质上与实例变量并无关联（包括外部类的实例变量），并且不会导致对外部类执行序列化。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.CON.01 对共享变量做同步访问控制时需避开同步陷阱——不要使用基于高级并发对象的synchronized块",
					"language": "java",
					"id": "51c038400fef11ed983284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "避免使用了基于高级并发对象的synchronized块。\n\n使用了基于高级并发对象的synchronized块。高级并发类是指实现java.util.concurrent.locks包中的Lock或Condition接口的类，其本身提供了lock与unlock来实现同步，不应将这些类的对象作为synchronized块的同步对象使用。当使用基于高层并发对象的synchronized块时，容易被误认为这种方式与正常使用lock接口的方式是同一个锁，而实际是两个不同的锁，会导致无法实现同步控制。\n",
					"systemTag": "codemars",
					"goodExample": "public class SomeSharedResource {\n    private final Lock lock = new ReentrantLock();\n    public void updateResource() {\n        lock.lock();\n        try {\n            // 更新共享的资源\n            // ...\n        } finally {\n            lock.unlock();\n        }\n    }\n    public void doSomething() {\n        lock.lock();\n        try {\n            // 更新共享的资源\n            // ...\n        } finally {\n            lock.unlock();\n        }\n    }\n}&lt;/pre&gt;",
					"badExample": "public class SomeSharedResource {\n    private final Lock lock = new ReentrantLock();\n    public void updateResource() {\n        synchronized (lock) {\n            // 更新共享的资源\n            // ...\n        }\n    }\n    public void doSomething() {\n        lock.lock();\n        try {\n            // 更新共享的资源\n            // ...\n        } finally {\n            lock.unlock();\n        }\n    }\n}&lt;/pre&gt;",
					"recommend": "使用Lock接口提供的lock()和unlock()方法。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.CON.01 对共享变量做同步访问控制时需避开同步陷阱——避免使用class这类容易造成歧义的对象锁，而应使用明确的对象",
					"language": "java",
					"id": "51c038420fef11edb91284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "避免使用class类对象锁。如果使用class类对象作为同步对象，父子类继承关系增加了class类对象归属的复杂度，开发人员容易犯错，导致同步行为不符合预期；故应避免使用class这类容易造成歧义的对象，而应使用明确的对象。&lt;/pre&gt;",
					"systemTag": "codemars",
					"goodExample": "public class SomeSharedResource {\n    private final Object lock = new Object();\n    public void updateResource() {\n        synchronized (lock) {\n            // 更新共享的资源\n            // ...\n        }\n    }\n}&lt;/pre&gt;",
					"badExample": "public class SomeSharedResource {\n    public void updateResource() {\n        synchronized (this.getClass()) {\n            // 更新共享的资源\n            // ...\n        }\n    }\n}&lt;/pre&gt;",
					"recommend": "禁止基于getClass()返回的类对象进行同步。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.CON.01 对共享变量做同步访问控制时需避开同步陷阱——不要使用可被重用的对象锁",
					"language": "java",
					"id": "51c038440fef11ed841084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "使用可被重用的对象锁。如果使用可被重用的对象作为同步对象，容易导致不同的共享变量实际依赖了同一个锁，无法实现符合预期的同步效果。常见的可被重用的对象包括Boolean、封包的Integer对象、String常量等。&lt;/pre&gt;",
					"systemTag": "codemars",
					"goodExample": "public class SomeSharedResource {\n    private final Object lock = new Object();\n    public void updateResource() {\n        synchronized (lock) {\n            // 更新共享的资源\n            // ...\n        }\n    }\n}&lt;/pre&gt;",
					"badExample": "public class SomeSharedResource {\n    private final String lock = \"lock\";\n    public void updateResource() {\n        synchronized (lock) {\n            // 更新共享的资源\n            // ...\n        }\n    }\n}&lt;/pre&gt;",
					"recommend": "程序不能基于那些可能会被重用的对象进行同步。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "Forbid_Thread.run()",
					"language": "java",
					"id": "51c038460fef11edb59384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "禁止直接调用Thread.run()方法启动线程。调用Thread.start()方法表示启动一个线程，并执行该线程对应的run()方法。但是直接调用Thread.run()方法，run()方法中的语句是由当前线程执行而不是新创建线程来执行。&lt;/pre&gt;",
					"systemTag": "codemars",
					"goodExample": "public final class Foo implements Runnable {\n    @Override\n    public void run() {\n        // ...\n    }\n    public static void main(String[] args) {\n        Foo foo = new Foo();\n        new Thread(foo).start();\n    }\n}&lt;/pre&gt;",
					"badExample": "public final class Foo implements Runnable {\n    @Override\n    public void run() {\n        // ...\n    }\n    public static void main(String[] args) {\n        Foo foo = new Foo();\n        new Thread(foo).run();\n    }\n}&lt;/pre&gt;",
					"recommend": "调用 start() 来取代调用 run()。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.CON.11 禁止使用Thread.stop()来终止线程",
					"language": "java",
					"id": "51c038480fef11edb02284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "禁止调用Thread.stop()。\n\nThread.stop()已经被标记为@Deprecated，该方法是不安全的，调用Thread.stop()来终止线程会使其释放它所持有的所有锁，可能会导致这些锁保护的对象处于不一致的状态。\n",
					"systemTag": "codemars",
					"goodExample": "public final class Foo implements Runnable {\n    private volatile boolean shouldAbort = false;\n    public void stop() {\n        shouldAbort = true;\n    }\n    @Override\n    public void run() {\n        // ...\n        while (!shouldAbort) {\n            // ...\n        }\n    }\n    public static void main(String[] args) {\n        Foo foo = new Foo();\n        Thread thread = new Thread(foo);\n        thread.start();\n        // ...\n        foo.stop();\n    }\n}&lt;/pre&gt;",
					"badExample": "public final class Foo implements Runnable {\n    @Override\n    public void run() {\n        // ...\n    }\n    public static void main(String[] args) {\n        Foo foo = new Foo();\n        Thread thread = new Thread(foo);\n        thread.start();\n        // ...\n        thread.stop();\n    }\n}&lt;/pre&gt;",
					"recommend": "禁止调用Thread.stop()。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.EDV.07 禁止使用不安全的XSLT转换XML文件",
					"language": "java",
					"id": "51c060700fef11eda31784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "使用不安全的XSLT转换XML文件。\n\nXSLT是一种样式转换标记语言，可以将XML数据转换为另外的XML或其他格式，如HTML网页，纯文字。因为XSLT的功能十分强大，可以导致任意代码执行，当使用TransformerFactory转换XML格式数据的时候，需要添加安全策略禁止不安全的XSLT代码执行。",
					"systemTag": "codemars",
					"goodExample": "public void xsltTrans(String src, String dst, String xslt) {\n    // 获取转换器工厂\n    TransformerFactory tf = TransformerFactory.newInstance();\n    try {\n        // 转换器工厂设置黑名单，禁用一些不安全的方法，类似XXE防护\n        tf.setFeature(\"http://javax.xml.XMLConstants/feature/secure-processing\", true);\n        // 获取转换器对象实例\n        Transformer transformer = tf.newTransformer(new StreamSource(xslt));\n        // 去掉&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n        transformer.setOutputProperty(\"omit-xml-declaration\", \"yes\");\n        // 进行转换\n        transformer.transform(new StreamSource(src), new StreamResult(new FileOutputStream(dst)));\n        // ...\n    } catch (TransformerException ex) {\n        // 处理异常\n    }\n    // ...\n}&lt;/pre&gt;",
					"badExample": "public void XsltTrans(String src, String dst, String xslt) {\n    // 获取转换器工厂\n    TransformerFactory tf = TransformerFactory.newInstance();\n    try {\n        // 获取转换器对象实例\n        Transformer transformer = tf.newTransformer(new StreamSource(xslt));\n        // 进行转换\n        transformer.transform(new StreamSource(src), new StreamResult(new FileOutputStream(dst)));\n        // ...\n    } catch (TransformerException ex) {\n        // 处理异常\n    }\n    // ...\n}&lt;/pre&gt;",
					"recommend": "在TransformerFactory中开启安全防护策略。Java对xslt内置了黑名单，通过将http://javax.xml.XMLConstants/feature/secure-processing属性设置为true开启防护，可以禁用一些不安全的方法。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.SEC.01 进行安全检查的方法必须声明为private或final",
					"language": "java",
					"id": "51c060720fef11edbf8584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "安全检查方法可能被子类重写。\n\n实现安全检查功能（主要是指调用SecurityManager执行的安全检查）的方法，如果可以被子类重写，恶意子类可以重写安全检查方法，忽略这些安全检查，使安全检查失效。所以安全检查相关的方法必须声明为private或final，防止被子类重写。",
					"systemTag": "codemars",
					"goodExample": "  方法声明为private方法，防止被子类重写。\n  ```java\n  private PasswordAuthentication requestPasswordAuthentication(InetAddress addr, String protocol, String prompt, String scheme) {\n      SecurityManager sm = System.getSecurityManager();\n      if (sm != null) {\n          NetPermission requestPermission = new NetPermission(\"requestPasswordAuthentication\");\n          sm.checkPermission(requestPermission);\n      }\n      CIMAuthenticator auth = theAuthenticator;\n      auth.reset();\n      auth.requestingSite = addr;\n      auth.requestingProtocol = protocol;\n      auth.requestingPrompt = prompt;\n      auth.requestingScheme = scheme;\n      return auth.getPasswordAuthentication();\n  }\n  ```",
					"badExample": "public PasswordAuthentication requestPasswordAuthentication(InetAddress addr, String protocol, String prompt, String scheme) {\n    SecurityManager sm = System.getSecurityManager();\n    if (sm != null) {\n        NetPermission requestPermission = new NetPermission(\"requestPasswordAuthentication\");\n        sm.checkPermission(requestPermission);\n    }\n    CIMAuthenticator auth = theAuthenticator;\n    auth.reset();\n    auth.requestingSite = addr;\n    auth.requestingProtocol = protocol;\n    auth.requestingPrompt = prompt;\n    auth.requestingScheme = scheme;\n    return auth.getPasswordAuthentication();\n}&lt;/pre&gt;",
					"recommend": "请确保所有执行安全操作的方法都已在 final 类中声明，或者这些方法本身已声明为最终。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.ERR.08 不要使用return、break、continue或抛出异常使finally块非正常结束——在finally块中使用return语句",
					"language": "java",
					"id": "51c060740fef11ed8fef84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "不要使用return、break、continue或抛出异常使finally块非正常结束。在finally代码块中，直接使用return、break、continue、throw语句，或由于调用方法的异常未处理， 会导致finally代码块无法正常结束。非正常结束的finally代码块会影响try或catch代码块中异常的抛出， 也可能会影响方法的返回值。所以要保证finally代码块正常结束。&lt;/pre&gt;",
					"systemTag": "codemars",
					"goodExample": "public static void main(String[] args) {\n    try {\n        System.out.println(func());\n    } catch (MyException ex) {\n        // 处理异常\n    }\n}\npublic static int func() throws MyException {\n    for (int i = 1; i &lt; 2; i++) {\n        try {\n            throw new MyException();\n        } finally {\n            // ...\n        }\n    }\n    return 0;\n}&lt;/pre&gt;",
					"badExample": "public static void main(String[] args) {\n    try {\n        System.out.println(func());\n    } catch (MyException ex) {\n        // 处理异常\n    }\n}\npublic static int func() throws MyException {\n    for (int i = 1; i &lt; 2; i++) {\n        try {\n            throw new MyException();\n        } finally {\n            return -1; // 不推荐\n        }\n    }\n    return 0;\n}&lt;/pre&gt;",
					"recommend": "return语句不要出现在finally块中。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.ERR.08 不要使用return、break、continue或抛出异常使finally块非正常结束——在finally块中使用throw语句",
					"language": "java",
					"id": "51c060760fef11edb5c584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "在finally块中抛出异常。\n\n在finally代码块中，直接使用return、break、continue、throw语句，或由于调用方法的异常未处理，会导致finally代码块无法正常结束。非正常结束的finally代码块会影响try或catch代码块中异常的抛出，也可能会影响方法的返回值。所以要保证finally代码块正常结束。\n",
					"systemTag": "codemars",
					"goodExample": "public static void main(String[] args) {\n    try {\n        System.out.println(func());\n    } catch (MyException ex) {\n        // 处理异常\n    }\n}\npublic static int func() throws MyException {\n    for (int i = 1; i &lt; 2; i++) {\n        try {\n            throw new MyException(\"try\");\n        } finally {\n            // ...\n        }\n    }\n    return 0;\n}&lt;/pre&gt;",
					"badExample": "public static void main(String[] args) {\n    try {\n        System.out.println(func());\n    } catch (MyException ex) {\n        // 处理异常\n    }\n}\npublic static int func() throws MyException {\n    for (int i = 1; i &lt; 2; i++) {\n        try {\n            throw new MyException(\"try\");\n        } finally {\n            throw new MyException(\"finally\"); // 不推荐\n        }\n    }\n    return 0;\n}&lt;/pre&gt;",
					"recommend": "throw语句不要出现在finally块中。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "Improper_SSL_setHostnameVerifier()",
					"language": "java",
					"id": "51c060780fef11edabbf84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "当进行 SSL 连接时，主机名验证功能被禁用。&lt;/pre&gt;",
					"systemTag": "codemars",
					"goodExample": "private void test01Good() {\n    DefaultHttpClient client = new DefaultHttpClient();\n    try {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        // 验证私有密钥\n        SSLSocketFactory sf = new SSLSocketFactory(ks);\n        sf.setHostnameVerifier(new StrictHostnameVerifier());\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        client.getConnectionManager().shutdown();\n    }\n}&lt;/pre&gt;",
					"badExample": "private void test01Bad() {\n    DefaultHttpClient client = new DefaultHttpClient();\n    try {\n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n        // 验证私有密钥\n        SSLSocketFactory sf = new SSLSocketFactory(ks);\n        /* POTENTIAL FLAW: 采用 SSL 连接时，使用 AllowAllHostnameVerifier() 或 SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER 会完全关闭主机名验证功能。这相当于信任所有证书。 */\n        sf.setHostnameVerifier(new AllowAllHostnameVerifier());\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        client.getConnectionManager().shutdown();\n    }\n}&lt;/pre&gt;",
					"recommend": "不要放弃SSL的验证检查。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.ERR.09 不要调用System.exit()终止JVM",
					"language": "java",
					"id": "51c0607a0fef11ed8d0184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "不要调用System.exit()终止JVM。\nSystem.exit()会结束当前正在运行的Java虚拟机（JVM），导致拒绝服务攻击。例如，在某个web请求的处理逻辑中调用System.exit()，会导致web容器停止运行。系统中应避免无意和恶意地调用System.exit()。",
					"systemTag": "codemars",
					"goodExample": "main()方法正常退出，结束进程。\npublic static void main(String[] args) {\n    LOGGER.info(\"exit\");\n}",
					"badExample": "使用 System.exit()来强制关闭JVM并终止运行中的进程。\npublic static void main(String[] args) {\n    /* POTENTIAL FLAW: 强制关闭JVM并终止运行中的进程 */\n    System.exit(1);\n    LOGGER.info(\"exit\");\n}",
					"recommend": "不要调用System.exit()终止JVM。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.EXP.06 代码中不应使用断言（assert）",
					"language": "java",
					"id": "51c0607c0fef11edb58584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "使用assert不当。\n\n默认情况下，断言（assert）是被禁用的，可以通过-ea或-da选项开启或关闭。断言（assert）的判断条件为false时会抛出 AssertionError ，表示程序遇到了一个不可恢复的错误，对该错误不做处理会导致程序异常退出。断言（assert）只适用于开发调试阶段的问题定位。以下两种场景不应使用断言：\n\n1 运行态错误检查：如下常见的运行态错误检查，不应使用断言（assert），否则可能因为运行态错误触发 AssertionError 导致程序异常终止或因为断言（assert）禁用而导致错误未处理。\n   \n1. 无效的用户输入（如环境变量、命令行参数等）\n    \n2. IO错误（如文件操作、网络通信等）\n    \n3. 权限不足（如文件权限、用户权限等）\n    \n4. Java虚拟机运行时错误（如堆栈溢出等）\n\n5. 系统资源耗尽（如文件句柄数不足等）；",
					"systemTag": "codemars",
					"goodExample": "不应使用断言。&lt;/pre&gt;",
					"badExample": "public void doSomething(List list, Object element) {\n    assert list.remove(element) : \" Failed to remove the element: \" + element;\n    // ...\n}&lt;/pre&gt;",
					"recommend": "不应使用断言。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "Avoid_printStackTrace()",
					"language": "java",
					"id": "51c0607e0fef11edb13484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "避免使用printStackTrace()输出异常信息。当系统数据或调试信息通过输出流或者日志功能流出程序时，就会发生信息泄漏。&lt;/pre&gt;",
					"systemTag": "codemars",
					"goodExample": "public void doSomeThing() {\n    try {\n        int a = 5 / 0;\n    } catch (Exception e) {\n        LOG.info(e.getMessage());\n    }\n}&lt;/pre&gt;",
					"badExample": "public void doSomeThing() {\n    try {\n        int a = 5 / 0;\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}&lt;/pre&gt;",
					"recommend": "不要调用printStackTrace方法。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.FIO.02 从ZipInputStream中解压文件必须进行安全检查",
					"language": "java",
					"id": "51c060800fef11ed960c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "使用ZipEntry.getSize()进行解压尺寸大小的检查。\n使用java.util.zip.ZipInputStream 解压zip文件时，可能会有两类安全风险：\n1. 将文件解压到目标目录之外\n压缩包中的文件名中如果包含.. ，可能导致文件被解压到目标目录之外，造成任意文件注入、文件恶意篡改等风险。因此，压缩包中的文件在解压前，要先对解压的目标路径进行校验，如果解压目标路径不在预期目录之内，要么拒绝将其解压出来，要么将其解压到一个安全的位置。\n2. 解压的文件消耗过多的系统资源\nzip压缩算法可能有很大的压缩比，可以把超大文件压缩成很小的zip文件（例如可以将上G的文件压缩为几K大小），这样的文件解压可能会导致zip炸弹（zip bomb）攻击。所以zip文件解压时，要对解压的实际文件大小进行检查，若解压之后的文件大小超过一定的限制，必须拒绝解压。具体的大小限制根据实际情况来确定。除此之外，解压时，还需要对解压出来的文件数量进行限制，防止zip压缩包中是数量巨大的小文件。&lt;/pre&gt;",
					"systemTag": "codemars",
					"goodExample": "使用累加每次解压尺寸的大小进行最终解压尺寸的判断。\npublic final void unzip_compilant(String fileName, String destDir) throws java.io.IOException {\n        FileInputStream fis = new FileInputStream(fileName);\n        ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n        ZipEntry entry;\n        int total = 0;\n        int entries = 0;\n        try {\n            while ((entry = zis.getNextEntry()) != null) {\n                BufferedOutputStream dest = null;\n                int count;\n                byte data[] = new byte[BUFFER];\n                // Write the files to the disk, but ensure that the entryName is valid,and that the file is not insanely big\n                String name = sanitizeFileName(entry.getName(), destDir);\n                // process file\n                FileOutputStream fos = new FileOutputStream(name);\n                dest = new BufferedOutputStream(fos, BUFFER);\n                // check every entry's size\n                while ((count = zis.read(data, 0, BUFFER)) != -1) {\n                    total += count;\n                    if (total &gt; TOOBIG) {\n                        break;\n                    }\n                    dest.write(data, 0, count);\n                }\n                entries++;\n                // if the total number of entry is larger than the max number,it will throw exception.\n                if (entries &gt; TOOMANY) {\n                    //handle exception\n                }\n                // if the total size of zip file is bigger than the max size value,it will throw exception.\n                if (total &gt; TOOBIG) {\n                    //handle exception\n                }\n                // …\n            }\n        } finally {\n            zis.close();\n        }\n    }&lt;/pre&gt;",
					"badExample": "直接调用ZipEntry的getSize方法进行判断。\n    public final void zipEntryBad(String filename) throws java.io.IOException {\n        FileInputStream fis = new FileInputStream(filename);\n        ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n        ZipEntry entry;\n        try {\n            while ((entry = zis.getNextEntry()) != null) {\n                System.out.println(\"Extracting: \" + entry);\n                int count;\n                byte data[] = new byte[BUFFER];\n                // Write the files to the disk, but only if the file is not\n                // insanely big\n                /* 使用ZipEntry.getSize()来做文件大小的判断。 */\n                int a = (int) entry.getSize();\n                if (a &gt; TOOBIG) {\n                    throw new IllegalStateException(\"File to be unzipped is huge.\");\n                }\n                FileOutputStream fos = new FileOutputStream(entry.getName());\n                BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) {\n                    dest.write(data, 0, count);\n                }\n                dest.flush();\n                dest.close();\n                zis.closeEntry();\n            }\n        } finally {\n            zis.close();\n        }\n    }&lt;/pre&gt;",
					"recommend": "禁止通过ZipEntry.getSize()进行解压尺寸判断。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.DCL.05 禁止将mutable对象定义为常量",
					"language": "java",
					"id": "51c060820fef11ed916584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "使用assert断言语是对代码进行诊断测试的方便机制。当使用有副作用的断言表达式时，assert语句的行为取决于运行时属性的状态，启用时，assert语句会计算表达式的值，如果值为false时抛出AssertionError异常；禁用时，assert语句不执行",
					"systemTag": "fixbotengine-java",
					"goodExample": "// 使用Collections.unmodifiableList()以保证EMPTY_RESULT_LIST不可变\npublic static final List&lt;String&gt; EMPTY_RESULT_LIST =\n    Collections.unmodifiableList(new ArrayList&lt;&gt;());\n// 更自然的写法：Collections.emptyList()\npublic static final List&lt;String&gt; EMPTY_RESULT_LIST = Collections.emptyList();",
					"badExample": "public static final List&lt;String&gt; EMPTY_RESULT_LIST = new ArrayList&lt;&gt;();\npublic static final List&lt;String&gt; RESULT_LIST = Arrays.asList(\"result1\", \"result2\");",
					"recommend": "使用immutable对象",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.OBJ.02 不要在父类的构造方法中调用可能被子类覆写的方法",
					"language": "java",
					"id": "51c060840fef11edb1b784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "如果构造函数调用了可覆盖的函数，则在该对象完全初始化之前，攻击者将可以访问  引用，进而导致出现漏洞。",
					"systemTag": "fixbotengine-java",
					"goodExample": "package CodeCorrectness.ConstructorInvokesOverridableFunction;\n\nimport org.springframework.util.StringUtils;\n\n\npublic class CodeCorrectness_ConstructorInvokesOverridableFunction_Internal_PublicMethod_01 {\n\n    private String username;\n    private boolean valid;\n\n    public CodeCorrectness_ConstructorInvokesOverridableFunction_Internal_PublicMethod_01(String username, String password){\n        this.username = username;\n    }\n\n    public boolean validateUser(String username, String password) {\n        if(!StringUtils.isEmpty(username) && !StringUtils.isEmpty(password)){\n            return true;\n        }\n        return false;\n    }\n}",
					"badExample": "package CodeCorrectness.ConstructorInvokesOverridableFunction;\n\nimport org.springframework.util.StringUtils;\n\npublic class CodeCorrectness_ConstructorInvokesOverridableFunction_Internal_PublicMethod_01 {\n\n    private String username;\n    private boolean valid;\n\n    public CodeCorrectness_ConstructorInvokesOverridableFunction_Internal_PublicMethod_01(String username, String password){\n        this.username = username;\n        /* POTENTIAL FLAW:  类的构造函数调用了可被覆盖的函数。 */\n        this.valid = validateUser(username,password);\n    }\n\n    public boolean validateUser(String username, String password) {\n        if(!StringUtils.isEmpty(username) && !StringUtils.isEmpty(password)){\n            return true;\n        }\n        return false;\n    }\n}",
					"recommend": "构造函数不应调用可覆盖的函数，无论是通过将该函数指定为 `final`，还是将该类指定为 `final` 的方式。或者，如果此代码仅在构造函数中才需要，则可使用访问说明符 `private`，或直接将逻辑放在子类的构造函数中。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CON.10 线程中断由业务代码来协作完成，慎用Thread.interrupt方法",
					"language": "java",
					"id": "51c087810fef11ed9cdb84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "优先使用协作式的线程同步机制，如java.util.concurrent包中的各种synchronizer，加锁的共享变量、volatile共享变量等，来通知一个线程中止作业。",
					"systemTag": "fixbotengine-java",
					"goodExample": "轮询状态，满足退出条件时结束线程。\nclass Job implements Runnable {\n    boolean shouldStop() {\n        ...\n    }\n\n    @Override\n    public void run() {\n        while (!shouldStop()) {\n            doWork();\n        }\n    }\n}",
					"badExample": "使用非volatile变量进行通信，存在data race。将hasStopRequested改为volatile即可修正。\nclass Job implements Runnable {\n    private boolean hasStopRequested; // 不是volatile，不能作为通信变量使用\n    // private volatile boolean hasStopRequested; // 改为volatile即可修正问题\n\n    public void requestStop() {\n        hasStopRequested = true;\n    }\n\n    @Override\n    public void run() {\n        // hasStopRequested非volatile读，无happens-before关系。有可能每次都读到初值false\n        while (!hasStopRequested) {\n            doWork();\n        }\n    }\n}",
					"recommend": "",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.SEC.04 使用安全管理器来保护敏感操作",
					"language": "java",
					"id": "51c087830fef11ed8c4684a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "敏感操作缺少安全管理器。\n所有的敏感操作必须经过安全管理器的检查，防止被不可信的代码调用。对于Java API 中的敏感操作，例如文件操作、向远程主机开放套接字连接以及创建ClassLoader 等，在源码中已经添加了安全检查的代码逻辑，开发者只需要安装安全管理器即可；对于应用本身的敏感操作，除了安装安全管理器之外，还需要自定义安全策略，并在合适的位置添加安全检查的代码。&lt;/pre&gt;",
					"systemTag": "codemars",
					"goodExample": "新增 securityCheck()方法来保护resourceMap防止不可信代码调用removeEntry() 方法。\npublic final class SecureSensitiveMap {\n    private static final SensitiveResourcePermission REMOVE_ENTRY_PERMISSION = \n        new SensitiveResourcePermission(\"removeEntry\");\n    private final Map&lt;Integer,String&gt; resourceMap = new HashMap&lt;&gt;();\n    public void removeEntry(Integer key) {\n        this.securityCheck();\n        resourceMap.remove(key);\n    }\n\n    private void securityCheck(){\n        SecurityManager securityManager = System.getSecurityManager();\n        if (securityManager != null) {\n            securityManager.checkPermission(REMOVE_ENTRY_PERMISSION);\n        }\n    }\n}&lt;/pre&gt;",
					"badExample": "resourceMap包含敏感信息，然而removeEntry()方法是public的并且没有被安全管 理器检查，因此恶意调用者可以通过该方法随意删除敏感信息\npublic final class SensitiveMap {\n    private final Map&lt;Integer,String&gt; resourceMap = new HashMap&lt;&gt;;\n    public void removeEntry(Integer key) {\n        resourceMap.remove(key);\n    }\n}&lt;/pre&gt;",
					"recommend": "所有的敏感操作必须经过安全管理器的检查，防止被不可信的代码调用。&lt;/pre&gt;",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "G.EXP.04 表达式的比较，应该遵循左侧倾向于变化、右侧倾向于不变的原则——使用equals方法进行字符串比较",
					"language": "java",
					"id": "51c087850fef11edad4684a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "使用equals比较字符串。当比较字符串常量和变量时，常量应当位于变量的左侧",
					"systemTag": "fixbotengine-java",
					"goodExample": "public class StringComparisonTest {\n    private static final String STRING_CONSTANT = \"hello\";\n    private static String stringVariable = \"world\";\n\n    public void stringTest() {\n        String localVariable = \"yes\";\n\n        System.out.println(\"world\".equals(stringVariable));\n        System.out.println(STRING_CONSTANT.equals(stringVariable));\n        System.out.println(localVariable.equals(stringVariable));\n    }\n}",
					"badExample": "public class StringComparisonTest {\n    private static final String STRING_CONSTANT = \"hello\";\n    private static String stringVariable = \"world\";\n\n    public void stringTest() {\n        String localVariable = \"yes\";\n        System.out.println(localVariable == STRING_CONSTANT);\n        System.out.println(stringVariable != localVariable);\n        System.out.println(stringVariable == STRING_CONSTANT);\n        System.out.println(stringVariable.equals(\"world\"));\n  System.out.println(stringVariable.equals(STRING_CONSTANT));\n    }\n}",
					"recommend": "正确使用equals比较字符串",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "P.05 外部数据使用前必须进行合法性校验——代码注入场景",
					"language": "java",
					"id": "51c087870fef11ed893584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "Eval注入。\n\n当前程序执行不可信的代码，就会产生code injection问题，比如对当前的用户对象进行计算或修改用户的状态。",
					"systemTag": "secbrella",
					"goodExample": "",
					"badExample": "不可信数据未经校验就被执行。\nString data = req.getParameter(\"input\");\nScriptEngineManager manager = new ScriptEngineManager();\nScriptEngine engine = manager.getEngineByName(\"javascript\");\ntry {\n    Object res = engine.eval(data);\n} catch (ScriptException e) {\n    IO.writeLine(e.getMessage());\n}",
					"recommend": "使用白名单的方式对外部数据进行校验。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EDV.03 禁止直接向 Runtime.exec() 方法或 java.lang.ProcessBuilder 类传递外部数据",
					"language": "java",
					"id": "51c087890fef11eda2c784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "命令注入。\nRuntime.exec()方法或java.lang.ProcessBuilder类被用来启动一个新的进程，在新进程中执行命令。命令执行通常会有两种方式：\n直接执行具体命令：例如Runtime.getRuntime().exec(\"ping 127.0.0.1\")；\n通过shell方式执行命令：windows下使用cmd.exe、linux下通过sh方式执行命令，或通过脚本文件（.bat/.sh）执行命令。\n直接使用外部数据构造命令行，会存在以下风险：shell方式执行命令时，需要命令行解释器对命令字符串进行拆分，该方式可执行多条命令，存在命令注入风险；直接执行具体的命令时，可以通过空格、双引号或以 -/ 开头的字符串向命令行中注入参数，存在参数注入风险。",
					"systemTag": "secbrella",
					"goodExample": "如下示例中，外部数据在拼接shell命令行前，先对其中的特殊字符进行了转义处理，可有效消减命令注入风险。\nString encodePath = HWEncoder.encodeForOS(new WindowsCodec(), path);\nString cmd = \"cmd.exe /c dir \" + encodePath;\nRuntime rt = Runtime.getRuntime();\nProcess proc = rt.exec(cmd);\n…",
					"badExample": "如下示例中，使用外部数据构造shell方式的命令，存在命令注入风险。例如，当path的值为\"D:\\test&notepad.exe\"，实际会执行两个命令：\"dir D:\\test\"和\"notepad.exe\"。\nString cmd = \"cmd.exe /c dir \" + path;\nRuntime rt = Runtime.getRuntime();\nProcess proc = rt.exec(cmd);\n…",
					"recommend": "针对命令注入或参数注入，具体的解决方案如下：\n1） 对于Java的标准库或开源组件已经提供的功能，应使用标准库或开源组件的API，避免执行命令。\n2） 外部数据用于拼接命令行时，可使用白名单方式对外部数据进行校验，保证外部数据中不含注入风险的 特殊字符。\n3） 在执行命令行时，如果输入校验不能禁止有风险的特殊字符，需先外部输入进行转义处理，转义后的字 段拼接命令行可有效防止命令注入的产生。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "P.05 外部数据使用前必须进行合法性校验——跨站脚本场景",
					"language": "java",
					"id": "51c0878b0fef11ed916f84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "跨站脚本攻击。当应用程序收到含有不可信的数据，在没有进行适当的校验和转义的情况下就将它发送给Web浏览器，这就会产生跨站脚本攻击（简称XSS）。XSS允许攻击者在受害者的浏览 器上执行脚本，从而劫持用户会话、危害网站、或者将用户转向恶意网站。",
					"systemTag": "secbrella",
					"goodExample": " 如下示例中，OWASP开源组件esapi就提供了XSS防护的编码API。\n@Override\npublic void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    String safe = ESAPI.encoder().encodeForHTML(request.getParameter(\"xss\"));\n    Object[] obj = { \"a\", \"b\" };\n    response.getWriter().format(safe, obj);\n}",
					"badExample": "如下示例中，将不可信的外部参数直接通过response传递到web浏览器。\n@Override\npublic void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    String param = request.getParameter(\"xss\");\n    Object[] obj = { \"a\", \"b\" };\n    response.getWriter().format(param, obj);\n}",
					"recommend": "1) 对于Java的标准库或开源组件已经提供的功能,应使用标准库或开源组件的API,避免产生XSS注入问题\n2) 使用白名单的方式对外部数据进行校验",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "P.03 使用相同的顺序请求和释放锁来避免死锁",
					"language": "java",
					"id": "51c0878d0fef11ed80cf84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "当程序涉及到使用多个锁对资源进行同步时，编码过程中，要仔细考虑锁的顺序，尽量以相同的顺序来请求和释放锁，避免发生死锁。不能为了避免死锁的发生，扩大锁的使用范围，影响系统性能。",
					"systemTag": "secbrella",
					"goodExample": " 相同的顺序获取两个锁。\npublic class Foo {\n    private final Object lockA = new Object();\n    private final Object lockB = new Object();\n    public void doSomething01() {\n        synchronized (lockA) {\n            synchronized (lockB) {\n                // do something with both resources\n            }\n        }\n    }\n    public void doSomething02() {\n        synchronized (lockA) {\n            synchronized (lockB) {\n                // do something with both resources\n            }\n        }\n    }\n}",
					"badExample": "不同顺序获取两个锁。\npublic class Foo {\n    private final Object lockA = new Object();\n    private final Object lockB = new Object();\n    public void doSomething01() {\n        synchronized (lockA) {\n            synchronized (lockB) {\n                // do something with both resources\n            }\n        }\n    }\n    public void doSomething02() {\n        synchronized (lockB) {\n            synchronized (lockA) {\n                // do something with both resources\n            }\n        }\n    }\n}",
					"recommend": "两个不同的线程需要以相同的顺序获取两个锁。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "P.05 外部数据使用前必须进行合法性校验——序列化场景",
					"language": "java",
					"id": "51c0878f0fef11ed812284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "直接将外部数据进行反序列化。当不可信的数据被用于反序列化时，就会产生反序列化漏洞。反序列化漏洞允许攻击者绕过安全检查或执行任意代码。",
					"systemTag": "secbrella",
					"goodExample": "",
					"badExample": " 如下示例中，方法将 HTTP 请求输入数据流传递给了属于反序列化 API 的 ObjectInputStream 构造函数，攻击者可以在 HTTP 请求中提供任意对象实例。\npublic void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException{\n    ... \n    Foo foo = null;\n    try (ServletInputStream sis = request.getInputStream();\n        ObjectInputStream ois = new ObjectInputStream(sis)) {\n        foo = (Foo)ois.readObject();\n    } catch (ClassNotFoundException e) {\n        LOGGER.error(\"read object failed\", e.getMessage())\n    }\n    ...\n}",
					"recommend": "使用白名单的方式对外部数据进行校验。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.TYP.02 确保除法运算和模运算中的除数不为0",
					"language": "java",
					"id": "51c087910fef11eda42184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "除零错误。如果除法或模运算中的除数为零可能会导致程序终止或拒绝服务（DoS），因此需要在运算前保证除数不为0。",
					"systemTag": "secbrella",
					"goodExample": "如下示例中，对除数进行非零判断，然后再进行除法或取余运算。\nlong dividendNum = 0;\nlong divisorNum = 0;\nif (divisorNum != 0) {\n    long result1 = dividendNum / divisorNum;\n    long result2 = dividendNum % divisorNum;\n}",
					"badExample": "如下示例中，没有对除数进行非零判断，会导致程序运行错误。\nlong dividendNum = 0;\nlong divisorNum = 0;\n/* POTENTIAL FLAW: 使用除法运算或模运算没有判断除数大小。 */\nlong result1 = dividendNum / divisorNum;\n/* POTENTIAL FLAW: 使用除法运算或模运算没有判断除数大小。 */\nlong result2 = dividendNum % divisorNum;",
					"recommend": "对除数进行非零判断，然后再进行除法或取余运算。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "P.05 外部数据使用前必须进行合法性校验——Header Manipulation场景",
					"language": "java",
					"id": "51c087930fef11eda55a84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "HTTP header操纵。\n\n攻击者或许能够设置重要的HTTP Header，并禁用安全保护或固定会话ID。缺陷的严重性取决于可以操纵的头文件以及攻击者是否能够直接或间接地控制头文件值。\n当在HTTP头文件名称中使用不受控制的动态数据时，就会产生此类漏洞。此安全漏洞可能允许攻击者设置或重写重要的头文件值。",
					"systemTag": "secbrella",
					"goodExample": "",
					"badExample": "直接将不可信数据放入Header中。\nvoid foo(HttpServletRequest request, HttpServletResponse response) {\n    Socket socket = new Socket(\"host.example.org\", 39544);\n    try(InputStreamReader readerInputStream = new InputStreamReader(socket.getInputStream(), \"UTF-8\");\n        BufferedReader readerBuffered = new BufferedReader(readerInputStream)){\n        String data = readerBuffered.readLine();\n\n        response.addHeader(\"header\", data);\n    }   \n}",
					"recommend": "使用白名单的方式对外部数据进行校验。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CON.04 避免使用不正确形式的双重检查锁",
					"language": "java",
					"id": "51c0aeb50fef11edae2d84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "不正确的使用双重检查锁。\n\n双重检查锁（double-checked locking）是一种软件设计模式，通常用于延迟初始化单例。主要通过在进行获取锁之前先检查单例对象是否创建（第一次检查），在获取锁以后，再次检查对象是否创建（第二次检查），以此减少并发获取锁的开销。\n但是不正确的使用双重检查锁，存在延迟初始化的Java优化问题隐患。也就是会导致一个线程发布一个未初始化或部分初始化的对象给另外的线程使用。",
					"systemTag": "secbrella",
					"goodExample": "把 instance 声明为 volatile ，当一个线程初始化 Singleton 对象时，会在这个线程和其他任何获取该实例的线程之间建立起happens-before关系。避免使用到未初始化完全的对象引用。\n\nfinal class Singleton {\n    private static volatile Singleton instance = null;\n\n    private static final Object LOCK = new Object();\n\n    private Singleton() {\n        // ...\n    }\n\n    public static Singleton getSingletonInstance() {\n        if (instance == null) {\n            synchronized (LOCK) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}",
					"badExample": "当一个线程完成对成员属性 instance 的赋值时，并未完成对象的完全初始化，也就是说此时另外一个并发线程调用 getSingletonInstance() 会得到一个指向 Singleton 对象的非空引用，然而该对象的数据成员可能是默认值，而不是构造方法中设置的值。\n\nfinal class Singleton {\n    private static Singleton instance = null;\n\n    private static final Object LOCK = new Object();\n\n    private Singleton() {\n        // ...\n    }\n\n    public static Singleton getSingletonInstance() {\n        if (instance == null) {\n            synchronized (LOCK) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}",
					"recommend": "把 instance 声明为 volatile，当一个线程初始化 Singleton 对象时，会在这个线程和其他任何获取该实例的线程之间建立起happens-before关系。避免使用到未初始化完全的对象引用。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.TYP.01 进行数值运算时，避免整数溢出",
					"language": "java",
					"id": "51c0aeb70fef11edb3e384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "进行数值运算时，避免整数溢出。\n\n在进行数值运算过程中，确保运算结果在特定的整数类型的数据范围内，避免溢出，导致非预期的结果。 \n\n内置的整数运算符不会以任何方式来标识运算结果的上溢或下溢。常见的加、减、乘、除都可能会导致整数溢出。另外，Java数据类型的合法取值范围是不对称的（最小值的绝对值比最大值大1），所以对最小值取绝对值（ java.lang.Math.abs() ）时，也会导致溢出。",
					"systemTag": "secbrella",
					"goodExample": "如下示例中，当无法预判乘积结果是否会产生溢出时，使用了Java 8新增的 Math.multiplyExact() 方 法，该方法在乘积运算不产生溢出时会返回运算结果，溢出时抛出 ArithmeticException。\npublic static int multNum(int num1, int num2) {\n return Math.multiplyExact(num1, num2);\n}\n",
					"badExample": "如下示例中，当num1和num2的绝对值较大，两者的乘积大于 Integer.MAX_VALUE 或小于 Integer.MIN_VALUE 时，方法就无法返回正确的计算结果（产生溢出）。\npublic static int multNum(int num1, int num2) {\n return num1 * num2;\n}\n",
					"recommend": "对于整数溢出问题，可以通过先决条件检测、使用Math类的安全方法、向上类型转换或者使用`BigInteger`等方法进行规避。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "P.05 外部数据使用前必须进行合法性校验——LDAP注入场景",
					"language": "java",
					"id": "51c0aeb90fef11ed9d5984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "LDAP注入。当不受控制的数据被传递给LDAP查询时，就会产生此类漏洞。注入被污染的数据可能会更改查询的目的，这可能会绕过安全检查或泄露未经授权的数据。",
					"systemTag": "secbrella",
					"goodExample": "",
					"badExample": "在下面的示例中，不可信参数 `username` 直接拼接LDAP查询。\npublic boolean isValidUser(String username) {\n    ...\n    String searchFilter = \"(CN=\" + userName + \")\";\n    DirContext ctx = getContext();\n    NamingEnumeration answer = ctx.search(baseDN, searchFilter, ctls);\n    ...\n}\n",
					"recommend": "使用白名单的方式对外部数据进行校验。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.LOG.05 禁止直接使用外部数据记录日志",
					"language": "java",
					"id": "51c0aebb0fef11eda36284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "日志注入。直接将外部数据记录到日志中，可能存在以下风险： \n1） 日志注入：恶意用户可利用回车、换行等字符注入一条完整的日志； \n2） 敏感信息泄露：当用户输入敏感信息时，直接记录到日志中可能会导致敏感信息泄露；\n3） 垃圾日志或日志覆盖：当用户输入的是很长的字符串，直接记录到日志中可能会导致产生大量垃圾 日志；当日志被循环覆盖时，这样还可能会导致有效日志被恶意覆盖。",
					"systemTag": "secbrella",
					"goodExample": "外部数据记录到日志中前，将其中的\\r\\n等导致换行的字符进行替换，消除注入风险。上述示例为其中一种实现方式。\n\npublic String replaceCRLF(String message) {\nif (message == null) {\n      return \"\";\n}\nreturn message.replace('\\n', '_').replace('\\r', '_');\n}",
					"badExample": "如下示例中，当请求的json数据校验失败，会直接将json字符串记录到日志中，当json字符串中含有敏 感信息，会导致敏感信息泄露的风险，当恶意用户向json字符串中通过回车换行符注入伪造的日志会造成日志注入问题，当json字符串比较长时，会导致日志冗余。\nString jsonData = getRequestBodyData(request);\nif (!validateRequestData(jsonData)) {\n    LOG.error(\"Request data validate fail! Request Data : \" + jsonData);\n}",
					"recommend": "外部数据应尽量避免直接记录到日志中，如果必须要记录到日志中，要进行必要的校验及过滤处 理，对于较长字符串可以截断。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.ERR.06 在catch块中抛出新异常时，避免丢失原始异常信息",
					"language": "java",
					"id": "51c0aebd0fef11ed8a1384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "丢失原始异常信息。在catch代码块中更改异常类型时，如果只是使用原始异常中的 message（ originalException.getMessage() ）或新的错误描述构造新异常，可能会导致原始异常 中的有价值的信息丢失，例如异常类型、调用堆栈等信息，增加问题定位的难度。",
					"systemTag": "secbrella",
					"goodExample": "如下示例中，在捕获 IOException 后，首先将 IOException 记录到日志中，然后抛出一个新的与业务代码相对应的异常。\npublic void loadConfigFile() throws MyBizDomainException {\n    ...\n    try {\n        ...\n    } catch (IOException ex) {\n        // 将原始异常记录到日志中，然后抛出新的异常\n        log.warn(ex);\n        throw new MyBizDomainException(\"my exception message\");\n    }\n}\n",
					"badExample": "如下示例中，在捕获 IOException 后，直接抛出了一个 MyBizDomainException，这样会导致原始的 IOException 信息丢失。\npublic void loadConfigFile() throws MyBizDomainException {\n ...\n    try {\n        ...\n    } catch (IOException ex) {\n        throw new MyBizDomainException(\"Lost original exception message\");\n    }\n}\n",
					"recommend": "1) 抛出的新异常包含原始异常信息\n2) 抛出新异常之前已经用日志记录了原始异常未显式地处理异常",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EXP.05 禁止直接使用可能为null的对象，防止出现空指针引用",
					"language": "java",
					"id": "51c0aebf0fef11ed903684a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "访问一个为null的对象时，会导致空引用问题，代码中抛出NullPointerException。该类问题应该通过预检查的方式进行消解，而不是通过try...catch机制处理NullPointerException。",
					"systemTag": "secbrella",
					"goodExample": "如下示例中，对 System.getenv() 返回值先判空再使用，消除了空指针引用问题。\nString env = System.getenv(SOME_ENV);\nif (env != null && env.length() &gt; MAX_LENGTH) {\n    ...\n}",
					"badExample": "如下示例中，System.getenv() 返回值可能为null，代码中在使用变量 env 前未判空，会发生空指针引用。\nString env = System.getenv(SOME_ENV);\nif (env.length() &gt; MAX_LENGTH) {\n    ...\n}\n",
					"recommend": "对为Null的对象进行判空处理。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "P.05 外部数据使用前必须进行合法性校验——OGNL注入场景",
					"language": "java",
					"id": "51c0aec10fef11ed9ee284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "OGNL注入。\n禁止外部数据直接拼接(OGNL)语句以执行任意代码。对象图导航语言(OGNL)是一种针对Java的开源表达式语言(EL)，它允许在由开发者提供的环境中计算并执行EL表达式。允许在任何环境下计算未验证的表达式将允许攻击者执行任意代码。",
					"systemTag": "secbrella",
					"goodExample": "正确示例：\n\n通过安全框架中的API或者业界开源组件ESAPI中的API进行转义。\n\nvoid foo(HttpServletRequest request, HttpServletResponse response) {\n    String data = request.getCookies()[0].getValue();\n    OgnlContext ctx = new OgnlContext();\n\n    Object expr = null;\n    try {\n        data = HWEncoder.encodeForOS(new WindowsCodec(), data);\n        expr = Ognl.parseExpression(data);\n        Object value = Ognl.getValue(expr, ctx, \"xxx\");\n    } catch (OgnlException e) {\n        IO.writeLine(e.getMessage());\n    }\n}",
					"badExample": "不可信数据从cookie中读取，允许攻击者远程执行任意代码。\nvoid foo(HttpServletRequest request, HttpServletResponse response) {\n    String data = request.getCookies()[0].getValue();\n    OgnlContext ctx = new OgnlContext();\n    Object expr = null;\n    try {\n        expr = Ognl.parseExpression(data);\n        Object value = Ognl.getValue(expr, ctx, \"xxx\");\n    } catch (OgnlException e) {\n        IO.writeLine(e.getMessage());\n    }\n}\n",
					"recommend": "使用白名单的方式对外部数据进行校验。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "P.05 外部数据使用前必须进行合法性校验——未经验证的重定向和转发场景",
					"language": "java",
					"id": "51c0aec30fef11ed977c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "指向未可信站点的URL重定向(开放重定向)。用户控制输入被用于指定至外部站点的链接的情况。攻击者可以创建链接，指向被重定向至恶意网站的受信任网站。这可以让攻击者实施钓鱼攻击，以允许他们窃取用户凭证。",
					"systemTag": "secbrella",
					"goodExample": "正确示例： 对数据进行白名单校验，确定输入的url是合法的url。\nvoid sendRedirect(HttpServletRequest request, HttpServletResponse response) {\n    String url = request.getCookies()[0].getValue();\n    if (checkUrl(url)) {\n      return;\n  }\n    response.sendRedirect(url); \n}\npublic boolean checkUrl(String url) {\n  //TODO 使用白名单\n}",
					"badExample": "如下示例中，直接重定向至恶意网站。\nvoid sendRedirect(HttpServletRequest request, HttpServletResponse response) {\n    String url = request.getCookies()[0].getValue();\n\n    response.sendRedirect(url); \n}\n",
					"recommend": "对用户输入的URL进行合法校验，只允许使用合法的URL，从而过滤不可信URL。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.OBJ.02 不要在父类的构造方法中调用可能被子类覆写的方法",
					"language": "java",
					"id": "51c0aec50fef11edb68584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "当在父类的构造方法中调用可能被子类覆写的方法时，构造方法的表现是不可预知的，很可能会导致异常。而问题出现后，往往难以快速定位。这是由于在Java中，当子类初始化时，会调用父类的构造方法，当父类构造方法调用了被子类覆写的方法，往往会由于子类的初始化未完成而导致异常。",
					"systemTag": "secbrella",
					"goodExample": "public class SeniorClass {\n    public SeniorClass() {\n        println(); \n    }\n    \n    private void println() {\n        System.out.println(\"IAmSeniorClass\");\n    }\n}\npublic class JuniorClass extends SeniorClass {\n    private String name;\n    public JuniorClass() {\n        super(); \n        name = \"JuniorClass\";\n    }\n}",
					"badExample": "public class SeniorClass {\n    public SeniorClass() {\n        println(); // 如果toString()被覆写了，可能会导致异常\n    }\n    \n    public void println() {\n        return \"IAmSeniorClass\";\n    }\n}\npublic class JuniorClass extends SeniorClass {\n    private String name;\n    public JuniorClass() {\n        super(); // 调用父类的构造方法，导致NullPointerException异常\n        name = \"JuniorClass\";\n    }\n    \n    @Override\n    public void println() {\n        return name.toUpperCase();\n    }\n}",
					"recommend": "不要在父类的构造方法中调用可能被子类覆写的方法。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CON.05 禁止使用非线程安全的方法来覆写线程安全的方法",
					"language": "java",
					"id": "51c0aec70fef11ed9a5284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "使用非线程安全的方法来重写线程安全的方法。\n\n对于线程安全的方法，如果子类将其重写为非线程安全的方法，可能会导致不正确的同步，导致难以定位的问题产生。",
					"systemTag": "secbrella",
					"goodExample": "如下示例中，同步方法，子类和父类方法都用synchronized修饰。\nclass Base {\n    public synchronized void doSomething() {\n        ...\n    }\n}\nclass Derived extends Base {\n    @Override\n    public synchronized void doSomething() {\n        ...\n    }\n}",
					"badExample": " 如下示例中，doSomething() 在被子类覆写时，改为了非线程安全的方法。\nclass Base {\n    public synchronized void doSomething() {\n        ...\n    }\n}\nclass Derived extends Base {\n    @Override\n    public void doSomething() {\n        ...\n    }\n}",
					"recommend": "如果某个子方法的父方法声明为 synchronized，则必须将该子方法也声明为 synchronized或者用私有常量锁锁定。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "P.05 外部数据使用前必须进行合法性校验——路径篡改场景",
					"language": "java",
					"id": "51c0aec90fef11ed96cf84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "使用外部数据构造的文件路径。\n文件路径来自外部数据时，必须对其合法性进行校验，否则可能会产生路径遍历（Path Traversal）漏洞。文件路径有多种表现形式，如绝对路径、相对路径，路径中可能会含各种链接、快捷方式、影子文件等，这些都会对文件路径的校验产生影响，所以在文件路径校验前要对文件路径进行规范化处理，使用规范化的文件路径进行校验。对文件路径的规范化处理必须使用getCanonicalPath() ，禁止使用getAbsolutePath() （该方法无法保证在所有的平台上对文件路径进行正确的规范化处理）。",
					"systemTag": "secbrella",
					"goodExample": "使用外部输入的fileName构造文件路径后，先对文件路径进行规范化，然后用规范化的文件路径进行校验，满足条件后执行文件读写操作。这样可以有效避免路径遍历之类的风险。\npublic void doSomething() {\nFile file = new File(HOME_PATH, fileName);\ntry {\n   String canonicalPath = file.getCanonicalPath();\n   if (!validatePath(canonicalPath)) {\n       throw new IllegalArgumentException(\"Path Traversal vulnerability!\");\n   }\n... // 对文件进行读写等操作\n} catch (IOException ex) {\n   throw new IllegalArgumentException(\"An exception occurred ...\", ex);\n  }\n}\nprivate boolean validatePath(String path) {\n    if (path.startsWith(HOME_PATH)) {\n        return true;\n    } else {\n        return false;\n    }\n}",
					"badExample": "fileName来自外部输入，直接用fileName的值与固定路径进行拼接，作为实际访问文件的路径，在访问文件之前通过validatePath检查了拼接的路径是否在固定目录下，但是攻击者可以通过../这样的路径方式，访问HOME_PATH之外的任意文件。\npublic void doSomething() {\nFile file = new File(HOME_PATH, fileName);\nString path = file.getPath();\nif (!validatePath(path)) {\n    throw new IllegalArgumentException(\"Path Traversal vulnerabilities may exist！\");\n}\nprivate boolean validatePath(String path) {\nif (path.startsWith(HOME_PATH)) {\n    return true;\n} else {\n    return false;\n    }\n}",
					"recommend": "对外部数据进行白名单（创建一份合法资源名的列表）校验。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EDV.08 正则表达式要尽量简单,防止ReDos攻击",
					"language": "java",
					"id": "51c0d5420fef11eda9a384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "ReDos攻击是正则编写不当导致的常见安全风险。Java中的正则匹配使用的是NFA引擎。NFA引擎的回溯机制，导致当字符串文本与正则表达式不匹配时，所花费的时间要比匹配时多，即要确定匹配失败， 需要与所有可能的路径进行对比匹配，证明都不匹配时，才返回匹配失败。当使用简单的非分组正则表 达式时，一般不会存在ReDos攻击。容易存在ReDos攻击的正则表达式主要有两类：\n+包含具有自我重复的重复性分组的正则，例如：^(\\d+)+$、^(\\d*)*$、^(\\d+)*$、^(\\d+|\\s+)*$\n+包含替换的重复性分组，例如：^(\\d|\\d|\\d)+$、^(\\d|\\d?)+$\nPendingIntent是一种特殊的Intent，用来启动特定情境下触发的事件。当A应用设定一个原始Intent，并据此创建PendingIntent，然后将其传递给B应用时， B应用就持有PendingIntent，可以执行A应用预设的操作，并拥有A应用同样的权限（with the same Permission and identity）。 因此，A应用应当小心设置原始Intent，在Intent中显示指定目的Component名称的方式，可以防止被恶意应用程序劫持，造成权限泄露。",
					"systemTag": "secbrella",
					"goodExample": "  如下示例中，将正则表达式精简为a[bc]+d。与a(b|c+)+d相比，可以在实现相同功能的前提下消除ReDos风险。\n  ```java\n  private static final Pattern REGEX_PATTER = Pattern.compile(\"a[bc]+d\");\n  public static void main(String[] args) {\n      ...\n      Matcher matcher = REGEX_PATTER.matcher(args[0]);\n      if (matcher.matches()) {\n          ...\n      } else {\n          ...\n      }\n      ...\n  }",
					"badExample": "  如下示例中，正则表达式a(b|c+)+d存在ReDos风险，当匹配的字符串格式类似\"accccccccccccccccx\"时，随中间的字符\"c\"的增加，代码执行时间将成指数级增长。\n  ```java\n  private static final Pattern REGEX_PATTER = Pattern.compile(\"a(b|c+)+d\");\n  public static void main(String[] args) {\n      ...\n      Matcher matcher = REGEX_PATTER.matcher(args[0]);\n      if (matcher.matches()) {\n          ...\n      } else {\n          ...\n      }\n      ...\n  }",
					"recommend": "对于ReDos攻击的防护手段主要包括：\n+ 进行正则匹配前，先对匹配的文本的长度进行校验。\n+ 在编写正则时，尽量不要使用过于复杂的正则，尽量少用分组，例如对于正则^(([a-z])+\\.)+[AZ]([a-z])+$（存在ReDos风险），可以将多余的分组删除：^([a-z]+\\.)+[A-Z][a-z]+$，这样在不改变检查规则的前提下消除了ReDos风险。\n+ 避免动态构建正则，当使用外部数据构造正则时，要使用白名单进行严格校验。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.FIO.05 临时文件使用完毕必须及时删除",
					"language": "java",
					"id": "51c0d5440fef11edba0c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "临时文件使用完毕必须及时删除\n程序中有很多使用临时文件的场景，比如用于进程间的数据共享，缓存内存数据，动态构造的类文件，动态连接库文件等。\n临时文件可能创建于操作系统的共享临时文件目录，例如，POSIX系统下的/tmp与/var/tmp目录，Windows系统下的C:\\TEMP目录，这类目录中的文件可能会被定期清理。\n创建在其他路径下的临时文件不会被自动清理。\n如果文件未被安全地创建或者用完后还是可访问的，具备本地文件系统访问权限的恶意用户便可以利用共享目录中的文件进行恶意操作，\n另外，临时文件不清理也可能会导致大量垃圾文件占用磁盘的存储空间。",
					"systemTag": "secbrella",
					"goodExample": "如下示例中，在临时文件使用完毕后，在finally代码块中对其进行了删除处理。\npublic boolean uploadFile(InputStream in) throws IOException {\n    File tempFile = File.createTempFile(\"test\", \".tmp\");\n    try (FileOutputStream fop = new FileOutputStream(tempFile)) {\n        int readSize;\n        do {\n            readSize = in.read(buffer, 0, MAX_BUFF_SIZE);\n            if (readSize &gt; 0) {\n                fop.write(buffer, 0, readSize);\n            }\n        } while (readSize &gt;= 0);\n        ... // 对tempFile进行其他操作\n    } finally {\n        if (!tempFile.delete()) {\n            // 忽略\n        }\n    }\n}",
					"badExample": "如下示例中，在运行结束时未将临时文件删除。\npublic boolean uploadFile(InputStream in) throws IOException {\n    File tempFile = File.createTempFile(\"test\", \".tmp\");\n    try (FileOutputStream fop = new FileOutputStream(tempFile)) {\n        int readSize;\n        do {\n            readSize = in.read(buffer, 0, MAX_BUFF_SIZE);\n            if (readSize &gt; 0) {\n                fop.write(buffer, 0, readSize);\n            }\n        } while (readSize &gt;= 0);\n        ... // 对tempFile进行其他操作\n    }\n}",
					"recommend": "在临时文件使用完毕之后、系统终止之前，及时对其进行删除。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "P.05 外部数据使用前必须进行合法性校验——资源注入场景",
					"language": "java",
					"id": "51c0d5460fef11ed899784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "资源注入。使用来自上游组件的输入来标识某个资源（文件、端口号）前，没有对其进行限制或限制不正确，导致可能访问预期受控范围之外的资源。",
					"systemTag": "secbrella",
					"goodExample": "",
					"badExample": "  如下示例中，外部不可信数据未经校验直接创建URl。\n  ```java\n    public HttpURLConnection getUrlConnection(String serviceUrl,String requestMethodType) throws IOException {\n        URL url = new URL(serviceUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(requestMethodType);\n        return conn;\n    }\n  ```",
					"recommend": "使用白名单的方式对外部数据进行校验。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.PRM.07 进行IO类操作时，必须在try-with-resource或finally里关闭资源",
					"language": "java",
					"id": "51c0d5480fef11ed955484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "资源泄露。申请的资源不再使用时，需要及时释放。而在产生异常时，资源释放经常被忽视，因此对于IO、数据库 操作等需要显式调用关闭方法（如 close() ）来释放资源的场景，必须在try-catch-finally的finally中调 用关闭方法。如果有多个IO对象需要 close() ，需要分别对每个对象的 close() 方法进行try-catch， 防止一个IO对象关闭失败导致其他IO对象无法关闭，保证即使产生异常也能释放已申请的资源。 \nJava 7有自动资源管理的特性try-with-resource，不需手动关闭。该方式应该优先于try-finally，这样得 到的代码将更加简洁、清晰，产生的异常也更有价值。特别是对于多个资源关闭发生异常时，try-finally可能丢失掉前面的异常，而try-with-resource会保留第一个异常，并把后续的异常作为 Suppressed exceptions，可通过 getSuppressed() 获取这些异常信息。",
					"systemTag": "secbrella",
					"goodExample": "如下示例中，通过try-with-resource释放资源了。\ntry (FileInputStream in = new FileInputStream(inputFileName);\n     FileOutputStream out = new FileOutputStream(outputFileName)) {\n    copy(in, out);\n}\n",
					"badExample": "如下示例中，文件流在使用完后未释放资源。\nFileInputStream in = new FileInputStream(inputFileName);\nFileOutputStream out = new FileOutputStream(outputFileName);\ncopy(in, out);\n",
					"recommend": "使用try-with-resource特性释放资源。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EDV.01 禁止直接使用外部数据来拼接SQL语句",
					"language": "java",
					"id": "51c0d54a0fef11edad8584a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "SQL注入。\nSQL注入是指使用外部数据构造的SQL语句所代表的数据库操作与预期不符，这样可能会导致信息泄露或者数据被篡改。SQL注入产生的根本原因是使用外部数据直接拼接SQL语句，参数化查询是一种简单有效的防止SQL注入的查询方式，应该被优先考虑使用。另外，参数化查询还能提高数据库访问的性能，例如，SQL Server与Oracle数据库会为其缓存一个查询计划，以便在后续重复执行相同的查询语句时无需编译而直接使用。对于常用的ORM框架（如Hibernate、iBATIS等），同样支持参数化查询。",
					"systemTag": "secbrella",
					"goodExample": "PreparedStatement stmt = null;\nResultSet rs = null;\ntry {\n    String userName = request.getParameter(\"name\");\n    String password = request.getParameter(\"password\");\n    ... // 确保userName和password的长度是合法的\n    String sqlStr = \"SELECT * FROM t_user_info WHERE name=? AND password =?\";\n    stmt = connection.prepareStatement(sqlStr);\n    stmt.setString(1, userName);\n    stmt.setString(2, password);\n    rs = stmt.executeQuery();\n    ... // 结果集处理\n} catch (SQLException ex) {\n    // 处理异常\n}\n",
					"badExample": "Statement stmt = null;\nResultSet rs = null;\ntry {\n    String userName = request.getParameter(\"name\");\n    String password = request.getParameter(\"password\");\n    ...\n    String sqlStr = \"SELECT * FROM t_user_info WHERE name =  + userName\n        +  AND password =  + password + \";\n    stmt = connection.createStatement();\n    rs = stmt.executeQuery(sqlString);\n    ... // 结果集处理\n} catch (SQLException ex) {\n    // 处理异常\n}\n",
					"recommend": "SQL注入产生的根本原因是使用外部数据直接拼接SQL语句，防护措施主要有以下三 类\n1） 使用参数化查询：最有效的防护手段，但对SQL语句中的表名、字段名等不适用； \n2） 对外部数据进行白名单校验：适用于拼接SQL语句中的表名、字段名；\n3） 对外部数据中的与SQL注入相关的特殊字符（参考附录A）进行转义：适用于必须通过字符串拼接 构造SQL语句的场景，转义仅对由引号限制的字段有效。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "P.05 外部数据使用前必须进行合法性校验——信任边界场景",
					"language": "java",
					"id": "51c0d54c0fef11edbad284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "外部数据进入Map。\n\n来自程序外部的数据通常被认为是不可信的，在使用这些数据前需要进行合法性校验，否则可能会导致不正确的计算结果、运行时异常、不一致的对象状态，甚至引起各种注入攻击，对系统造成严重影响。当程序使可信赖和不可信赖的分界线模糊不清时，就会发生Trust Boundary Violation漏洞。",
					"systemTag": "secbrella",
					"goodExample": "",
					"badExample": "如下示例中，Map中将可信数据和不可信数据混合使用，会导致错误地信赖未验证的数据。\nvoid foo(HttpServletRequest request, HttpServletResponse response) {\n    String data = request.getCookies()[0].getValue();\n\n    Model model = new ConcurrentModel();\n    Map map = new HashMap();\n    map.put(\"data\", data);\n    map.put(\"name\", \"张三\")\n\n    model.mergeAttributes(map);\n}\n",
					"recommend": "使用白名单的方式对外部数据进行校验。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.CON.13 线程池中的任务结束后必须清理其自定义的 ThreadLocal 变量",
					"language": "java",
					"id": "51c0d54e0fef11edb75784a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "线程池中的任务结束后必须清理其自定义的ThreadLocal变量。\n\nThreadLocal基于弱引用实现，如果线程栈随着线程一起被JVM回收，ThreadLocal中存放的值也会在之后的GC被回收。而线程池技术则会重复使用线程以减少线程创建开销。\n这种线程的复用，导致ThreadLocal变量的使用存在以下两类问题：\n1.脏数据问题：当前任务未正确初始化ThreadLocal变量，导致ThreadLocal变量取到该线程之前执行的某一个任务中设置的未清除的值；\n2.内存泄露问题：任务中没有手动清理ThreadLocal中存放的值，且该线程池中的核心线程持有了ThreadLocal的引用，使得ThreadLocal中的值对象不会被JVM主动释放，最终造成这一片内存无法被回收从而导致内存泄露。",
					"systemTag": "secbrella",
					"goodExample": " 如下示例中，执行remove方法清理线程局部变量。\npublic class TestThreadLocal {\n    public static void main(String[] args) {\n        ThreadPoolExecutor pool = new ThreadPoolExecutor(1, 2, 100,\n             TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(),\n             Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());\n        for (int i = 0; i &lt; 20; i++) {\n            pool.execute(new TestThreadLocalTask());\n        }\n    }\n}\nclass TestThreadLocalTask implements Runnable {\n    private static ThreadLocal&lt;Integer&gt; localValue = new ThreadLocal&lt;&gt;();\n    @Override\n    public void run() {\n        localValue.set(STATE1);\n        try {\n            ...\n                localValue.set(STATE3);\n            ...\n        } finally {\n            localValue.remove(); // 需要执行remove方法清理线程局部变量，避免内存泄露\n        }\n    }\n}",
					"badExample": "如下示例中，ThreadLocal中一直会保存线程局部变量。\npublic class TestThreadLocal {\n    public static void main(String[] args) {\n        ThreadPoolExecutor pool = new ThreadPoolExecutor(1, 2, 100,\n             TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(),\n             Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());\n        for (int i = 0; i &lt; 20; i++) {\n            pool.execute(new TestThreadLocalTask());\n        }\n    }\n}\nclass TestThreadLocalTask implements Runnable {\n    private static ThreadLocal&lt;Integer&gt; localValue = new ThreadLocal&lt;&gt;();\n    @Override\n    public void run() {\n        localValue.set(STATE1);\n    }\n}",
					"recommend": "线程结束后必须调用ThreadLocal变量的remove方法。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EDV.02 禁止直接使用外部数据构造格式化字符串",
					"language": "java",
					"id": "51c0d5500fef11ed8f1084a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "直接使用外部数据构造格式化字符串。Java中的Format可以将对象按指定的格式转为某种格式的字符串，格式化字符串可以控制最终字符串的长度、内容、样式，当格式化字符串中指定的格式与格式对象不匹配时还可能会抛出异常。当攻击者可 以直接控制格式化字符串时，可导致信息泄露、拒绝服务、系统功能异常等风险。",
					"systemTag": "secbrella",
					"goodExample": "格式化字符串不含外部数据\npublic String formatInfo() {\n    String value = getData();\n    return String.format(\"my format: %s\", value));\n}",
					"badExample": "如下示例中，直接使用外部指定的格式对字符串数据进行格式化，当外部指定的格式为非字符类型如%d，会导致格式化操作出现异常。\npublic String formatInfo(String formatStr) {\n    String value = getData();\n    return String.format(formatStr, value));\n}\nString formatStr = req.getParameter(\"format\");\nString formattedValue = formatInfo(formatStr);",
					"recommend": "对外部数据白名单进行校验。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "P.05 外部数据使用前必须进行合法性校验——不安全地使用反射场景",
					"language": "java",
					"id": "51c0d5520fef11edac2484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "直接使用外部数据作为反射操作中的类名/方法名。\n\n反射操作中直接使用外部数据作为类名或方法名，会导致系统执行非预期的逻辑流程（Unsafe Reflection）。这可被恶意用户利用来绕过安全检查或执行任意代码。当反射操作需要使用外部数据时，必须对外部数据进行白名单校验，明确允许访问的类或方法列表；另外也可以通过让用户在指定范围内选择的方式进行防护。",
					"systemTag": "secbrella",
					"goodExample": "外部只能指定要反射的类的代号，当代号可映射为一个指定的类名时，执行反射操作，否则判断为非法参数。这样可以有效限制反射操作的类的范围。\nString classIndex = request.getParameter(\"classIndex\");\nString className = (String) reflectClassesMap.get(classIndex);\nif (className != null) {\n    Class objClass = Class.forName(className);\n    BaseClass obj = (BaseClass) objClass.newInstance();\n    obj.doSomething();\n} else {\n    throw new IllegalStateException(\"Invalid reflect class!\");\n}\n...",
					"badExample": "直接使用外部指定的类名通过反射构造了一个对象，恶意用户可利用此处构造一个任意的BaseClass子类的对象，当恶意用户可控制BaseClass的某个子类时，则可在该子类的 doSomething() 方法中执行任意代码。\nString className = request.getParameter(\"class\");\n...\nClass objClass = Class.forName(className);\nBaseClass obj = (BaseClass) objClass.newInstance();\nobj.doSomething();",
					"recommend": "使用白名单的方式对外部数据进行校验。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EDV.04 禁止直接使用外部数据来拼接XML——XML场景",
					"language": "java",
					"id": "51c0d5540fef11ed8f4484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "使用外部数据来拼接XML，XML注入。使用未经校验的数据来构造XML会导致XML注入漏洞。如果用户被允许输入结构化的XML片段，则用户 可以在XML的数据域中注入XML标签来改写目标XML文档的结构和内容，XML解析器会对注入的标签进 行识别和解释，引起注入问题。",
					"systemTag": "secbrella",
					"goodExample": "使用白名单的方式对外部数据进行校验，要求输入的userId中只能包含字母、数字或者下划线。\nprivate void createXMLStream(BufferedOutputStream outStream, User user)\n      throws IOException {\n// 仅当userID只包含字母、数字和下划线时写入XML字符串\nif (!Pattern.matches(\"[_a-bA-B0-9]+\", user.getUserId())) {\n// 处理错误\n}\nif (!Pattern.matches(\"[_a-bA-B0-9]+\", user.getDescription())) {\n// 处理错误\n}\nString xmlString = \"&lt;user&gt;&lt;id&gt;\" + user.getUserId()\n+ \"&lt;/id&gt;&lt;role&gt;operator&lt;/role&gt;&lt;description&gt;\"\n+ user.getDescription() + \"&lt;/description&gt;&lt;/user&gt;\";\noutStream.write(xmlString.getBytes(StandardCharsets.UTF_8));\noutStream.flush();\n}",
					"badExample": " 使用外部不可信数据user获取Id拼接xml。\nprivate void createXMLStream(BufferedOutputStream outStream, User user)\n    throws IOException {\n    String xmlString;\n    xmlString = \"&lt;user&gt;&lt;role&gt;operator&lt;/role&gt;&lt;id&gt;\" + user.getUserId()\n        + \"&lt;/id&gt;&lt;description&gt;\" + user.getDescription() + \"&lt;/description&gt;&lt;/user&gt;\";\n    ... // 解析xml字符串\n}\n如上示例中，当恶意用户使用joeadministratorjoe作为用户ID，使用正常的输入I want to be an administrator作为描述字段。最终构造出的整个XML字符串将变成如下形式，导致此用户角色由操作员提升为了管理员。\n\n&lt;user&gt;\n    &lt;role&gt;operator&lt;/role&gt;\n    &lt;id&gt;joe&lt;/id&gt;\n    &lt;role&gt;administrator&lt;/role&gt;\n    &lt;id&gt;joe&lt;/id&gt;\n    &lt;description&gt;I want to be an administrator&lt;/description&gt;\n&lt;/user&gt;\n",
					"recommend": "使用白名单的方式对外部数据进行校验。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "G.EDV.04 禁止直接使用外部数据来拼接XML——Xpath场景",
					"language": "java",
					"id": "51c0d5560fef11ed97cf84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "0",
					"comments": "外部输入导致XPath表达式注入。直接使用外部数据更改 XPath 查询的意图，此漏洞会造成信息泄露或允许对应用程序功能进行未经授权的访问。",
					"systemTag": "secbrella",
					"goodExample": "",
					"badExample": "如下示例中，通过用户提供的（被污染的）数据用户名和密码注入了 XPath 查询。如果攻击者的用户名为 admin 并且密码为 ' or @loginID='admin，则完整的 XPath 查询现在为 /employees/employee[@loginID='admin' and @passwd='' or @loginID='admin']。如果此查询被用于验证用户身份，攻击者可能会被验证为管理员用户。\npublic void xpathInjection() {\n    XPathFactory factory = XPathFactory.newInstance();\n    XPath xPath = factory.newXPath();\n    String expression = \"/employees/employee[@loginID='\" + username + \"' and @passwd='\" + password + \"']\";\n    nodes = (NodeList) xPath.evaluate(expression, inputSource, XPathConstants.NODESET);\n}",
					"recommend": "使用白名单的方式对外部数据进行校验。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Improper_HTTPS_Cookie_Secure_Attribute",
					"language": "java",
					"id": "51c0fcb30fef11ed8c2284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "没有设置Https的Cookie的secure属性为真。\n\nCookie的secure标志是应用服务器发送新cookie给客户端时的一个可选设置项，设置cookie的secure标志，用于指示浏览器只有在https（加密协议）下才能发送该cookie，禁止在http（明文协议）下发送该cookie，以防止cookie在http（明文协议）下被嗅探。",
					"systemTag": "secbrella",
					"goodExample": "创建cookie时将Secure属性设置为true。\npublic void createCookie(HttpServletResponse response) {\n    Cookie userCookie = new Cookie(\"cookie\", \"FileName\");\n    userCookie.setSecure(true);\n    response.addCookie(userCookie);\n}\n",
					"badExample": "创建了cookie，但是未将Secure属性设置为true。\npublic void createCookie(HttpServletResponse response) {\n    Cookie userCookie = new Cookie(\"\"cookie\"\", \"\"FileName\"\");\n    userCookie.setSecure(false);\n    /* 创建了cookie，但未将secure标记设置为TRUE */\n    response.addCookie(userCookie);\n}\"",
					"recommend": "cookie设置secure属性为true。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Android_Improper_WebView_WebContentsDebuggingEnabled",
					"language": "java",
					"id": "51c0fcb50fef11edb92184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "WebView把内容设置为调试模式。启用加载到此应用程序WebView中的Web内容（HTML/CSS/JavaScript）的调试，存在安全风险。",
					"systemTag": "secbrella",
					"goodExample": "下面的代码中setWebContentsDebuggingEnabled参数为false。\npublic void setWebviewDebuggingEnabled() {\n    /* webView的属性WebContentsDebuggingEnabled设置为false */\n    WebView.setWebContentsDebuggingEnabled(false);\n}\n",
					"badExample": "下面代码中setWebContentsDebuggingEnabled参数为true。\npublic void setWeviewDebuggingEnabled() {\n    /* webView的属性WebContentsDebuggingEnabled设置为true，存在安全风险 */\n    WebView.setWebContentsDebuggingEnabled(true);\n}\n",
					"recommend": "不要将WevView的属性WebContentsDebuggingEnabled设置为true。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Missing_Nullable_Annotation",
					"language": "java",
					"id": "51c0fcb70fef11ed966b84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "字段可以为null，但未声明为@Nullable。",
					"systemTag": "secbrella",
					"goodExample": "str字段赋值为null，声明为@Nullable。\npublic class Foo {\n    @Nullable\n    private String str = null;\n}\n",
					"badExample": "str字段赋值为null，未声明为@Nullable。\npublic class Foo {\n    private String str = null;\n}\n",
					"recommend": "可以为null的字段声明为@Nullable。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Immutable_Cast",
					"language": "java",
					"id": "51c0fcb90fef11edb68184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "3",
					"comments": "从返回可变类型数据的方法返回了不可变类型的数据。",
					"systemTag": "secbrella",
					"goodExample": "方法声明的返回类型是List，return语句的返回类型是ArrayList。\npublic List&lt;String&gt; getSomeList() {\n    return new ArrayList&lt;&gt;();\n}\n",
					"badExample": "方法声明的返回类型是List，return语句的返回类型是ImmutableList。\npublic List&lt;String&gt; getSomeList() {\n    return ImmutableList.of();\n}\n",
					"recommend": "不要从类型为可变的方法返回不可变集合。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Improper_HTTP_Header_Access_Control_Allow_Origin",
					"language": "java",
					"id": "51c0fcbb0fef11ed968a84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "HTTP header的Access-Control-Allow-Origin属性被设置成*。\n\nAccess-Control-Allow-Origin响应头指定了该响应的资源是否被允许与给定的origin共享, 不能设置成*。若设置为*，则允许所有域都能访问。",
					"systemTag": "secbrella",
					"goodExample": " Access-Control-Allow-Origin 响应头指定了该响应的资源不要设置成*。\npublic void setHttpResponse(HttpServletRequest request, HttpServletResponse response) {\n    /* Access-Control-Allow-Origin */\n    response.setHeader(\"Access-Control-Allow-Origin\", \"\");\n}",
					"badExample": "Access-Control-Allow-Origin 响应头指定了该响应的资源设置成*。\npublic void setHttpResponse(HttpServletRequest request, HttpServletResponse response) {\n    /* Access-Control-Allow-Origin */\n    response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n}",
					"recommend": "Access-Control-Allow-Origin 响应头指定了该响应的资源不要设置成*。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Improper_Web_Configuration_cors.allowed.methods",
					"language": "java",
					"id": "51c0fcbd0fef11ed9b0c84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "web.xml的CorsFilter配置cors.allowed.methods不允许包含GET和POST之外的方法。",
					"systemTag": "secbrella",
					"goodExample": "web.xml中的CorsFilter中&lt;cors.allowed.methods&gt;标签只包含了GET、POST方法。\n&lt;filter&gt;\n    &lt;filter-name&gt;CORS Filter3&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.apache.catalina.filters.CorsFilter&lt;/filter-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.origins&lt;/param-name&gt;\n        &lt;param-value&gt;http://192.168.56.129,http://192.168.56.130&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.methods&lt;/param-name&gt;\n        &lt;param-value&gt;GET,POST&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.headers&lt;/param-name&gt;\n        &lt;param-value&gt;Content-Type,X-Requested-With,accept,Origin,Access-Control-Request-Method,Access-Control-Request-Headers&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n&lt;filter&gt;\n    &lt;filter-name&gt;CORS Filter4&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.apache.catalina.filters.CorsFilter&lt;/filter-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.origins&lt;/param-name&gt;\n        &lt;param-value&gt;http://192.168.56.129,http://192.168.56.130&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.methods&lt;/param-name&gt;\n        &lt;param-value&gt;GET&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.headers&lt;/param-name&gt;\n        &lt;param-value&gt;Content-Type,X-Requested-With,accept,Origin,Access-Control-Request-Method,Access-Control-Request-Headers&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n&lt;filter&gt;\n    &lt;filter-name&gt;CORS Filter5&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.apache.catalina.filters.CorsFilter&lt;/filter-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.origins&lt;/param-name&gt;\n        &lt;param-value&gt;http://192.168.56.129,http://192.168.56.130&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.methods&lt;/param-name&gt;\n        &lt;param-value&gt;POST&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.headers&lt;/param-name&gt;\n        &lt;param-value&gt;Content-Type,X-Requested-With,accept,Origin,Access-Control-Request-Method,Access-Control-Request-Headers&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n",
					"badExample": "web.xml中的CorsFilter中&lt;cors.allowed.methods&gt;标签包含了GET、POST之外的方法。\n&lt;filter&gt;\n    &lt;filter-name&gt;CORS Filter0&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.apache.catalina.filters.CorsFilter&lt;/filter-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.origins&lt;/param-name&gt;\n        &lt;param-value&gt;http://192.168.56.129,http://192.168.56.130&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;!-- unsafe method except get and post --&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.methods&lt;/param-name&gt;\n        &lt;param-value&gt;GET,POST,HEAD,OPTIONS,PUT&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.headers&lt;/param-name&gt;\n        &lt;param-value&gt;Content-Type,X-Requested-With,accept,Origin,Access-Control-Request-Method,Access-Control-Request-Headers&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n&lt;filter&gt;\n    &lt;filter-name&gt;CORS Filter1&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.apache.catalina.filters.CorsFilter&lt;/filter-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.origins&lt;/param-name&gt;\n        &lt;param-value&gt;http://192.168.56.129,http://192.168.56.130&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;!-- unsafe method except get and post --&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.methods&lt;/param-name&gt;\n        &lt;param-value&gt;OPTIONS,PUT&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.headers&lt;/param-name&gt;\n        &lt;param-value&gt;Content-Type,X-Requested-With,accept,Origin,Access-Control-Request-Method,Access-Control-Request-Headers&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n&lt;filter&gt;\n    &lt;filter-name&gt;CORS Filter2&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.apache.catalina.filters.CorsFilter&lt;/filter-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.origins&lt;/param-name&gt;\n        &lt;param-value&gt;http://192.168.56.129,http://192.168.56.130&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;!-- unsafe method except get and post --&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.methods&lt;/param-name&gt;\n        &lt;param-value&gt;PUT&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.headers&lt;/param-name&gt;\n        &lt;param-value&gt;Content-Type,X-Requested-With,accept,Origin,Access-Control-Request-Method,Access-Control-Request-Headers&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n",
					"recommend": "web.xml中的CorsFilter过滤器&lt;cors.allowed.methods&gt;标签不要包含GET、POST之外的不安全的请求方法。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Improper_Web_Configuration_cors.allowed.origins",
					"language": "java",
					"id": "51c0fcbf0fef11eda91384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "web.xml的CorsFilter参数cors.allowed.origins不允许为“*”。Web系统允许跨域访问，但CorsFilter配置为“*”，允许任意域访问，存在安全风险，且支持不安全的HTTP方法。",
					"systemTag": "secbrella",
					"goodExample": "web.xml中的CorsFilter初始化参数不要设置成*。\n&lt;filter&gt;\n    &lt;filter-name&gt;CORS Filter3&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.apache.catalina.filters.CorsFilter&lt;/filter-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.origins&lt;/param-name&gt;\n        &lt;param-value&gt;http://192.168.56.129,http://192.168.56.130&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n",
					"badExample": "web.xml中的CorsFilter初始化参数设置成*。\n&lt;!-- do not allow set * to filter's CorsFilter --&gt;\n&lt;filter&gt;\n    &lt;filter-name&gt;MyFilter1&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.apache.catalina.filters.CorsFilter&lt;/filter-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;cors.allowed.origins&lt;/param-name&gt;\n        &lt;param-value&gt;*&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n",
					"recommend": "web.xml中的CorsFilter初始化参数不要设置成*。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Improper_HTTP_Content-Security-Policy",
					"language": "java",
					"id": "51c0fcc10fef11eda5ca84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "HTTP header信息的Content-Security-Policy的字段设置不当。\n\nContent-Security-Policy响应头提供一种以可信白名单机制来限制网站加载的资源，缓解广泛的内容注入漏洞，比如XSS。",
					"systemTag": "secbrella",
					"goodExample": "下面代码中调用setHeader方法，Content-Security-Policy设置成default-src self。\npublic void sethttpResponse(HttpServletRequest request, HttpServletResponse response) {\n    response.setHeader(\"Content-Security-Policy\",\"default-src self\");\n}",
					"badExample": "下面代码中调用setHeader方法，Content-Security-Policy设置成unsafe-inline。\npublic void setHttpResponse(HttpServletRequest request, HttpServletResponse response) {\n    /* Content-Security-Policy */\n    response.setHeader(\"Content-Security-Policy\",\"unsafe-inline\");\n}",
					"recommend": "不要设置参数Content-Security-Policy为'unsafe-inline'或'unsafe-eval'。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Weak_Encryption_Inadquate_Length_HMAC256",
					"language": "java",
					"id": "51c0fcc30fef11ed9b5b84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "调用javax.net.ssl.SSLContext类的getInstance方法，参数使用了非安全的SSL3.0协议。",
					"systemTag": "secbrella",
					"goodExample": "generateDerivedMacParameters方法参数大于等于256。\npublic CipherParameters getCipherParameters() {\n    PKCS5S2ParametersGenerator pkcs5S2ParametersGenerator = new PKCS5S2ParametersGenerator(new SHA256Digest());\n    CipherParameters cipherParameters = pkcs5S2ParametersGenerator.generateDerivedMacParameters(256);\n    return cipherParameters;\n}",
					"badExample": "generateDerivedMacParameters方法参数小于256。\npublic CipherParameters getCipherParameters() {\n    PKCS5S2ParametersGenerator pkcs5S2ParametersGenerator = new PKCS5S2ParametersGenerator(new SHA256Digest());\n    /* Key Length less than 256. */\n    CipherParameters cipherParameters = pkcs5S2ParametersGenerator.generateDerivedMacParameters(255);\n    return cipherParameters;\n}",
					"recommend": "使用hmac256消息签名的key的长度应大于等于32字节，即256。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Andirod_Improper_WebView_MixedContentMode",
					"language": "java",
					"id": "51c0fcc50fef11eda54884a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "WebView把混合内容模式设置为非MIXED_CONTENT_NEVER_ALLOW模式。webSettings的setMixedContentMode内容配置参数不是WebSettings.MIXED_CONTENT_NEVER_ALLOW，存在中间人攻击风险。",
					"systemTag": "secbrella",
					"goodExample": "setMixedContentMode内容配置参数为WebSettings.MIXED_CONTENT_NEVER_ALLOW。\npublic void setWebViewContentMode01() {\n    WebView.setMixedContentMode(WebSettings.MIXED_CONTENT_NEVER_ALLOW);\n}\n",
					"badExample": "setMixedContentMode内容配置参数不为WebSettings.MIXED_CONTENT_NEVER_ALLOW。\npublic void setWebViewContentMode01() {\n    /* unused MIXED_CONTENT_NEVER_ALLOW */\n    WebView.setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);\n}\n",
					"recommend": "配置webSettings的setMixedContentMode内容配置参数为WebSettings.MIXED_CONTENT_NEVER_ALLOW。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Improper_X-XSS-Protection_Setting",
					"language": "java",
					"id": "51c123c20fef11edaddb84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "未启用浏览器的XSS防护（X-XSS-Protection：0表示关闭XSS防护）。\n\nX-XSS-Protection：1（默认），开启XSS防护。",
					"systemTag": "secbrella",
					"goodExample": " 删除设置0的代码。\npublic void setHttpResponse(HttpServletRequest request, HttpServletResponse response) {\n    /* X-XSS-Protection */\n    response.setHeader(\"X-XSS-Protection\", \"1\");\n}",
					"badExample": "X-XSS-Protection设置成0。\npublic void setHttpResponse(HttpServletRequest request, HttpServletResponse response) {\n    /* X-XSS-Protection */\n    response.setHeader(\"X-XSS-Protection\", \"0\");\n}",
					"recommend": "X-XSS-Protection : 0 表示禁用 XSS过滤功能。请删除该代码，默认是1。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Improper_ThreadSafe_Annotation_Interface",
					"language": "java",
					"id": "51c123c40fef11edb4a684a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "标记为@ThreadSafe的类，其接口也需要标记为@ThreadSafe。\n\n从线程安全上下文（例如，使用锁或标记为@ThreadSafe的代码）不要调用未使用@ThreadSafe注解的接口方法。",
					"systemTag": "secbrella",
					"goodExample": " class C 声明为@ThreadSafe，interface I 也声明为@ThreadSafe。\npublic class Foo {\n    @ThreadSafe\n    interface I {\n        void bar();\n    }\n    @ThreadSafe\n    class C {\n        void foo(I i) {\n            i.bar();\n        }\n    }\n}",
					"badExample": " class C 声明为@ThreadSafe，interface I 未声明为@ThreadSafe。\npublic class Foo {\n    interface I {\n        void bar();\n    }\n    @ThreadSafe\n    class C {\n        void foo(I i) {\n            i.bar();\n        }\n    }\n}",
					"recommend": "从线程安全上下文（例如，使用锁或标记为@ThreadSafe的代码）调用使用了@ThreadSafe注解的接口方法。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Missing_XML_Validation",
					"language": "java",
					"id": "51c123c60fef11edb49b84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "软件接受来自不受信任源的XML，但不根据正确的Schema验证XML。",
					"systemTag": "secbrella",
					"goodExample": "如下示例中，xml解析启动了Schema校验功能。\ntry {\n    ...\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n    factory.setValidating(true);\n    ....\n        c_dom = factory.newDocumentBuilder().parse(xmlFile);\n} catch(Exception e) {\n    ...\n}",
					"badExample": "如下示例中，xml解析没有启动Schema校验功能。\ntry {\n    ...\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n    factory.setValidating(false);\n    ....\n        c_dom = factory.newDocumentBuilder().parse(xmlFile);\n} catch(Exception e) {\n    ...\n}\n",
					"recommend": "解析 XML 时，务必启用Schema验证功能。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Android_Pass_Explicit_Intents_to_PendingIntent",
					"language": "java",
					"id": "51c123c80fef11edb8b284a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "不正确的初始化Intent。\n使用PendingIntent触发事件时须传入显式Intent。\nPendingIntent是一种特殊的Intent，用来启动特定情境下触发的事件。当A应用设定一个原始Intent，并据此创建PendingIntent，然后将其传递给B应用时， B应用就持有PendingIntent，可以执行A应用预设的操作，并拥有A应用同样的权限（with the same Permission and identity）。 因此，A应用应当小心设置原始Intent，在Intent中显示指定目的Component名称的方式，可以防止被恶意应用程序劫持，造成权限泄露。",
					"systemTag": "secbrella",
					"goodExample": "设置包名类名或者初始化参数或者设置的setAction匹配(android|com.android)..*。\npublic void setActivity01() {\n /* intent 含有class参数 */\n    Intent intent = new Intent(this, NotifyingController.class);\n    PendingIntent contentIntent = PendingIntent.getActivity(this, 0, intent, 0);\n}\n",
					"badExample": "未设置包名类名且初始化参数或者设置的setAction不匹配(android|com.android)..*。\npublic void setActivity01() {\n   /* 初始化的intent只有一个参数，且没有setClass等操作，且设置了初始化的参数不匹配(android|com.android)..* */    \n   Intent intent = new Intent(\"androidx.app.xxx\");\n   PendingIntent contentIntent = PendingIntent.getActivity(this, 0, intent, 0);\n}\n",
					"recommend": "get(Activity|Service|Broadcast)方法使用初始化的intent后设置类名或包名。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Exposure_Private_Personal_Information",
					"language": "java",
					"id": "51c123ca0fef11eda80a84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "隐私泄露。程序直接将隐私信息（比如：密码、身份证号、信用卡号、位置信息等）写入文件或日志中，造成信息泄露风险。",
					"systemTag": "secbrella",
					"goodExample": "",
					"badExample": "如下示例中，直接将用户密码信息写入到文件中，导致账号信息泄露。\nchar[] password = System.console().readPassword();\nString data = new String(password);\ntry {\n    /* POTENTIAL FLAW: Privacy Violation */\n    Files.write(new File(\"text.txt\").toPath(), data.getBytes());\n} catch (IOException e) {\n    IO.writeLine(e.getMessage());\n}\n",
					"recommend": "不应允许应用程序、流程处理以及员工访问任何隐私数据。如果需要记录或访问隐私信息，对日志进行匿名化处理；对文件处理时，确保读写文件可控。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Improper_ThreadSafe_Annotation",
					"language": "java",
					"id": "51c123cc0fef11ed85be84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "ThreadSafe注解用在非线程安全的类上。",
					"systemTag": "secbrella",
					"goodExample": "读写字段mBalance已同步。\n@ThreadSafe\npublic class Foo {\n    int mBalance = 0;\n    public synchronized void deposit(int amount) {\n        if (amount &gt; 0) {\n            mBalance += amount;\n        }\n    }\n    public synchronized int withdraw(int amount) {\n        if (amount &gt;= 0 && mBalance - amount &gt;= 0) {\n            mBalance -= amount;\n            return mBalance;\n        } else {\n            return 0;\n        }\n    }\n}",
					"badExample": " 读写字段mBalance未同步。\n@ThreadSafe\npublic class Foo {\n    int mBalance = 0;\n    public void deposit(int amount) {\n        if (amount &gt; 0) {\n            mBalance += amount;\n        }\n    }\n    public int withdraw(int amount) {\n        if (amount &gt;= 0 && mBalance - amount &gt;= 0) {\n            mBalance -= amount;\n            return mBalance;\n        } else {\n            return 0;\n        }\n    }\n}",
					"recommend": "读写字段需要同步。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Android_Improper_UiThread_Annotation",
					"language": "java",
					"id": "51c123ce0fef11ed8abe84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "将非UI线程通过注解@UiThread标记为UI线程。\n\n运行该线程可能会阻塞，从而导致应用程序响应错误。",
					"systemTag": "secbrella",
					"goodExample": "类Foo未声明为@UiThread。\npublic class Foo {\n    public void bar() throws RemoteException {\n        Binder binder = new Binder();\n        binder.transact(0, null, null, 0);\n    }\n}\n",
					"badExample": "类Foo声明为@UiThread，类中调用了阻塞方法android.os.Binder.transact(...)。\n@UiThread\npublic class Foo {\n    public void bar() throws RemoteException {\n        Binder binder = new Binder();\n        binder.transact(0, null, null, 0);\n    }\n}\n",
					"recommend": "不要把非UI线程，标记为@UiThread。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Improper_Guarded_Annotation",
					"language": "java",
					"id": "51c123d00fef11ed9f6e84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "访问@GuardedBy(锁)注解的字段或方法时，需要持有相应的锁。",
					"systemTag": "secbrella",
					"goodExample": "访问字段时持有相应的锁。\npublic class Foo {\n    @GuardedBy(\"this\")\n    int y;\n    void goo() {\n        synchronized (this) {\n            y = 83;\n        }\n    }\n}\n",
					"badExample": "访问字段时未持有相应的锁。\npublic class Foo {\n    @GuardedBy(\"this\")\n    int y;\n    void goo() {\n        y = 83;\n    }\n}\n",
					"recommend": "访问已使用@GuardedBy(锁)注解的字段或方法，需要持有相应的锁。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Unsafe_TLS_Protocol",
					"language": "java",
					"id": "51c123d20fef11ed8ac384a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "使用不安全的TLS协议。",
					"systemTag": "secbrella",
					"goodExample": "下面的代码中调用javax.net.ssl.SSLContext类的getInstance方法，参数是TLSv1.2。\npublic void safeSSLContext() throws NoSuchAlgorithmException {\n    /* 调用了SSLContext的getInstance方法，参数是TLSv1.2、TLSv1.3 */\n    SSLContext.getInstance(\"TLSv1.2\");\n}",
					"badExample": "下面代码中调用javax.net.ssl.SSLContext类的getInstance方法，参数不是TLSv1.2、TLSv1.3。\npublic void unsafeSSLContext01() throws NoSuchAlgorithmException {\n    /* 调用了SSLContext的getInstance方法，参数不是TLSv1.2、TLSv1.3 */\n    SSLContext.getInstance(\"TLSv\");\n}",
					"recommend": "调用javax.net.ssl.SSLContext类的getInstance方法，参数使用TLSv1.2、TLSv1.3。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Externally_Controlled_Hash_Algorithm",
					"language": "java",
					"id": "51c123d40fef11eda42484a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "外部控制的哈希算法。使用外部不可信的数据来初始化哈希算法。",
					"systemTag": "secbrella",
					"goodExample": "使用外部不可信数据algorithm初始化hash算法。\npublic void userControlledAlgorithm() throws Throwable {\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(\"file\"));\n    String algorithm = properties.getProperty(\"hashAlg2\");\n    /* Weak Cryptographic Hash: User-Controlled Algorithm */\n    MessageDigest md = MessageDigest.getInstance(algorithm);\n}\n",
					"badExample": "对外部不可信数据algorithm进行校验。\npublic void userControlledAlgorithm() throws Throwable {\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(\"file\"));\n    String algorithm = properties.getProperty(\"hashAlg2\");\n    /* valid the algorithm */\n    if (isSafeAlgorithm(algorithm)) {\n        MessageDigest md = MessageDigest.getInstance(algorithm);\n    }            \n}\n",
					"recommend": "对外部参数进行白名单校验。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Weak_Encryption_CRC32",
					"language": "java",
					"id": "51c123d60fef11ed844b84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "1",
					"comments": "使用CRC32用于加密。\n\n使用CRC32加密算法，存在安全风险。",
					"systemTag": "secbrella",
					"goodExample": "下面的代码中使用SHA256加密算法\npublic void safeEncryption() throws NoSuchAlgorithmException {\n    String str = \"123\";\n    /* 使用sha256加密算法 */\n    MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n    messageDigest.update(str.getBytes(StandardCharsets.UTF_8));\n}",
					"badExample": "下面代码中调用CRC32构造方法进行加密。\npublic void unsafeEncryption() {\n    String str = \"123\";\n    /* 使用CRC32加密算法，存在安全风险 */\n    CRC32 crc32 = new CRC32();\n    crc32.update(str.getBytes());\n    Long.toString(crc32.getValue());\n}\n",
					"recommend": "使用SHA256等算法替换CRC32算法。",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "common",
					"isChecked": true
				},
				{
					"name": "Forbid_Hard-coded_Password",
					"language": "java",
					"id": "51c14ae80fef11ed909184a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "硬编码的秘密可能会被滥用以获取未经授权的访问并破坏安全边界。",
					"systemTag": "codemars",
					"goodExample": "",
					"badExample": "错误示例\nprivate void test_noncompliant() {\n        String DB_passwd = \"Password1\"; // Noncompliant\n        String dbpassword = \"Password1\"; // Noncompliant\n        String password = \"Password1\"; // Noncompliant\n        // String password = \"Password1\"; // Noncompliant\n        final String PASSWORD = \"Password1\"; // Noncompliant\n        password = \"Password1\"; // Noncompliant\n        String passwd = \"Password1\"; // Noncompliant\n        // String passwd = \"Password1\"; // Noncompliant\n        final String PASSWD = \"Password1\"; // Noncompliant\n        passwd = \"Password1\"; // Noncompliant\n        String pwd = \"Password1\"; // Noncompliant\n        // String pwd = \"Password1\"; // Noncompliant\n        final String PWD = \"Password1\"; // Noncompliant\n        pwd = \"Password1\"; // Noncompliant\n        // already in a class\n        // no default function parameter values in Java\n        // no native JSON support in Java\n        if (password == \"admin\") {} // Noncompliant\n        if (passwd == \"admin\") {} // Noncompliant\n        if (pwd == \"admin\") {} // Noncompliant\n}",
					"recommend": "不要使用硬编码",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "Forbid_Hard-coded_Api_Credentials",
					"language": "java",
					"id": "51c14aea0fef11ed93f984a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "硬编码的 API 密钥可能被滥用以获取对私有服务的未经授权的访问。\n",
					"systemTag": "codemars",
					"goodExample": "",
					"badExample": "错误示例\nprivate void test_noncompliant() {\n        TRAVEL_API_KEY = \"912ec803b2ce49e4a541068d495ab570\"; // Noncompliant\n        String ApiKey = \"912ec803b2ce49e4a541068d495ab570\"; // Noncompliant\n        String apikey = \"apikey\"; // Noncompliant\n        final String api_key = \"YXNkZmZmZmZm_YXNkZmZmZmZm\"; // Noncompliant\n        apiKey = \"912ec803b2ce49e4a541068d495ab570\"; // Noncompliant\n        PRIVATE_API_TOKEN = \"912ec803b2ce49e4a541068d495ab570\"; // Noncompliant\n        String ApiToken = \"912ec803b2ce49e4a541068d495ab570\"; // Noncompliant\n        String apitoken = \"apitoken\"; // Noncompliant\n        final String api_token = \"YXNkZmZmZmZm_YXNkZmZmZmZm\"; // Noncompliant\n        apiToken = \"912ec803b2ce49e4a541068d495ab570\"; // Noncompliant\n        SKYSCANNER_API_SECRET = \"912ec803b2ce49e4a541068d495ab570\"; // Noncompliant\n        String ApiSecret = \"912ec803b2ce49e4a541068d495ab570\"; // Noncompliant\n        String apisecret = \"apisecret\"; // Noncompliant\n        final String api_secret = \"YXNkZmZmZmZm_YXNkZmZmZmZm\"; // Noncompliant\n        apiSecret = \"912ec803b2ce49e4a541068d495ab570\"; // Noncompliant\n        String GITLAB_TOKEN = \"YXNkZmZmZmZm_YXNkZmZmZmZm\"; // Noncompliant\n        String GITHUB_SECRET = \"YXNkZmZmZmZm_YXNkZmZmZmZm\"; // Noncompliant\n        final String slack_key = \"YXNkZmZmZmZm_YXNkZmZmZmZm\"; // Noncompliant\n        Google_token = \"YXNkZmZmZmZm_YXNkZmZmZmZm\"; // Noncompliant\n        // already in a class\n        // no default function parameter values in Java\n        // no native JSON support in Java\n        if (apikey == \"YXNkZmZmZmZm_YXNkZmZmZmZm\") {} // Noncompliant\n        if (api_key == \"912ec803b2ce49e4a541068d495ab570\") {} // Noncompliant\n        if (apitoken == \"YXNkZmZmZmZm_YXNkZmZmZmZm\") {} // Noncompliant\n        if (api_token == \"912ec803b2ce49e4a541068d495ab570\") {} // Noncompliant\n        if (apisecret == \"YXNkZmZmZmZm_YXNkZmZmZmZm\") {} // Noncompliant\n        if (api_secret == \"912ec803b2ce49e4a541068d495ab570\") {} // Noncompliant\n    }",
					"recommend": "不要硬编码API 密钥",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				},
				{
					"name": "Forbid_Hard-coded_AK_Credentials",
					"language": "java",
					"id": "51c14aec0fef11edb5cb84a93e798437",
					"nodeType": "criterion",
					"parentId": "",
					"linkUrl": "",
					"severity": "2",
					"comments": "硬编码的AccessKey机密可能会被滥用以获取隐私数据",
					"systemTag": "codemars",
					"goodExample": "",
					"badExample": "错误示例\nprivate void test() {\n        String id = \"LTAIabcdefghabcd123a\";\n    }",
					"recommend": "不要硬编码AccessKey机密",
					"demo": "",
					"typeName": "",
					"optionInfos": [],
					"criterionType": "security",
					"isChecked": true
				}
			],
			"ruleSetName": "华为云规范(Java语言)",
			"updateTime": "2021-09-30 00:00:00",
			"ruleSetId": "java_rules",
			"ruleSetUrl": "",
			"language": "java"
		}
	],
	"customParameters": []
}